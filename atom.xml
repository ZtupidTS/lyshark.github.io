<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哔哩哔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://localhost/"/>
  <updated>2019-09-07T04:26:10.000Z</updated>
  <id>https://localhost/</id>
  
  <author>
    <name>王瑞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++反汇编: 基础知识(7)</title>
    <link href="https://localhost/2019/09/07/C-%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-7/"/>
    <id>https://localhost/2019/09/07/C-反汇编-基础知识-7/</id>
    <published>2019-09-07T04:18:41.000Z</published>
    <updated>2019-09-07T04:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>反汇编(Disassembly),即把目标二进制机器码转为汇编代码的过程,该技术常用于软件破解、外挂技术、病毒分析、逆向工程、软件汉化等领域,学习和理解反汇编语言对软件调试、漏洞分析、内核原理及理解高级语言代码都有相当大的帮助,软件一切神秘的运行机制全在反汇编代码里面,该笔记整理了C++反汇编的一些常识.</p><a id="more"></a><p><br></p><p>1.寻找Main函数<br>2.数据类型<br>3.优化加减乘除</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反汇编(Disassembly),即把目标二进制机器码转为汇编代码的过程,该技术常用于软件破解、外挂技术、病毒分析、逆向工程、软件汉化等领域,学习和理解反汇编语言对软件调试、漏洞分析、内核原理及理解高级语言代码都有相当大的帮助,软件一切神秘的运行机制全在反汇编代码里面,该笔记整理了C++反汇编的一些常识.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编PE结构剖析(6)</title>
    <link href="https://localhost/2019/06/25/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96PE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90-6/"/>
    <id>https://localhost/2019/06/25/汇编与反汇编/Win32汇编PE结构剖析-6/</id>
    <published>2019-06-25T01:34:16.000Z</published>
    <updated>2019-09-07T00:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><p>PE格式是Windows系统下最常用的可执行文件格式,有些应用必须建立在了解PE文件格式的基础之上,如可执行文件的加密与解密,文件型病毒的查杀等,熟练掌握PE文件结构,有助于软件的分析.</p><a id="more"></a><p><br></p><h2 id="PE-结构概述"><a href="#PE-结构概述" class="headerlink" title="PE 结构概述"></a>PE 结构概述</h2><p>在操作系统中,可执行的代码在被最终装载进内存执行之前是以文件的方式存放在磁盘中的,早期DOS操作系统中,是以.com文件的格式存储的,com文件限制了只能使用代码段,<code>堆栈寻址</code>也被限制在了<code>64KB</code>的段中,这样极大的限制了软件的发展.</p><p>为了应对这种局面,出现了另一种可执行文件,那就是我们所熟悉的<code>exe文件</code>,exe文件在代码前面加了一个<code>文件头</code>,文件头中包括各种说明数据,如程序的入口地址,堆栈的位置,重定位表等,显然可执行文件的格式是操作系统工作方式的写照,不同的系统之间文件格式千差万别,从而导致不同系统中的可执行文件无法跨平台运行.</p><p>当Windows3x出现的时候,可执行文件出现了<code>32位</code>代码,程序运行时会转到保护模式执行,所以Windows3x使用了新的LE格式的可执行文件<code>(Linear Executable/线性可执行文件)</code>,而在Windows NT系统中可执行文件则使用微软设计的新的文件格式,也就是现在还在使用的PE格式<code>(Portable Executable File Format/可移植的执行体)</code>.</p><p>PE文件的基本结构如下所示,在PE文件中,代码,已初始化的数据,资源和重定位信息等数据被按照属性分类放到不同的<code>Section(节区/或简称为节)</code>中,而每个节区的属性和位置等信息用一个<code>IMAGE_SECTION_HEADER</code>结构来描述,所有的<code>IMAGE_SECTION_HEADER</code>结构组成了一个<code>节表(Section Table)</code>,节表数据在PE文件中被放在所有节数据的前面.</p><p><img src="/picture/20190625093903.jpg" alt="blockchain"></p><p>在Win32系统中,当我们执行了可执行文件之后,可执行文件会被映射到内存,并且以4kb的粒度进行对齐,这个4kb也就是一个页面的大小,而每个页面又分别具有,可执行,可读写等属性.</p><p>在PE文件中将同样属性的数据分类放在一起是为了统一描述这些数据装入内存后的页面属性,由于数据是按照属性在节中放置的,不同用途但是属性相同的数据可能被放在同一个节中,PE文件头被放置在节和节表的前面,上面介绍的是真正的PE文件,为了兼容以前的DOS系统,所以保留了DOS的文件格式,接下来将依次介绍这几种数据结构.</p><h3 id="◆DOS头结构◆"><a href="#◆DOS头结构◆" class="headerlink" title="◆DOS头结构◆"></a>◆DOS头结构◆</h3><p>从上面的PE结构图中,PE文件的开头部分包括了一个标准的DOS可执行文件结构,这看上去有些奇怪,但是这对于可执行文件的向下兼容性来说却是不可缺少的.</p><p>操作系统识别可执行文件的方法是按照文件格式而不是扩展名来识别的,就是因为其识别文件看的是文件格式,所以就算你将exe可执行文件改成bat,scr等其他格式,PE文件加载器依然可以识别出这是一个可执行文件,但是,如果不去兼容DOS结构,那么在DOS下运行PE文件的话,则系统一定会崩盘,为了避免这一情况的发生,PE文件的头部依然包括一个标准的DOS_MZ格式的可执行部分,这样万一在DOS下执行PE文件,那么系统会弹出一个提示<code>This program cannot be run in DOS mode.</code>,这样不至于崩溃.</p><p>PE格式中的DOS部分由<code>MZ格式</code>的文件头和可执行代码部分组成,可执行代码被称为DOS块<code>(DOS stub)</code>.MZ格式的文件头由<code>IMAGE_DOS_HEADER</code>结构定义,以下就是DOS头部分的关键属性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov esi,lpMemory</span><br><span class="line">assume esi:ptr IMAGE_DOS_HEADER</span><br><span class="line">movzx eax,[esi].e_magic         ; 读取DOS的头部</span><br><span class="line">movzx eax,[esi].e_ss            ; DOS代码段的初始堆栈段</span><br><span class="line">movzx eax,[esi].e_sp            ; DOS代码段的初始堆栈指针</span><br><span class="line">movzx eax,[esi].e_cs            ; DOS代码的入口地址</span><br><span class="line">movzx eax,[esi].e_ip            ; DOS代码的入口IP</span><br><span class="line">movzx eax,[esi].e_lfanew        ; 指向了PE文件的开头(重要)</span><br></pre></td></tr></table></figure></p><p>第一个字段<code>e_magic</code>被定义为<code>MZ</code>,标志着DOS文件的开头部分,最后一个字段<code>e_lfanew</code>则指明了PE文件的开头位置,现在来说除了第一个字段和最后一个字段有些用处,其他的字段几乎已经废弃了,这里也不再介绍了.</p><h3 id="◆PE头结构◆"><a href="#◆PE头结构◆" class="headerlink" title="◆PE头结构◆"></a>◆PE头结构◆</h3><p>从DOS文件头的e_lfanew字段(文件头偏移003ch),PE文件格式排列在DOS头的后面,也就是e_lfanew指针所指向的地址,而PE文件的第一个字节就是PE这两个字符,有了这些信息,我们就可以写一个小工具,来检测指定一个程序是否是可执行文件啦.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName db &quot;lyshark.exe&quot;,0h</span><br><span class="line">hFile dd ?</span><br><span class="line">hMapFile dd ?</span><br><span class="line">lpMemory dd ?</span><br><span class="line">szText db &quot;这是一个PE可执行文件 !&quot;,0h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 打开文件,并创建内存映射镜像</span><br><span class="line">invokeCreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ or \</span><br><span class="line">FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL</span><br><span class="line">mov hFile,eax</span><br><span class="line">invoke CreateFileMapping,hFile,NULL,PAGE_READONLY,0,0,NULL</span><br><span class="line">mov hMapFile,eax</span><br><span class="line">invoke MapViewOfFile,eax,FILE_MAP_READ,0,0,0</span><br><span class="line">mov lpMemory,eax</span><br><span class="line">; -------------------------------------------------------------------</span><br><span class="line">; 检测PE文件是否有效,是否是一个正常的PE</span><br><span class="line">mov esi,lpMemory</span><br><span class="line">assume esi:ptr IMAGE_DOS_HEADER</span><br><span class="line">; 判断是否为DOS文件头部</span><br><span class="line">.if [esi].e_magic == IMAGE_DOS_SIGNATURE</span><br><span class="line">add esi,[esi].e_lfanew              ; 递增指针</span><br><span class="line">assume esi:ptr IMAGE_NT_HEADERS</span><br><span class="line">; 判断是否为PE可执行文件</span><br><span class="line">.if [esi].Signature == IMAGE_NT_SIGNATURE</span><br><span class="line">invoke MessageBox,NULL,addr szText,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">.endif</span><br><span class="line">; -------------------------------------------------------------------</span><br><span class="line">invoke UnmapViewOfFile,addr lpMemory</span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p>上面的核心代码原理也非常的简单,过程：读入文件,判断第一个字符是不是MZ,如果是MZ,则在判断e_lfanew指针指向的地址是不是PE如果是,则说明这是PE文件.</p><p>下面的代码,则用于读取PE文件的一些关键区块信息.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">include masm32.inc</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szFileName db &quot;lyshark.exe&quot;,0h</span><br><span class="line">hFile dd ?</span><br><span class="line">hMapFile dd ?</span><br><span class="line">lpMemory dd ?</span><br><span class="line">lpBuffer db 2048 dup(?)</span><br><span class="line">.const</span><br><span class="line">szMsgdb&quot;----------------------------------------&quot;,0dh,0ah</span><br><span class="line">db&quot;运行平台：           0x%04X&quot;,0dh,0ah</span><br><span class="line">db&quot;节区数量：           %d&quot;,0dh,0ah</span><br><span class="line">db&quot;文件属性：           0x%04X&quot;,0dh,0ah</span><br><span class="line">db&quot;时间标记:            %d&quot;,0dh,0ah</span><br><span class="line">db&quot;镜像装入基址：       0x%08X&quot;,0dh,0ah</span><br><span class="line">db&quot;程序的入口RVA：      0x%08X&quot;,0dh,0ah</span><br><span class="line">db&quot;代码节起始RVA：      0x%08X&quot;,0dh,0ah</span><br><span class="line">db&quot;数据节起始RVA：      0x%08X&quot;,0dh,0ah</span><br><span class="line">db&quot;----------------------------------------&quot;,0dh,0ah,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 打开文件,并创建内存映射镜像</span><br><span class="line">invokeCreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ or \</span><br><span class="line">FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL</span><br><span class="line">mov hFile,eax</span><br><span class="line">invoke CreateFileMapping,hFile,NULL,PAGE_READONLY,0,0,NULL</span><br><span class="line">mov hMapFile,eax</span><br><span class="line">invoke MapViewOfFile,eax,FILE_MAP_READ,0,0,0</span><br><span class="line">mov lpMemory,eax</span><br><span class="line">mov esi,lpMemory</span><br><span class="line"></span><br><span class="line">assumeesi:ptr IMAGE_DOS_HEADER</span><br><span class="line">add esi,[esi].e_lfanew</span><br><span class="line">assume esi:ptr IMAGE_NT_HEADERS</span><br><span class="line">invoke wsprintf,addr lpBuffer,addr szMsg,\</span><br><span class="line">[esi].FileHeader.Machine, \                 ; 运行平台</span><br><span class="line">[esi].FileHeader.NumberOfSections, \        ; 节区数目</span><br><span class="line">[esi].FileHeader.Characteristics, \         ; 文件属性</span><br><span class="line">[esi].FileHeader.TimeDateStamp, \           ; 时间标记</span><br><span class="line">[esi].OptionalHeader.ImageBase, \           ; 镜像基址</span><br><span class="line">[esi].OptionalHeader.AddressOfEntryPoint, \ ; 入口RVA地址</span><br><span class="line">[esi].OptionalHeader.BaseOfCode, \          ; 代码节起始RVA</span><br><span class="line">[esi].OptionalHeader.BaseOfData</span><br><span class="line">invoke StdOut,addr lpBuffer</span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><h3 id="◆节与节表◆"><a href="#◆节与节表◆" class="headerlink" title="◆节与节表◆"></a>◆节与节表◆</h3><p>在执行一个PE文件的时候,Windows并不在一开始就将整个文件读入内存,而是采用与内存映射文件类似的机制,Windows会事先建立好虚拟地址和PE文件之间的映射关系,只有真正执行到某个内存页中的指令或者访问某一页中的数据时,这个页面才会被提交到内存,这种机制加快了程序的运行效率,同时使文件的装入速度与文件大小没有关系.</p><p>系统装载可执行文件并不等同于内存映射,内存映射是将整个磁盘文件原封不动的搬到内存中去,而PE的加载则会处理一些其他数据,例如预处理,重定位等,装入以后页面位置,偏移等都会随之发生改变,Windows装载器在装载DOS部分,PE文件头部分和节表部分时不进行任何处理,而装载节的时候将根据节的属性做不同的处理.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">include masm32.inc</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szFileName db &quot;lyshark.exe&quot;,0h</span><br><span class="line">hFile dd ?</span><br><span class="line">hMapFile dd ?</span><br><span class="line">lpMemory dd ?</span><br><span class="line">lpBuffer db 2048 dup(?)</span><br><span class="line">.const</span><br><span class="line">szMsgdb&quot;----------------------------------------------------------&quot;,0dh,0ah</span><br><span class="line">db&quot;节区名称  节区大小  虚拟地址  Raw_尺寸  Raw_偏移  节区属性&quot;,0dh,0ah</span><br><span class="line">db&quot;----------------------------------------------------------&quot;,0dh,0ah,0</span><br><span class="line">szFmtdb&quot;%s  %08X  %08X  %08X  %08X  %08X&quot;,0dh,0ah,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invokeCreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ or \</span><br><span class="line">FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL</span><br><span class="line">mov hFile,eax</span><br><span class="line">invoke CreateFileMapping,hFile,NULL,PAGE_READONLY,0,0,NULL</span><br><span class="line">mov hMapFile,eax</span><br><span class="line">invoke MapViewOfFile,eax,FILE_MAP_READ,0,0,0</span><br><span class="line">mov lpMemory,eax</span><br><span class="line">mov esi,lpMemory</span><br><span class="line"></span><br><span class="line">assumeesi:ptr IMAGE_DOS_HEADER     ; 指向DOS开头</span><br><span class="line">add esi,[esi].e_lfanew               ; 递增指针到PE结构开头</span><br><span class="line">assume esi:ptr IMAGE_NT_HEADERS</span><br><span class="line"></span><br><span class="line">invoke StdOut,addr szMsg                        ; 输出提示信息</span><br><span class="line">movzx ecx,[esi].FileHeader.NumberOfSections     ; 取出节的数量,作为循环条件</span><br><span class="line">add esi,sizeof IMAGE_NT_HEADERS      ; 指向.text节</span><br><span class="line">assume esi:ptr IMAGE_SECTION_HEADER  ; 指向节中的SECTION</span><br><span class="line">.repeat</span><br><span class="line">push ecx      ; wsprintf影响ecx寄存器,所以这里必须压栈保存数据</span><br><span class="line">mov eax,[esi].VirtualAddress</span><br><span class="line"></span><br><span class="line">invoke wsprintf,addr lpBuffer,addr szFmt,esi, \   ; 节区名称</span><br><span class="line">[esi].Misc.VirtualSize, \                 ; 节区大小</span><br><span class="line">[esi].VirtualAddress, \                   ; 虚拟地址</span><br><span class="line">[esi].SizeOfRawData, \                    ; Raw_尺寸</span><br><span class="line">[esi].PointerToRawData, \                 ; Raw_偏移</span><br><span class="line">[esi].Characteristics                     ; 节区属性</span><br><span class="line">invoke StdOut,addr lpBuffer                       ; 打印节区信息</span><br><span class="line">pop ecx</span><br><span class="line">add esi,sizeof IMAGE_SECTION_HEADER</span><br><span class="line">.untilcxz</span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p><br></p><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><h2 id="导出表结构"><a href="#导出表结构" class="headerlink" title="导出表结构"></a>导出表结构</h2><h2 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
&lt;p&gt;PE格式是Windows系统下最常用的可执行文件格式,有些应用必须建立在了解PE文件格式的基础之上,如可执行文件的加密与解密,文件型病毒的查杀等,熟练掌握PE文件结构,有助于软件的分析.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编系统函数(5)</title>
    <link href="https://localhost/2019/04/20/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-5/"/>
    <id>https://localhost/2019/04/20/汇编与反汇编/Win32汇编系统函数-5/</id>
    <published>2019-04-20T01:57:38.000Z</published>
    <updated>2019-09-07T00:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><p>熟练掌握Win32 API函数的参数传递,是软件逆向的基础,本章节内容将使用MASM汇编器,逐个编译这些源程序,你可以通过使用一些调试工具,这里推荐OllyDBG来附加编译后的可执行文件,进行逐个分析,观察二进制程序逆向后的一些变化,总结吸收经验,为以后的二进制逆向,漏洞挖掘打基础.</p><a id="more"></a><p><br></p><h2 id="通用系统函数"><a href="#通用系统函数" class="headerlink" title="通用系统函数"></a>通用系统函数</h2><p><strong>注册热键:</strong> 注册全局热键并能激活.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">hMsgBox db &quot;你按下了 CTRL + ALT + A&quot;,0h</span><br><span class="line">uMsg MSG &lt;?&gt;</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 41h = A | 65h=uMsg.wParam</span><br><span class="line">invoke RegisterHotKey,NULL,065h,MOD_CONTROL or MOD_ALT,041h</span><br><span class="line">.while(TRUE)</span><br><span class="line">invoke GetMessage,addr uMsg,NULL,0,0</span><br><span class="line">.if(uMsg.message == WM_HOTKEY)       ; 按下按键提示</span><br><span class="line">invoke MessageBox,NULL,addr hMsgBox,addr uMsg.wParam,MB_OK</span><br><span class="line">.elseif(uMsg.message == WM_DESTROY)  ; 程序结束后关闭热键</span><br><span class="line">invoke UnregisterHotKey,NULL,065h</span><br><span class="line">invoke PostQuitMessage,NULL</span><br><span class="line">.endif</span><br><span class="line">.endw</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>最小化指定窗口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">FindName db &quot;qq&quot;,0h</span><br><span class="line">handle   dd ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke FindWindow,NULL,addr FindName</span><br><span class="line">mov handle,eax</span><br><span class="line"></span><br><span class="line">.if(handle != 0)         ; 找到则隐藏窗口</span><br><span class="line">invoke ShowWindow,handle,SW_HIDE</span><br><span class="line">.else                    ; 没有找到则显示</span><br><span class="line">invoke ShowWindow,handle,SW_SHOW</span><br><span class="line">.endif</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>显示当前目录等:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">stStartUp STARTUPINFO &lt;?&gt;</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invokeGetStartupInfo,addr stStartUp</span><br><span class="line">mov eax,stStartUp.lpDesktop</span><br><span class="line">mov eax,stStartUp.lpTitle        ; 显示当前软件目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>取系统版本等:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">version OSVERSIONINFO &lt;?&gt;</span><br><span class="line">lpsystem SYSTEM_INFO &lt;?&gt;</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetSystemInfo,addr lpsystem</span><br><span class="line">mov ax,lpsystem.wProcessorArchitecture</span><br><span class="line"></span><br><span class="line">invoke GetVersionEx,addr version</span><br><span class="line">mov eax,version.dwBuildNumber</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>取命令行参数:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">cmdline dword ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">invoke GetCommandLine                ; 获取命令行参数</span><br><span class="line">mov cmdline,eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取环境变量:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szBuffer  DB 200 dup(?)      ; 保存到缓冲区</span><br><span class="line">szVarName DB &quot;PATH&quot;,0h       ; 获取set PATH</span><br><span class="line">lpVar     DD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetEnvironmentVariable,addr szVarName,addr szBuffer,sizeof szBuffer</span><br><span class="line">xor eax,eax</span><br><span class="line">invoke GetEnvironmentStrings</span><br><span class="line">mov lpVar,eax</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>设置环境变量:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"></span><br><span class="line">lpVarName DB &quot;PATH&quot;,0h</span><br><span class="line">lpValue   DB &quot;E:\RadASM\masm32\bin&quot;,0h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke SetEnvironmentVariable,addr lpVarName,addr lpValue</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>运行系统软件:</strong> 下载并运行一个软件.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include urlmon.inc</span><br><span class="line">includelib urlmon.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szURL DB &quot;https://www.mkdirs.com/lyshark.exe&quot;,0h</span><br><span class="line">szFileName DB &quot;C:\\lyshark.exe&quot;,0h</span><br><span class="line">WinRun DB &quot;C:/lyshark.exe&quot;,0h</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke URLDownloadToFile,NULL,addr szURL,addr szFileName,0,NULL</span><br><span class="line">invoke WinExec,offset WinRun,SW_SHOW</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>获取本地时间:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">systime SYSTEMTIME &lt;&gt;</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetLocalTime,addr systime   ; 获取当前时间</span><br><span class="line">mov ax,systime.wYear</span><br><span class="line">mov bx,systime.wMonth</span><br><span class="line">mov cx,systime.wDay</span><br><span class="line"></span><br><span class="line">invoke SetLocalTime,addr systime   ; 设置当前时间</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取系统时间:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">systime SYSTEMTIME &lt;&gt;</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetSystemTime,addr systime</span><br><span class="line">mov ax,systime.wYear</span><br><span class="line">mov bx,systime.wMonth</span><br><span class="line">mov cx,systime.wDay</span><br><span class="line"></span><br><span class="line">invoke SetSystemTime,addr systime</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取时间差:</strong> eax保存的就是执行代码后的时间差,单位毫秒<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">dwTock DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetTickCount</span><br><span class="line">mov dwTock,eax</span><br><span class="line">invoke GetTickCount</span><br><span class="line">sub eax,dwTock</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="内存分配函数"><a href="#内存分配函数" class="headerlink" title="内存分配函数"></a>内存分配函数</h2><h3 id="◆标准内存管理◆"><a href="#◆标准内存管理◆" class="headerlink" title="◆标准内存管理◆"></a>◆标准内存管理◆</h3><p><strong>获取内存状态:</strong> GlobalMemourStatus<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Mem MEMORYSTATUS &lt;&gt;</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GlobalMemoryStatus,offset Mem</span><br><span class="line"></span><br><span class="line">mov eax,Mem.dwLength        ; 获取结构长度</span><br><span class="line">mov eax,Mem.dwMemoryLoad    ; 已用内存百分比</span><br><span class="line">mov eax,Mem.dwTotalPhys     ; 物理内存总数</span><br><span class="line">mov eax,Mem.dwAvailPhys     ; 可用物理内存</span><br><span class="line">mov eax,Mem.dwTotalPageFile ; 交换文件的总大小</span><br><span class="line">mov eax,Mem.dwAvailPageFile ; 交换文件可用大小</span><br><span class="line">mov eax,Mem.dwTotalVirtual  ; 用户可用的地址空间</span><br><span class="line">mov eax,Mem.dwAvailVirtual  ; 用户空闲地址空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>申请内存:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">;GMEM_FIXED=申请内存;GMEM_ZEROINIT申请并初始化为0</span><br><span class="line">invoke GlobalAlloc,GMEM_ZEROINIT,1024</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lpMemory,eax     ; lpMemory 为分配成功后的内存指针</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke GlobalFree,lpMemory   ; 释放内存空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>扩大内存空间:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line">reMemory DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GlobalAlloc,GMEM_ZEROINIT,100</span><br><span class="line">mov lpMemory,eax</span><br><span class="line">invoke GlobalReAlloc,lpMemory,1024,GMEM_ZEROINIT or GMEM_MOVEABLE</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov reMemory,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke GlobalFree,lpMemory</span><br><span class="line">invoke GlobalFree,reMemory</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>锁定/解锁内存:</strong> 程序需要使用这块内存可以将其锁定,使用完后可以解除锁定.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line">Locks    DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GlobalAlloc,GMEM_ZEROINIT,100</span><br><span class="line">mov lpMemory,eax</span><br><span class="line"></span><br><span class="line">invoke GlobalLock,lpMemory     ; 锁定内存空间</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov Locks,eax          ; 锁定成功后,返回原内存地址</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke GlobalUnlock,lpMemory   ; 解锁内存空间,成功返回非0</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>可移动/可丢弃内存:</strong> 可移动内存允许在不使用时改变其内存地址,可丢弃当内存不足时可将其丢弃。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lp_Move_Memory DWORD ?</span><br><span class="line">lp_Disb_Memory DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GlobalAlloc,GMEM_MOVEABLE or GMEM_ZEROINIT,1024     ; 分配可移动的内存</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lp_Move_Memory,eax                  ; 分配成功则保存其内存地址</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke GlobalAlloc,GMEM_DISCARDABLE or GMEM_ZEROINIT,1024  ; 分配可丢弃的内存</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lp_Disb_Memory,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>复制内存地址:</strong> 将源地址复制到目标地址中,总共复制40个字节.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Source DWORD 1,2,3,4,5</span><br><span class="line">       DWORD 6,7,8,9,0</span><br><span class="line"></span><br><span class="line">Dest   DWORD 0,0,0,0,0</span><br><span class="line">       DWORD 0,0,0,0,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea eax,Source         ; 源地址</span><br><span class="line">lea ebx,Dest           ; 目标地址</span><br><span class="line"></span><br><span class="line">invoke RtlMoveMemory,addr Dest,addr Source,40     ;将源地址复制到目标地址,复制40个字节</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>填充内存:</strong> 将Memory中的字节数据，全部填充替换为A，或填充为0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Memory DB 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">       DB 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">       DB 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">Fill   DB &quot;A&quot;,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea eax,Memory</span><br><span class="line"></span><br><span class="line">; 填充Memory内存，向后填充1024字节，填充为A</span><br><span class="line">invoke RtlFillMemory,addr Memory,1024,addr Fill</span><br><span class="line">;填充Memory内存，向后填充1024字节，全部初始化为0</span><br><span class="line">invoke RtlZeroMemory,addr Memory,1024</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆堆管理函数◆"><a href="#◆堆管理函数◆" class="headerlink" title="◆堆管理函数◆"></a>◆堆管理函数◆</h3><p><strong>创建私有堆:</strong> 创建一个1024字节的私有堆,并返回内存地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">HeapMain DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,1024,0   ; 保留1024字节物理内存</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov HeapMain,eax                         ; 成功分配则返回内存地址</span><br><span class="line">.endif</span><br><span class="line">invoke HeapDestroy,HeapMain                  ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>分配内存块:</strong> 在创建的堆中分配内存块.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpHeap DWORD ?</span><br><span class="line">lpMem  DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,1024,0   ; 保留1024字节物理内存</span><br><span class="line">mov lpHeap,eax                               ; 保存分配的地址</span><br><span class="line">invoke HeapAlloc, lpHeap,HEAP_ZERO_MEMORY,1024 ; 分配1024字节空间</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lpMem,eax                          ; 分配成功,保存内存地址</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke HeapDestroy,lpHeap                  ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>在堆中分配内存:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpHeap   DWORD ?</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,1024,0     ; 创建堆句柄,并保留1024字节</span><br><span class="line">mov lpHeap,eax                                 ; 保存分配句柄地址</span><br><span class="line"></span><br><span class="line">invoke HeapAlloc,lpHeap,HEAP_ZERO_MEMORY,1024  ; 分配1024字节的地址</span><br><span class="line">mov lpMemory,eax                               ; 分配并返回内存地址</span><br><span class="line"></span><br><span class="line">invoke HeapDestroy,lpHeap                      ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>增加堆内存空间:</strong> 在原本来的内存地址基础上,增加内存空间<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpHeap   DWORD ?</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line">ReMemory DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,4096,0     ; 创建堆句柄,并保留4096字节</span><br><span class="line">mov lpHeap,eax                                 ; 保存分配句柄地址</span><br><span class="line"></span><br><span class="line">invoke HeapAlloc,lpHeap,HEAP_ZERO_MEMORY,1024  ; 分配1024字节的地址</span><br><span class="line">mov lpMemory,eax                               ; 分配并返回内存地址</span><br><span class="line"></span><br><span class="line">; 重新分配内存空间,在原内存1024上调整到2048</span><br><span class="line">invoke HeapReAlloc,lpHeap,HEAP_ZERO_MEMORY,lpMemory,2048</span><br><span class="line">mov ReMemory,eax                               ; 保存返回内存地址</span><br><span class="line"></span><br><span class="line">invoke HeapDestroy,lpHeap                      ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>计算堆空间大小:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpHeap   DWORD ?</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line">Mem_Size DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,4096,0     ; 创建堆句柄,并保留4096字节</span><br><span class="line">mov lpHeap,eax                                 ; 保存分配句柄地址</span><br><span class="line"></span><br><span class="line">invoke HeapAlloc,lpHeap,HEAP_ZERO_MEMORY,1024  ; 分配1024字节的地址</span><br><span class="line">mov lpMemory,eax                               ; 分配并返回内存地址</span><br><span class="line"></span><br><span class="line">invoke HeapSize,lpHeap,HEAP_NO_SERIALIZE,lpMemory ; 计算堆空间的大小</span><br><span class="line">mov Mem_Size,eax                                  ; 取地址大小,此处为1024</span><br><span class="line"></span><br><span class="line">invoke HeapDestroy,lpHeap                      ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>锁定/解锁堆:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpHeap   DWORD ?</span><br><span class="line">lpMemory DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke HeapCreate,HEAP_NO_SERIALIZE,4096,0     ; 创建堆句柄,并保留4096字节</span><br><span class="line">mov lpHeap,eax                                 ; 保存分配句柄地址</span><br><span class="line"></span><br><span class="line">invoke HeapAlloc,lpHeap,HEAP_ZERO_MEMORY,1024  ; 分配1024字节的地址</span><br><span class="line">mov lpMemory,eax                               ; 分配并返回内存地址</span><br><span class="line"></span><br><span class="line">invoke HeapLock,lpHeap                         ; 锁定内存堆</span><br><span class="line">invoke HeapUnlock,lpHeap                       ; 解锁内存堆</span><br><span class="line"></span><br><span class="line">invoke HeapDestroy,lpHeap                      ; 释放堆空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆虚拟内存函数◆"><a href="#◆虚拟内存函数◆" class="headerlink" title="◆虚拟内存函数◆"></a>◆虚拟内存函数◆</h3><p><strong>保留地址空间:</strong> 保留的空间不可以直接使用.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpAddr DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke VirtualAlloc,NULL,1024,MEM_RESERVE,PAGE_NOACCESS  ; 保留内存地址</span><br><span class="line">mov lpAddr,eax</span><br><span class="line">invoke VirtualFree,lpAddr,1024,MEM_RELEASE               ; 释放地址空间</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>分配地址空间:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpAddr DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke VirtualAlloc,NULL,1024,MEM_COMMIT,PAGE_READWRITE  ; 分配内存地址</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lpAddr,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke VirtualFree,lpAddr,1024,MEM_RELEASE               ; 释放内存地址</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>保护/锁定内存:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpAddr DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke VirtualAlloc,NULL,1024,MEM_COMMIT,PAGE_READWRITE  ; 保留内存地址</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov lpAddr,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke VirtualProtect,lpAddr,1024,PAGE_NOACCESS,NULL     ; 设置内存为只读</span><br><span class="line"></span><br><span class="line">invoke VirtualLock,lpAddr,1024                           ; 锁定内存地址</span><br><span class="line">invoke VirtualUnlock,lpAddr,1024                         ; 解除内存锁定</span><br><span class="line"></span><br><span class="line">invoke VirtualFree,lpAddr,1024,MEM_RELEASE               ; 释放地址空间</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>内存状态测试:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpMemory DWORD 1024</span><br><span class="line">lpString BYTE &quot;hello lyshark&quot;,0</span><br><span class="line">lpStatus DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov lpMemory,1024</span><br><span class="line">lea eax,lpMemory</span><br><span class="line"></span><br><span class="line">invoke IsBadCodePtr,lpMemory          ; 内存的第一个字节是否可读</span><br><span class="line">mov lpStatus,eax                      ; 可读返回0否则返回非0</span><br><span class="line"></span><br><span class="line">invoke IsBadReadPtr,lpMemory,1024     ; 测试前1024字节是否可读</span><br><span class="line">mov lpStatus,eax                      ; 可读返回0否则返回非0</span><br><span class="line"></span><br><span class="line">invoke IsBadWritePtr,lpMemory,1024    ; 测试前1024字节是否可写</span><br><span class="line">mov lpStatus,eax                      ; 可写返回0否则返回非0</span><br><span class="line"></span><br><span class="line">invoke IsBadStringPtr,addr lpString,sizeof lpString ; 测试字符串是否可读</span><br><span class="line">mov lpStatus,eax                      ; 可读返回0否则返回非0</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="文件与磁盘函数"><a href="#文件与磁盘函数" class="headerlink" title="文件与磁盘函数"></a>文件与磁盘函数</h2><h3 id="◆文件相关函数◆"><a href="#◆文件相关函数◆" class="headerlink" title="◆文件相关函数◆"></a>◆文件相关函数◆</h3><p><strong>打开/关闭文件:</strong> 打开文件成功返回文件句柄,失败则返回error<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName db &quot;e:\lyshark.log&quot;,0h    ; 打开的文件名称</span><br><span class="line">hFile      dd ?                      ; 打开成功后返回的句柄</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0, \</span><br><span class="line">OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line"></span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFile,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>创建文件:</strong> CREATE_ALWAYS=文件存在则清空内容,CREATE_NEW=文件存在则返回失败<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szNewFile db &quot;C:\lyshark.log&quot;,0h</span><br><span class="line">hFile      dd ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szNewFile,GENERIC_WRITE,FILE_SHARE_READ,0, \</span><br><span class="line">CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line"></span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFile,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke CloseHandle,hFile</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>移动文件指针:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName DB &quot;c:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandl DD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFileHandl,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke SetFilePointer,hFileHandl,0,NULL,FILE_CURRENT     ; eax=获取的文件指针位置</span><br><span class="line">xor eax,eax</span><br><span class="line">invoke SetFilePointer,hFileHandl,10,NULL,FILE_BEGIN      ; 将文件指针向后移动10个字节</span><br><span class="line">xor eax,eax</span><br><span class="line">invoke SetFilePointer,hFileHandl,0,NULL,FILE_CURRENT     ; 再次获取指针位置,eax=10</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>设置指针到末尾:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName DB &quot;e:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandl DD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFileHandl,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke SetEndOfFile,hFileHandl                           ; 将文件位置设置到末尾</span><br><span class="line">invoke SetFilePointer,hFileHandl,0,NULL,FILE_CURRENT     ; 获取指针位置</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>读取文件内容:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName  DB &quot;C:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandle DD ?</span><br><span class="line">szReadBuff  DB ?      ; 每次读取一个字节,放入该变量中</span><br><span class="line">ByteRead    DB ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFileHandle,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke SetFilePointer,hFileHandle,1,NULL,FILE_BEGIN   ; 取第一个字符</span><br><span class="line">invoke ReadFile,hFileHandle,addr szReadBuff,sizeof szReadBuff,addr ByteRead,0</span><br><span class="line">mov al,[szReadBuff]                           ; 将取出来的字符放入al寄存器中</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>写入文件内容:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName  DB &quot;C:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandle DD ?                         ; 获取文件句柄</span><br><span class="line">lpBuffer    DB &quot;hello lyshark&quot;,0h        ; 要写入的字符串</span><br><span class="line">reWrite     DD ?                         ; 返回写入成功字节数</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_WRITE,FILE_SHARE_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">.if(eax != INVALID_HANDLE_VALUE)</span><br><span class="line">mov hFileHandle,eax</span><br><span class="line">.endif</span><br><span class="line">; 将lpBuffer中的数据写入到文件,写入大小为sizeof获取的大小.</span><br><span class="line">invoke WriteFile,hFileHandle,addr lpBuffer,sizeof lpBuffer,addr reWrite,NULL</span><br><span class="line">invoke FlushFileBuffers,hFileHandle    ; 强制刷新写入</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取文件长度:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName  DB &quot;E:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandle DD ?</span><br><span class="line">FilesSize   DD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">mov hFileHandle,eax</span><br><span class="line"></span><br><span class="line">invoke GetFileSize,hFileHandle,NULL      ; 取出文件的长度</span><br><span class="line">mov FilesSize,eax                        ; 放入FilesSize里面</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取文件日期:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName  DB &quot;E:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandle DD ?</span><br><span class="line"></span><br><span class="line">create  FILETIME &lt;&gt;            ; 存储创建文件的日期</span><br><span class="line">systime SYSTEMTIME &lt;&gt;          ; 存储转换后的文件日期</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">mov hFileHandle,eax                                     ; 取出文件句柄</span><br><span class="line"></span><br><span class="line">invoke GetFileTime,hFileHandle,addr create,NULL,NULL    ; 只取出创建日期，其他的用NULL填充</span><br><span class="line">invoke FileTimeToSystemTime,addr create,addr systime    ; 转换成常用格式</span><br><span class="line"></span><br><span class="line">mov ax,systime.wYear    ; 取出年份</span><br><span class="line">mov bx,systime.wMonth   ; 取出月份</span><br><span class="line">mov cx,systime.wDay     ; 取出天数</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>修改文件日期:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szFileName  DB &quot;E:\lyshark.log&quot;,0h</span><br><span class="line">hFileHandle DD ?</span><br><span class="line"></span><br><span class="line">create  FILETIME &lt;&gt;            ; 存储创建文件的日期</span><br><span class="line">systime SYSTEMTIME &lt;&gt;          ; 存储转换后的文件日期</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CreateFile,addr szFileName,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0</span><br><span class="line">mov hFileHandle,eax                                     ; 取出文件句柄</span><br><span class="line">mov systime.wYear,19      ; 先填写结构</span><br><span class="line">mov systime.wMonth,19</span><br><span class="line"></span><br><span class="line">invoke SystemTimeToFileTime,addr systime,addr create  ; 转换成filetime</span><br><span class="line">invoke SetFileTime,hFileHandle,addr create,NULL,NULL  ; 回写</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>拷贝/移动/删除/文件:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpSourceFile  DB &quot;C:\lyshark.log&quot;,0h</span><br><span class="line">lpDestFile    DB &quot;E:\wang.log&quot;,0h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke CopyFile,addr lpSourceFile,addr lpDestFile,TRUE   ; 拷贝文件</span><br><span class="line">invoke MoveFile,addr lpDestFile,addr lpSourceFile        ; 移动文件</span><br><span class="line">invoke DeleteFile,addr lpSourceFile</span><br><span class="line">invoke DeleteFile,addr lpDestFile                        ; 删除文件</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆磁盘相关函数◆"><a href="#◆磁盘相关函数◆" class="headerlink" title="◆磁盘相关函数◆"></a>◆磁盘相关函数◆</h3><p><strong>显示所有驱动器:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpLength  BYTE  ?</span><br><span class="line">lpDrives  DWORD 0 dup(1024)</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetLogicalDrives      ; 获取卷标</span><br><span class="line">invoke GetLogicalDriveStrings,addr lpLength,addr lpDrives  ; 同上</span><br><span class="line">lea esi,[lpDrives]            ; 显示C盘</span><br><span class="line">lea esi,[lpDrives+4]          ; 显示D盘</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取磁盘类型:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpDrive DB &quot;c:\&quot;,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetDriveType,addr lpDrive</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取磁盘详细信息:</strong>(有问题的)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpRoot DB &quot;c:\&quot;,0h</span><br><span class="line">lpBuffer DB 1024 dup(?)</span><br><span class="line">dwSerial DD ?</span><br><span class="line">lpType DB 1024 dup(?)</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetVolumeInformation,addr lpRoot, \</span><br><span class="line">addr lpBuffer,1024,addr dwSerial,255, \</span><br><span class="line">FILE_CASE_PRESERVED_NAMES,addr lpType,1024</span><br><span class="line"></span><br><span class="line">lea eax,lpRoot</span><br><span class="line">lea ebx,lpBuffer</span><br><span class="line">lea ecx,dwSerial</span><br><span class="line">lea edx,lpType</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>检测逻辑驱动器字节:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpRoot DB &quot;c:\&quot;,0h</span><br><span class="line">lpSect DD ?</span><br><span class="line">lpByte DD ?</span><br><span class="line">lpNumb DD ?</span><br><span class="line">lpTota DD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 总容量 = 簇总数 * 每簇扇区数 * 每扇区字节数</span><br><span class="line">; 空闲字节数 = 未使用的簇 * 每扇区数 * 每扇区字节数</span><br><span class="line">invoke GetDiskFreeSpace,addr lpRoot,addr lpSect,addr lpByte,addr lpNumb,addr lpTota</span><br><span class="line"></span><br><span class="line">mov eax,lpSect     ; 返回每个簇的扇区数</span><br><span class="line">mov eax,lpByte     ; 返回每扇区的字节数</span><br><span class="line">mov eax,lpNumb     ; 返回未使用的簇的数量</span><br><span class="line">mov eax,lpTota     ; 返回簇的总数</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>获取当前目录:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpRoot DB ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetCurrentDirectory,1024,addr lpRoot    ; 获取当前目录</span><br><span class="line">lea eax,lpRoot</span><br><span class="line"></span><br><span class="line">invoke GetTempPath,1024,addr lpRoot            ; 获取临时目录</span><br><span class="line">lea eax,lpRoot</span><br><span class="line"></span><br><span class="line">invoke GetSystemDirectory,addr lpRoot,1024     ; 获取系统目录</span><br><span class="line">lea eax,lpRoot</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>创建删除目录:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpRoot DB &quot;c:\windows\&quot;,0</span><br><span class="line">szDir  DB &quot;c:\lyshark\wang&quot;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke SetCurrentDirectory,addr lpRoot         ; 设置默认路径</span><br><span class="line"></span><br><span class="line">invoke CreateDirectory,addr szDir,NULL         ; 创建目录</span><br><span class="line">invoke RemoveDirectory,addr szDir              ; 删除目录</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="进程与线程函数"><a href="#进程与线程函数" class="headerlink" title="进程与线程函数"></a>进程与线程函数</h2><h3 id="◆进程相关函数◆"><a href="#◆进程相关函数◆" class="headerlink" title="◆进程相关函数◆"></a>◆进程相关函数◆</h3><p><strong>创建进程:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szBuffer   DWORD ?</span><br><span class="line">szFileName DWORD ?</span><br><span class="line">szCmdLine DWORD ?</span><br><span class="line">szBlank DWORD ?</span><br><span class="line">stStartUp DWORD ?</span><br><span class="line">stProcInfo DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke lstrcpy,addr szBuffer,addr szFileName</span><br><span class="line">.if(szCmdLine)</span><br><span class="line">invoke lstrcat,addr szBuffer,addr szBlank</span><br><span class="line">invoke lstrcat,addr szBuffer,addr szCmdLine</span><br><span class="line">.endif</span><br><span class="line">invoke GetStartupInfo,addr stStartUp</span><br><span class="line">invoke CreateProcess,NULL,addr szBuffer,NULL,NULL,NULL, \</span><br><span class="line">NORMAL_PRIORITY_CLASS,NULL,NULL,addr stStrartUp,addr stProcInfo</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>取所有进程信息:</strong> 使用快照函数,一次性遍历出所有的进程列表.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">hSnapShot dd ?</span><br><span class="line">stProcess PROCESSENTRY32 &lt;?&gt;</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke CreateToolhelp32Snapshot,TH32CS_SNAPPROCESS,0   ; 创建快照</span><br><span class="line">mov hSnapShot,eax                                      ; 保存句柄</span><br><span class="line">mov stProcess.dwSize,sizeof stProcess                  ; 保存快照大小</span><br><span class="line"></span><br><span class="line">invoke Process32First,hSnapShot,addr stProcess         ; 取第一个进程数据</span><br><span class="line">.while(eax)                                            ; eax!=0则继续循环</span><br><span class="line">invoke Process32Next,hSnapShot,addr stProcess      ; 取下一个进程数据</span><br><span class="line">.endw</span><br><span class="line">invoke CloseHandle,hSnapShot                       ; 关闭进程句柄</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>取指定进程PID:</strong> 获取xshell进程的PID号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">FindID    DB &quot;Xshell&quot;,0h</span><br><span class="line">ThreadID  DD ?</span><br><span class="line">ProcessID DD ?          ; 获取到的进程号</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke FindWindow,NULL,addr FindID</span><br><span class="line">.if(FindID != 0)</span><br><span class="line">mov ThreadID,eax</span><br><span class="line">.endif</span><br><span class="line">invoke GetWindowThreadProcessId, ThreadID,offset ProcessID</span><br><span class="line">mov eax,ProcessID</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>内存示范例子:</strong> 请手动编译该例子,并命名为<code>lyshark.exe</code>,接下来的<code>读内存/写内存</code>例子将用它讲解.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386p</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">titles  DB &quot;box&quot;,0h</span><br><span class="line">check_ok DB &quot;破解完成.&quot;,0h</span><br><span class="line">check_err DB &quot;破解失败&quot;,0h</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">xor eax,eax</span><br><span class="line">.if eax</span><br><span class="line">invoke MessageBox,NULL,addr check_ok,addr titles,MB_OK</span><br><span class="line">.else</span><br><span class="line">invoke MessageBox,NULL,addr check_err,addr titles,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>读取进程数据:</strong> 读取指定的内存地址中的数据,并将其放入ReadBuf缓冲区中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OEP equ 004198402                            ; 读取的范围</span><br><span class="line">.data</span><br><span class="line">stStartUp STARTUPINFO &lt;&gt;             ; 初始化</span><br><span class="line">stProInfo PROCESS_INFORMATION &lt;&gt;     ; 该进程的进程信息</span><br><span class="line">ExeRun    DB &quot;C:\\lyshark.exe&quot;,0h    ; 要打开的进程名称</span><br><span class="line">ReadBuf   DD ?                       ; 读取到的数据内容</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetStartupInfo,addr stStartUp</span><br><span class="line">invoke CreateProcess,addr ExeRun,NULL,NULL,NULL,NULL,\</span><br><span class="line">NORMAL_PRIORITY_CLASS,0,0,addr stStartUp,addr stProInfo</span><br><span class="line"></span><br><span class="line">.if(eax)</span><br><span class="line">        ; 读取当前进程,读取内存地址为OEP,每次读取8个字节,读取到放入ReadBuf</span><br><span class="line">invoke ReadProcessMemory,stProInfo.hProcess,OEP,addr ReadBuf,8,NULL</span><br><span class="line">lea eax,ReadBuf</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>写入进程数据:</strong> 写入进程数据,将跳转替换为nop指令的机器码.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OEP equ 004198402                            ; 读取的范围</span><br><span class="line">.data</span><br><span class="line">stStartUp STARTUPINFO &lt;&gt;             ; 初始化</span><br><span class="line">stProInfo PROCESS_INFORMATION &lt;&gt;     ; 该进程的进程信息</span><br><span class="line">ExeRun    DB &quot;C:\\lyshark.exe&quot;,0h    ; 要打开的进程名称</span><br><span class="line">lpPatch   DB 90h,90h,90h,90h         ; 要替换的汇编指令</span><br><span class="line">redPatch  DD ?                       ; 替换完后保存替换结果</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetStartupInfo,addr stStartUp</span><br><span class="line">invoke CreateProcess,addr ExeRun,NULL,NULL,NULL,NULL,\</span><br><span class="line">NORMAL_PRIORITY_CLASS,0,0,addr stStartUp,addr stProInfo</span><br><span class="line"></span><br><span class="line">.if(eax)</span><br><span class="line">        ; 写入当前进程,写入内存地址为OEP,替换8个字节,替换成nop</span><br><span class="line">        invoke WriteProcessMemory,stProInfo.hProcess,OEP,addr lpPatch,4,NULL</span><br><span class="line">        .if(eax != 0)            ; 如果不等于0则说明补丁替换完成</span><br><span class="line">        invoke ReadProcessMemory,stProInfo.hProcess,OEP,addr redPatch,4,NULL</span><br><span class="line">        lea eax,redPatch ; 将补丁地址取出,并用OD分析,为9090则替换完成.</span><br><span class="line">        .endif </span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><h3 id="◆线程相关函数◆"><a href="#◆线程相关函数◆" class="headerlink" title="◆线程相关函数◆"></a>◆线程相关函数◆</h3><p><strong>创建线程函数:</strong> 默认情况下,线程创建后会被系统挂起,需要执行ResumeThread函数,将其放入前台.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ThreadID DWORD ?              ; 保存返回线程ID</span><br><span class="line">hThread  DWORD ?              ; 保存线程句柄</span><br><span class="line">.code</span><br><span class="line">_MyThread proc lParam         ; lParam为传递的参数</span><br><span class="line">xor eax,eax</span><br><span class="line">ret</span><br><span class="line">_MyThread endp</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">invoke CreateThread,NULL,0,addr _MyThread,NULL,CREATE_SUSPENDED,addr ThreadID</span><br><span class="line">.if(eax)</span><br><span class="line">mov hThread,eax             ; 将线程句柄放入hThread</span><br><span class="line">.endif</span><br><span class="line">invoke ResumeThread, hThread    ; 运行这个线程</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>创建事件:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpEventName DWORD ?         ; 创建的时间名称</span><br><span class="line">hEventID    DWORD ?         ; 成功后返回的句柄</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">invoke CreateEvent,NULL,TRUE,TRUE,addr lpEventName</span><br><span class="line">.if(eax != NULL)</span><br><span class="line">mov hEventID,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke WaitForSingleObject,addr hEventID,INFINITE  ; 等待一个事件</span><br><span class="line">invoke SetEvent,addr hEventID    ; 将事件的状态设置为:&quot;置位&quot;</span><br><span class="line"></span><br><span class="line">invoke ResetEvent,hEventID       ; 将事件的状态设置为:&quot;复位&quot;</span><br><span class="line">invoke CloseHandle,hEventID      ; 关闭这个句柄</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="DLL与线程注入"><a href="#DLL与线程注入" class="headerlink" title="DLL与线程注入"></a>DLL与线程注入</h2><h3 id="◆创建动态链接库◆"><a href="#◆创建动态链接库◆" class="headerlink" title="◆创建动态链接库◆"></a>◆创建动态链接库◆</h3><p><strong>创建dll:</strong> 这里我们创建一个<code>lyshark.asm</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">lpText db &quot;hello lyshark&quot;,0</span><br><span class="line">lpCapt db &quot;MsgBox&quot;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">DllEntry PROC _hInstance,_dwReason,_dwReserved</span><br><span class="line">mov eax,TRUE</span><br><span class="line">ret</span><br><span class="line">DllEntry ENDP</span><br><span class="line"></span><br><span class="line">_MsgBox PROC                          ; 无参数的信息框</span><br><span class="line">invoke MessageBox,NULL,addr lpText,addr lpCapt,MB_OK</span><br><span class="line">ret</span><br><span class="line">_MsgBox ENDP</span><br><span class="line"></span><br><span class="line">_MySum PROC Num_x:DWORD,Num_y:DWORD   ; 一个加法计算的函数</span><br><span class="line">mov eax,Num_x</span><br><span class="line">add eax,Num_y</span><br><span class="line">ret</span><br><span class="line">_MySum endp</span><br><span class="line">end DllEntry</span><br></pre></td></tr></table></figure></p><p><strong>创建def:</strong> 然后在当前目录下创建一个<code>lyshark.def</code>文件,用来声明导入库的函数名.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPORTS _MsgBox</span><br><span class="line">EXPORTS _MySum</span><br></pre></td></tr></table></figure></p><p><strong>创建inc文件:</strong> 在当前目录继续创建一个<code>lyshark.inc</code>文件,并写入相应的导入函数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_MsgBox PROTO</span><br><span class="line">_MySum  PROTO Num_X:DWORD,Num_Y:DWORD</span><br></pre></td></tr></table></figure></p><p><strong>生成dll:</strong> 生成dll执行如下代码.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ml /c /coff lyshark.asm</span><br><span class="line">link /SUBSYSTEM:WINDOWS /RELEASE /DLL /DEF:lyshark.def /OUT:&quot;lyshark.dll&quot; &quot;lyshark.obj&quot;</span><br></pre></td></tr></table></figure></p><p><strong>直接调用dll:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include lyshark.inc</span><br><span class="line">includelib lyshark.lib</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke _MsgBox</span><br><span class="line">invoke _MySum,100,200</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>动态装载dll(无参):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szMyDll        db &quot;lyshark.dll&quot;,0h   ; 装入的动态链接库名称</span><br><span class="line">szMsgBox       db &quot;_MsgBox&quot;,0h       ; 装入的函数名（无参）</span><br><span class="line">hLibMod        dd  ?                 ; dll的句柄</span><br><span class="line">lpMsgBox       dd  ?                 ; 函数的地址</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke LoadLibrary,addr szMyDll ; 加载指定的dll</span><br><span class="line">.if(eax)</span><br><span class="line">mov hLibMod,eax</span><br><span class="line">invoke GetProcAddress,hLibMod,addr szMsgBox</span><br><span class="line">mov lpMsgBox,eax</span><br><span class="line">call lpMsgBox         ; 调用MsgBox</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke FreeLibrary,hLibMod    ; 传递句柄,并释放dll</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>动态装载dll(有参):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szMyDll   db &quot;lyshark.dll&quot;,0h   ; 装入的动态链接库名称</span><br><span class="line">szMySum   db &quot;_MySum&quot;,0h        ; 装入的函数名（无参）</span><br><span class="line">hLibMod   dd  ?                 ; dll的句柄</span><br><span class="line">lpMySum   dd  ?                 ; 函数的地址</span><br><span class="line">Num_X     dd 10                 ; 参数x=10</span><br><span class="line">Num_Y     dd 20                 ; 参数y=20</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke LoadLibrary,addr szMyDll ; 加载指定的dll</span><br><span class="line">.if(eax)</span><br><span class="line">mov hLibMod,eax</span><br><span class="line">invoke GetProcAddress,hLibMod,addr szMySum</span><br><span class="line">mov lpMySum,eax</span><br><span class="line"></span><br><span class="line">push Num_Y           ; 压入第二个参数</span><br><span class="line">push Num_X           ; 压入第一个参数</span><br><span class="line">call lpMySum         ; 调用_MySum 函数</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke FreeLibrary,hLibMod    ; 传递句柄,并释放dll</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><h3 id="◆远程线程DLL注入◆"><a href="#◆远程线程DLL注入◆" class="headerlink" title="◆远程线程DLL注入◆"></a>◆远程线程DLL注入◆</h3><p><strong>动态调用函数:</strong> 动态的加载并使用一个函数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szDllKernel db &quot;Kernel32.dll&quot;,0h</span><br><span class="line">szFunction  db &quot;GetVersion&quot;,0h</span><br><span class="line">CallAddr    dd ?</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetModuleHandle,offset szDllKernel               ; 取出模块句柄</span><br><span class="line">.if(eax != 0)</span><br><span class="line">invoke GetProcAddress,eax,offset szFunction     ; 取出函数的地址</span><br><span class="line">mov CallAddr,eax                                ; 保存函数地址</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">call CallAddr           ; 直接调用kernel32.GetVersion</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>编写DLL:</strong> 首先编写一个dLL用来测试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szText DB &quot;welcome to asm&quot;,0h</span><br><span class="line">szCaption DB &quot;MsgBox&quot;,0h</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">Main PROC</span><br><span class="line">invoke MessageBox,NULL,addr szText,addr szCaption,MB_OK</span><br><span class="line">ret</span><br><span class="line">Main endp</span><br><span class="line"></span><br><span class="line">DllEntry PROC _hInstance,_dwReason,_dwReserved</span><br><span class="line">call Main</span><br><span class="line">moveax,TRUE</span><br><span class="line">ret</span><br><span class="line">DllEntry ENDP</span><br><span class="line">END DllEntry</span><br></pre></td></tr></table></figure></p><p><strong>注入DLL:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szMyDll        db &quot;\lyshark.dll&quot;,0h       ; 要注入的DLL</span><br><span class="line">szDllKernel    db &quot;Kernel32.dll&quot;,0h</span><br><span class="line">szLoadLibrary  db &quot;LoadLibraryA&quot;,0h</span><br><span class="line">lpFileName     db &quot;Tutorial-i386&quot;,0h      ; 指定要注入进程</span><br><span class="line">lpDllName      dd ?</span><br><span class="line">.data?</span><br><span class="line">szMyDllFull    db MAX_PATH dup (?)</span><br><span class="line">lpLoadLibrary  dd ?</span><br><span class="line">dwProcessID    dd ?     </span><br><span class="line">dwThreadID     dd ?</span><br><span class="line">hProcess       dd ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 准备工作：获取dll的全路径文件名、获取LoadLibrary函数地址等</span><br><span class="line">invoke GetCurrentDirectory,MAX_PATH,addr szMyDllFull</span><br><span class="line">invoke lstrcat,addr szMyDllFull,addr szMyDll</span><br><span class="line">invoke GetModuleHandle,addr szDllKernel</span><br><span class="line">invoke GetProcAddress,eax,offset szLoadLibrary</span><br><span class="line">mov lpLoadLibrary,eax</span><br><span class="line"></span><br><span class="line">; 查找文件管理器窗口并获取进程ID，然后打开进程</span><br><span class="line">invoke FindWindow,NULL,addr lpFileName</span><br><span class="line">invoke GetWindowThreadProcessId,eax,offset dwProcessID</span><br><span class="line">  mov dwThreadID,eax</span><br><span class="line">  invoke OpenProcess,PROCESS_ALL_ACCESS,FALSE,dwProcessID</span><br><span class="line">mov hProcess,eax</span><br><span class="line"></span><br><span class="line">; 在进程中分配空间并将DLL文件名拷贝过去，然后创建一个LoadLibrary线程</span><br><span class="line">invoke VirtualAllocEx,hProcess,NULL,MAX_PATH,MEM_COMMIT,PAGE_READWRITE</span><br><span class="line">mov lpDllName,eax</span><br><span class="line">invoke WriteProcessMemory,hProcess,eax,offset szMyDllFull,MAX_PATH,NULL</span><br><span class="line">invoke CreateRemoteThread,hProcess,NULL,0,lpLoadLibrary,lpDllName,0,NULL</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><h3 id="◆远程线程代码注入◆"><a href="#◆远程线程代码注入◆" class="headerlink" title="◆远程线程代码注入◆"></a>◆远程线程代码注入◆</h3><p><strong>注入器:</strong> 新建main.asm<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">lpLoadLibrary      dd ?</span><br><span class="line">lpGetProcAddress   dd ?</span><br><span class="line">lpGetModuleHandle  dd ?</span><br><span class="line">dwProcessID        dd ?</span><br><span class="line">dwThreadID         dd ?</span><br><span class="line">hProcess           dd ?</span><br><span class="line">lpRemoteCode       dd ?</span><br><span class="line">.const</span><br><span class="line">ProcHandle        db &quot;lyshark.exe&quot;,0h</span><br><span class="line">KernelBase        db &quot;Kernel32.dll&quot;,0h</span><br><span class="line">szLoadLibrary     db &quot;LoadLibraryA&quot;,0h</span><br><span class="line">szGetProcAddress  db &quot;GetProcAddress&quot;,0h</span><br><span class="line">szGetModuleHandle db &quot;GetModuleHandleA&quot;,0h</span><br><span class="line">.code</span><br><span class="line">include Macro.inc</span><br><span class="line">include ShellCode.asm</span><br><span class="line">main proc</span><br><span class="line">invoke GetModuleHandle,addr KernelBase</span><br><span class="line">mov ebx,eax</span><br><span class="line">invoke GetProcAddress,ebx,offset szLoadLibrary</span><br><span class="line">mov lpLoadLibrary,eax</span><br><span class="line">invoke GetProcAddress,ebx,offset szGetProcAddress</span><br><span class="line">mov lpGetProcAddress,eax</span><br><span class="line">invoke GetProcAddress,ebx,offset szGetModuleHandle</span><br><span class="line">mov lpGetModuleHandle,eax</span><br><span class="line"></span><br><span class="line">invoke FindWindow,NULL,addr ProcHandle</span><br><span class="line">invoke GetWindowThreadProcessId,eax,offset dwProcessID</span><br><span class="line">mov dwThreadID,eax</span><br><span class="line">invoke OpenProcess,PROCESS_ALL_ACCESS,FALSE,dwProcessID</span><br><span class="line">mov hProcess,eax</span><br><span class="line"></span><br><span class="line">invoke VirtualAllocEx,hProcess,NULL,2048,MEM_COMMIT,PAGE_EXECUTE_READWRITE</span><br><span class="line">.if eax</span><br><span class="line">mov lpRemoteCode,eax</span><br><span class="line">invoke WriteProcessMemory,hProcess,lpRemoteCode,offset REMOTE_CODE_START,1024,NULL</span><br><span class="line">invoke WriteProcessMemory,hProcess,lpRemoteCode,offset lpLoadLibrary,sizeof dword * 3,NULL</span><br><span class="line">mov eax,lpRemoteCode</span><br><span class="line">add eax,offset _RemoteThread - offset REMOTE_CODE_START</span><br><span class="line">invoke CreateRemoteThread,hProcess,NULL,0,eax,0,0,NULL</span><br><span class="line">invoke CloseHandle,eax</span><br><span class="line">.endif</span><br><span class="line">invoke CloseHandle,hProcess</span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>反转宏:</strong> Macro.inc 用来翻转参数,定义_invoke<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; --------------------------------------------</span><br><span class="line">; 翻转参数字节序</span><br><span class="line">reverseArgs macro arglist:VARARG</span><br><span class="line">LOCAL txt,count</span><br><span class="line">txt TEXTEQU &lt;&gt;</span><br><span class="line">count=0</span><br><span class="line">for i,&lt;arglist&gt;</span><br><span class="line">count = count+1</span><br><span class="line">txt TEXTEQU @CatStr(i,&lt;!,&gt;,&lt;%txt&gt;)</span><br><span class="line">endm</span><br><span class="line">if count GT 0</span><br><span class="line">txt SUBSTR txt,1,@SizeStr(%txt)-1</span><br><span class="line">endif</span><br><span class="line">exitm txt</span><br><span class="line">endm</span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 创建类似于INVOKE的宏代码</span><br><span class="line">_invoke macro _Proc,args:VARARG</span><br><span class="line">LOCAL count</span><br><span class="line">count = 0</span><br><span class="line">%for i,&lt; reverseArgs( args ) &gt;</span><br><span class="line">count = count+1</span><br><span class="line">push i</span><br><span class="line">endm</span><br><span class="line">call dword ptr _Proc    </span><br><span class="line">endm</span><br></pre></td></tr></table></figure></p><p><strong>注入代码:</strong> shellcode.asm<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REMOTE_CODE_START equ this byte</span><br><span class="line">_lpLoadLibrary      dd ?</span><br><span class="line">_lpGetProcAddress   dd ?</span><br><span class="line">_lpGetModuleHandle  dd ?</span><br><span class="line"></span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 存放静态资源,比如常量,字符串等.</span><br><span class="line">_hInstance          dd ?</span><br><span class="line">_szShowTitle        db &quot;hello lyshark&quot;,0h</span><br><span class="line"></span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 存放获取到的指针</span><br><span class="line">_lpDllUser          dd ?</span><br><span class="line">_lpMessageBox       dd ?</span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 放入导入函数的字符串</span><br><span class="line">_szDllUserdb&quot;user32.dll&quot;,0h</span><br><span class="line">_szMessageBox           db      &quot;MessageBoxA&quot;,0h,0</span><br><span class="line">; --------------------------------------------</span><br><span class="line">_RemoteThread proc uses ebx esi edi</span><br><span class="line">LOCAL @hModule</span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 计算指令的偏移地址,用ebx作为基址指针</span><br><span class="line">call @F</span><br><span class="line">@@:</span><br><span class="line">pop ebx</span><br><span class="line">sub ebx,offset @B</span><br><span class="line">; --------------------------------------------</span><br><span class="line">_invoke [ebx + _lpGetModuleHandle],NULL         ; 取当前模块句柄</span><br><span class="line">mov [ebx + _hInstance],eax</span><br><span class="line">lea eax,[ebx + offset _szDllUser]           </span><br><span class="line">_invoke [ebx + _lpGetModuleHandle],eax          ; 取user32.dll模块句柄</span><br><span class="line">mov @hModule,eax</span><br><span class="line">; --------------------------------------------</span><br><span class="line">; 循环获取每个导入函数的地址,并放入指针变量保存</span><br><span class="line">lea esi,[ebx + offset _szMessageBox]            ; 循环获取,从该函数起始地址处</span><br><span class="line">lea edi,[ebx + offset _lpMessageBox]</span><br><span class="line">.while TRUE</span><br><span class="line">_invoke[ebx + _lpGetProcAddress],@hModule,esi</span><br><span class="line">mov [edi],eax       ; 获取到函数地址后,放入导入函数字符串中</span><br><span class="line">add edi,4           ; 每次递增4字节,指向下一个函数,遇到0则停止</span><br><span class="line">@@:</span><br><span class="line">lodsb</span><br><span class="line">or al,al</span><br><span class="line">jnz @B</span><br><span class="line">.break .if !byte ptr [esi]</span><br><span class="line">.endw</span><br><span class="line">; --------------------------------------------</span><br><span class="line">;lea esi,[ebx+ offset _szMessageBox]            ; 取msgbox模块地址</span><br><span class="line">;_invoke [ebx+_lpGetProcAddress],@hModule,esi   ; 获取地址</span><br><span class="line">;mov [ebx+_lpMessageBox],eax                    ; 存入变量中</span><br><span class="line">lea esi,[ebx + offset _szShowTitle]             ; 获取弹窗资源</span><br><span class="line">_invoke [ebx + _lpMessageBox],0,esi,eax,0       ; 调用信息框</span><br><span class="line">ret</span><br><span class="line">_RemoteThread endp</span><br></pre></td></tr></table></figure></p><h3 id="◆创建Windows钩子◆"><a href="#◆创建Windows钩子◆" class="headerlink" title="◆创建Windows钩子◆"></a>◆创建Windows钩子◆</h3><p><strong>创建DLL文件:</strong> hookdll.dll<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstdll dd ?          ; dll句柄</span><br><span class="line">hHook    dd ?          ; 钩子句柄</span><br><span class="line">szAscii  db 5 dup (?)</span><br><span class="line">.code</span><br><span class="line">; ------------------------------------------------------------------</span><br><span class="line">; 钩子回调函数,这里按键后,弹出信息框提示</span><br><span class="line">CallBack proc nCode:DWORD,wParam:DWORD,lParam:DWORD</span><br><span class="line">LOCAL @szKeyState[256]:byte</span><br><span class="line">invoke CallNextHookEx,hHook,nCode,wParam,lParam </span><br><span class="line">invoke GetKeyboardState,addr @szKeyState</span><br><span class="line">invoke GetKeyState,VK_SHIFT</span><br><span class="line">mov @szKeyState+VK_SHIFT,al</span><br><span class="line">mov ecx,lParam</span><br><span class="line">shr ecx,16</span><br><span class="line">invoke ToAscii,wParam,ecx,addr @szKeyState,addr szAscii,0</span><br><span class="line">mov byte ptr szAscii [eax],0</span><br><span class="line">invoke MessageBox,NULL,addr wParam,0,MB_OK    ; 弹出信息框</span><br><span class="line">ret</span><br><span class="line">CallBack endp</span><br><span class="line">; ------------------------------------------------------------------</span><br><span class="line">; 加载钩子,安装hook的子程序</span><br><span class="line">installhook proc</span><br><span class="line">invoke SetWindowsHookEx,WH_KEYBOARD,addr CallBack,hInstdll,NULL</span><br><span class="line">mov hHook,eax</span><br><span class="line">ret</span><br><span class="line">installhook endp</span><br><span class="line">; ------------------------------------------------------------------</span><br><span class="line">; 卸载钩子,清除hook的子程序</span><br><span class="line">uninstallhook proc</span><br><span class="line">invoke UnhookWindowsHookEx,hHook</span><br><span class="line">ret</span><br><span class="line">uninstallhook endp</span><br><span class="line">; ------------------------------------------------------------------</span><br><span class="line">; DllMain 程序入口函数</span><br><span class="line">DllMain proc _hInstance:HINSTANCE,_dwReason:DWORD, _dwResverved:DWORD</span><br><span class="line">.if(_dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">push _hInstance</span><br><span class="line">pop hInstdll</span><br><span class="line">.elseif(_dwReason == DLL_PROCESS_DETACH)</span><br><span class="line">call uninstallhook</span><br><span class="line">.endif</span><br><span class="line">mov eax,TRUE</span><br><span class="line">ret</span><br><span class="line">DllMain endp</span><br><span class="line">end DllMain</span><br></pre></td></tr></table></figure></p><p><strong>创建inc文件:</strong> hookdll.inc<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">installhook proto</span><br><span class="line">uninstallhook proto</span><br></pre></td></tr></table></figure></p><p><strong>创建def:</strong> hookdll.def,并将目录下的hook.dll,hook.inc,hook.lib 拷贝出来.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LIBRARY hookdll</span><br><span class="line">EXPORTS installhook</span><br><span class="line">EXPORTS uninstallhook</span><br></pre></td></tr></table></figure></p><p><strong>创建主程序:</strong> 创建main.asm文件,并将hookdll.dll,hookdll.inc,hookdll.lib拷贝到目录下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include hookdll.inc</span><br><span class="line">includelib hookdll.lib</span><br><span class="line"></span><br><span class="line">.data?</span><br><span class="line">hInstance dd ?</span><br><span class="line">uMsg MSG &lt;?&gt;</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke installhook</span><br><span class="line">invoke GetModuleHandle,NULL</span><br><span class="line">mov hInstance,eax</span><br><span class="line">.while(TRUE)</span><br><span class="line">invoke GetMessage,addr uMsg,NULL,0,0</span><br><span class="line">invoke TranslateMessage,addr uMsg</span><br><span class="line">invoke DispatchMessage,addr uMsg</span><br><span class="line">.endw</span><br><span class="line">invoke uninstallhook</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="注册表和INI文件"><a href="#注册表和INI文件" class="headerlink" title="注册表和INI文件"></a>注册表和INI文件</h2><h3 id="◆注册表相关◆"><a href="#◆注册表相关◆" class="headerlink" title="◆注册表相关◆"></a>◆注册表相关◆</h3><p><strong>遍历子键:</strong> HKEY_LOCAL_MACHINE中的子键<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">dwIndex   dd ?</span><br><span class="line">dwSize    dd ?</span><br><span class="line">szBuffer  db 256 dup(?)</span><br><span class="line">PrintText db &quot;%s&quot;,0ah</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">mov dwIndex,0</span><br><span class="line">.while(TRUE)</span><br><span class="line">mov dwSize,offset szBuffer</span><br><span class="line">invoke RegEnumKeyEx,HKEY_LOCAL_MACHINE,dwIndex,addr szBuffer,addr dwSize, \</span><br><span class="line">NULL,NULL,NULL,NULL</span><br><span class="line">.break .if eax == ERROR_NO_MORE_ITEMS</span><br><span class="line">invoke crt_printf,addr PrintText,addr szBuffer</span><br><span class="line">inc dwIndex</span><br><span class="line">.endw</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>创建键值:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szKeyPATH    db &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;,0h</span><br><span class="line">szValueName  db &quot;AutoRun Shell&quot;,0h</span><br><span class="line">szFileName   db MAX_PATH dup(?)</span><br><span class="line">.code</span><br><span class="line">_RegSetValue proc _lpszKey,_lpszValueName,_lpszValue,_dwValueType,_dwSize</span><br><span class="line">LOCAL @hKey</span><br><span class="line">invoke RegCreateKey,HKEY_LOCAL_MACHINE,_lpszKey,addr @hKey</span><br><span class="line">.if (eax == ERROR_SUCCESS)</span><br><span class="line">invokeRegSetValueEx,@hKey,_lpszValueName,NULL,\</span><br><span class="line">_dwValueType,_lpszValue,_dwSize</span><br><span class="line">invoke RegCloseKey,@hKey</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">_RegSetValueendp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">invoke GetModuleFileName,NULL,addr szFileName,MAX_PATH  ; 获取文件全路径</span><br><span class="line">inc eax</span><br><span class="line">invoke _RegSetValue,addr szKeyPATH,addr szValueName,addr szFileName,REG_SZ,eax</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>删除键值:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szKeyPATH   db &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;,0h</span><br><span class="line">szValueName db &quot;AutoRun Shell&quot;,0h</span><br><span class="line">.code</span><br><span class="line">_RegDelValue proc _lpszKey,_lpszValueName</span><br><span class="line">LOCAL @hKey</span><br><span class="line">invoke RegOpenKeyEx,HKEY_LOCAL_MACHINE,_lpszKey,NULL,KEY_WRITE,addr @hKey</span><br><span class="line">.if(eax == ERROR_SUCCESS)</span><br><span class="line">invoke RegDeleteValue,@hKey,_lpszValueName</span><br><span class="line">invoke RegCloseKey,@hKey</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">_RegDelValue endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">invoke _RegDelValue,addr szKeyPATH,addr szValueName</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>创建子键</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">lpszKey    db &quot;Software\Microsoft\\Windows\\CurrentVersion\\Run\\&quot;,0h</span><br><span class="line">lpszSubKey db &quot;MySub&quot;,0h</span><br><span class="line">.code</span><br><span class="line">_RegCreateKey proc _lpszKey,_lpszSubKeyName</span><br><span class="line">LOCAL @hKey,@hSubkey,@dwDisp</span><br><span class="line">invoke RegOpenKeyEx,HKEY_LOCAL_MACHINE,_lpszKey,NULL,KEY_CREATE_SUB_KEY,addr @hKey</span><br><span class="line">.if eax == ERROR_SUCCESS</span><br><span class="line">invoke RegCreateKeyEx,@hKey,_lpszSubKeyName,NULL,NULL,\</span><br><span class="line">NULL,NULL,NULL,addr @hSubkey,addr @dwDisp</span><br><span class="line">invoke RegCloseKey,@hKey</span><br><span class="line">invoke RegCloseKey,@hSubkey</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">_RegCreateKey endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">invoke _RegCreateKey,addr lpszKey,addr lpszSubKey</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>删除子键：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">lpszKey    db &quot;Software\Microsoft\\Windows\\CurrentVersion\\Run\\&quot;,0h</span><br><span class="line">lpszSubKey db &quot;MySub&quot;,0h</span><br><span class="line">.code</span><br><span class="line">_RegDelSubKey proc _lpszKey,_lpszSubKeyName</span><br><span class="line">LOCAL @hKey</span><br><span class="line">invoke RegOpenKeyEx,HKEY_LOCAL_MACHINE,_lpszKey,NULL,KEY_WRITE,addr @hKey</span><br><span class="line">.if eax == ERROR_SUCCESS</span><br><span class="line">invoke RegDeleteKey,@hKey,_lpszSubKeyName</span><br><span class="line">invoke RegCloseKey,@hKey</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">_RegDelSubKey endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">invoke _RegDelSubKey,addr lpszKey,addr lpszSubKey</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>读取键值：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">lpDwSize  dd 1024</span><br><span class="line">lpValue   db 1024 dup(?)</span><br><span class="line">szKeyPATH   db &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run\\&quot;,0h</span><br><span class="line">szValueName db &quot;IgfxTray&quot;,0h</span><br><span class="line">.code</span><br><span class="line">_RegQueryValue proc _lpszKey,_lpszValueName,_lpszValue,_lpdwSize,_lpdwType</span><br><span class="line">LOCAL @hKey,@dwReturn</span><br><span class="line">mov @dwReturn,-1</span><br><span class="line">invoke RegOpenKeyEx,HKEY_LOCAL_MACHINE,_lpszKey,NULL,\</span><br><span class="line">KEY_QUERY_VALUE,addr @hKey</span><br><span class="line">.if eax == ERROR_SUCCESS</span><br><span class="line">invoke RegQueryValueEx,@hKey,_lpszValueName,NULL,_lpdwType,\</span><br><span class="line">_lpszValue,_lpdwSize</span><br><span class="line">mov @dwReturn,eax</span><br><span class="line">invoke RegCloseKey,@hKey</span><br><span class="line">.endif</span><br><span class="line">mov eax,@dwReturn</span><br><span class="line">ret</span><br><span class="line">_RegQueryValue endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">invoke _RegQueryValue,addr szKeyPATH,addr szValueName,addr lpValue,addr lpDwSize,0</span><br><span class="line">lea eax,lpValue</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>设置开机自启动:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include advapi32.inc</span><br><span class="line">includelib advapi32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szhKey         dd ?</span><br><span class="line">szFileName     db MAX_PATH dup(?)                                        ; 获取当前路径</span><br><span class="line">szKeyAutoRun   db &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;,0h ; 写入子键</span><br><span class="line">szValueAutoRun db &quot;AutoRun Shell&quot;,0h                                     ; 写入的名称</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetModuleFileName,NULL,addr szFileName,MAX_PATH  ; 获取文件全路径</span><br><span class="line">invoke RegCreateKey,HKEY_LOCAL_MACHINE,addr szKeyAutoRun,addr szhKey</span><br><span class="line">.if(eax == ERROR_SUCCESS)</span><br><span class="line">invoke RegSetValueEx,szhKey,addr szValueAutoRun,NULL,REG_SZ, \</span><br><span class="line">addr szFileName,sizeof szFileName</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><h3 id="◆INI文件相关◆"><a href="#◆INI文件相关◆" class="headerlink" title="◆INI文件相关◆"></a>◆INI文件相关◆</h3><p><strong>创建INI:</strong> Option.ini<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lyshark]         ; 字段1</span><br><span class="line">X=1024</span><br><span class="line">Y=2048</span><br><span class="line">Z=4096</span><br><span class="line">[IniDemo]         ; 字段2</span><br><span class="line">StringKey=hello,lyshark!</span><br><span class="line">IntKey=123123</span><br><span class="line">ToString=lyshark</span><br></pre></td></tr></table></figure></p><p><strong>遍历Section列表:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">.data</span><br><span class="line">szStrlen     dd ?</span><br><span class="line">szBuffer1    db 20480 dup(?)</span><br><span class="line">szININame    db &quot;.\Option.ini&quot;,0h</span><br><span class="line">szFmtSection db &quot;[%s]&quot;,0h</span><br><span class="line">PrintText    db &quot;%s &quot;,0ah</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @szBuffer[256]:byte</span><br><span class="line">invoke GetPrivateProfileSectionNames,addr szBuffer1,sizeof szBuffer1,addr szININame</span><br><span class="line">mov esi,offset szBuffer1</span><br><span class="line">.while byte ptr [esi]</span><br><span class="line">invoke wsprintf,addr @szBuffer,addr szFmtSection,esi</span><br><span class="line">invoke crt_printf,addr PrintText,esi          ; 打印键值</span><br><span class="line">invoke lstrlen,esi</span><br><span class="line">add esi,eax</span><br><span class="line">inc esi</span><br><span class="line">.endw</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>遍历键值对</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line">.data</span><br><span class="line">szStrlen     dd ?</span><br><span class="line">szBuffer     db 2048 dup(?)</span><br><span class="line">szININame    db &quot;.\Option.ini&quot;,0h    ; 指定要遍历的文件</span><br><span class="line">szPrintKey   db &quot;lyshark&quot;,0h         ; 指定要遍历的key</span><br><span class="line">szFmtSection db &quot;[%s]&quot;,0h</span><br><span class="line">PrintText    db &quot;%s &quot;,0ah</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetPrivateProfileSection,addr szPrintKey,addr szBuffer,sizeof szBuffer,addr szININame</span><br><span class="line">mov edi,offset szBuffer</span><br><span class="line">.while byte ptr [edi]</span><br><span class="line">invoke crt_printf,addr PrintText,edi   ; 打印key</span><br><span class="line">invoke lstrlen,edi</span><br><span class="line">add edi,eax</span><br><span class="line">inc edi</span><br><span class="line">.endw</span><br><span class="line">invoke lstrlen,esi</span><br><span class="line">add esi,eax</span><br><span class="line">inc esi</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>拼接并打印字符串:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include masm32.inc</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szBuffer  db 2048 dup(?)       ; 保存当前路径</span><br><span class="line">szININame db &quot;\Option.ini&quot;,0h  ; 配置文件路径</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetCurrentDirectory,MAX_PATH,addr szBuffer</span><br><span class="line">mov esi,offset szBuffer</span><br><span class="line">invoke lstrlen,esi</span><br><span class="line">mov ecx,offset szININame</span><br><span class="line">.if byte ptr [esi+eax-1] == &apos;\&apos;</span><br><span class="line">inc ecx</span><br><span class="line">.endif</span><br><span class="line">invoke lstrcat,esi,ecx</span><br><span class="line">invoke StdOut, eax      ; 打印拼接后的字符串</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>读取:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"></span><br><span class="line">szININame   db &quot;.\Option.ini&quot;,0h       ; 指定要遍历的文件</span><br><span class="line">szSecPos    db &quot;IniDemo&quot;,0h            ; 指定要遍历的key</span><br><span class="line">szKeyInt    db &quot;IntKey&quot;,0h             ; 要读取的整数字段值</span><br><span class="line">szKeyStr    db &quot;StringKey&quot;,0h          ; 要读取的字符串字段</span><br><span class="line">szBuffer    db 2048 dup(?)</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke GetPrivateProfileInt,addr szSecPos,addr szKeyInt,50,addr szININame  ; 读取整数</span><br><span class="line">invoke GetPrivateProfileString,addr szSecPos,addr szKeyStr,0, \</span><br><span class="line">addr szBuffer,sizeof szBuffer,addr szININame                               ; 读取字符串</span><br><span class="line">lea eax,szBuffer</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>添加/删除键值:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include masm32.inc</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szBuffer  db 2048 dup(?)       ; 保存当前路径</span><br><span class="line">szININame db &quot;.\Option.ini&quot;,0h  ; 配置文件路径</span><br><span class="line">szAppName db &quot;IniDemo&quot;,0h       ; 字段为IniDemo</span><br><span class="line">lpAppKey  db &quot;Temp&quot;,0h          ; 键值对为Temp</span><br><span class="line">lpAppStr  db &quot;app temp&quot;,0h      ; 键值对值</span><br><span class="line">lpAppNew  db &quot;hello temp&quot;,0h    ; 新的键值对</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">; 在IniDemo中添加 Temp=apptemp</span><br><span class="line">invoke WritePrivateProfileString,addr szAppName,addr lpAppKey,addr lpAppStr,addr szININame</span><br><span class="line">; 将IniDemo中的Temp=app temp修改为Temp=hello temp</span><br><span class="line">invoke WritePrivateProfileString,addr szAppName,addr lpAppKey,addr lpAppNew,addr szININame</span><br><span class="line">; 删除IniDemo中的Temp键值对</span><br><span class="line">invoke WritePrivateProfileString,addr szAppName,addr lpAppKey,NULL,addr szININame</span><br><span class="line">; 清空IniDemo底下的所有键值对</span><br><span class="line">invoke WritePrivateProfileString,addr szAppName,NULL,NULL,addr szININame</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="通用对话框"><a href="#通用对话框" class="headerlink" title="通用对话框"></a>通用对话框</h2><p><strong>设置页面对话框:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include Comdlg32.inc</span><br><span class="line">includelib Comdlg32.lib</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @stPS:PAGESETUPDLG</span><br><span class="line">invoke RtlZeroMemory,addr @stPS,sizeof @stPS</span><br><span class="line">mov @stPS.lStructSize,sizeof @stPS</span><br><span class="line">mov @stPS.hwndOwner,0</span><br><span class="line">invoke PageSetupDlg,addr @stPS</span><br><span class="line">.if eax &amp;&amp; @stPS.hDevMode</span><br><span class="line">mov eax,@stPS.hDevMode</span><br><span class="line">mov eax,[eax]</span><br><span class="line">invoke MessageBox,0,eax,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>打开对话框:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include Comdlg32.inc</span><br><span class="line">includelib Comdlg32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szFilter   db &apos;Text Files(*.txt)&apos;,0,&apos;*.txt&apos;,0,&apos;All Files(*.*)&apos;,0,&apos;*.*&apos;,0,0</span><br><span class="line">szFileName db MAX_PATH dup (?)</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @stOF:OPENFILENAME</span><br><span class="line">invoke RtlZeroMemory,addr @stOF,sizeof @stOF</span><br><span class="line">mov @stOF.lStructSize,sizeof @stOF</span><br><span class="line">mov @stOF.hwndOwner,eax</span><br><span class="line">mov @stOF.lpstrFilter,offset szFilter</span><br><span class="line">mov @stOF.lpstrFile,offset szFileName</span><br><span class="line">mov @stOF.nMaxFile,MAX_PATH</span><br><span class="line">mov @stOF.Flags,OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST</span><br><span class="line">invoke GetOpenFileName,addr @stOF</span><br><span class="line">.if eax</span><br><span class="line">invoke MessageBox,NULL,addr szFileName,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>保存对话框:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include Comdlg32.inc</span><br><span class="line">includelib Comdlg32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szFilter      db &apos;Text Files(*.txt)&apos;,0,&apos;*.txt&apos;,0,&apos;All Files(*.*)&apos;,0,&apos;*.*&apos;,0,0</span><br><span class="line">szFileName    db MAX_PATH dup (?)</span><br><span class="line">szDefExt      db &apos;txt&apos;,0</span><br><span class="line">szSaveCaption db &apos;请输入保存的文件名&apos;,0</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @stOF:OPENFILENAME</span><br><span class="line">invoke RtlZeroMemory,addr @stOF,sizeof @stOF</span><br><span class="line">mov @stOF.lStructSize,sizeof @stOF</span><br><span class="line">mov @stOF.hwndOwner,0</span><br><span class="line">mov @stOF.lpstrFilter,offset szFilter</span><br><span class="line">mov @stOF.lpstrFile,offset szFileName</span><br><span class="line">mov @stOF.nMaxFile,MAX_PATH</span><br><span class="line">mov @stOF.Flags,OFN_PATHMUSTEXIST</span><br><span class="line">mov @stOF.lpstrDefExt,offset szDefExt</span><br><span class="line">mov @stOF.lpstrTitle,offset szSaveCaption</span><br><span class="line">invoke GetSaveFileName,addr @stOF</span><br><span class="line">.if eax</span><br><span class="line">invoke MessageBox,NULL,addr szFileName,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>选择颜色:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include Comdlg32.inc</span><br><span class="line">includelib Comdlg32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">dwBackColor     dd ?</span><br><span class="line">dwCustColors    dd 16 dup (?)</span><br><span class="line">szBuffer        db 1024 dup (?)</span><br><span class="line">szFormatColor   db &quot;您选择的颜色值：%08x&quot;,0</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @stCC:CHOOSECOLOR</span><br><span class="line">invoke RtlZeroMemory,addr @stCC,sizeof @stCC</span><br><span class="line">mov @stCC.lStructSize,sizeof @stCC</span><br><span class="line">mov @stCC.hwndOwner,0</span><br><span class="line">push dwBackColor</span><br><span class="line">pop @stCC.rgbResult</span><br><span class="line">mov @stCC.Flags,CC_RGBINIT or CC_FULLOPEN</span><br><span class="line">mov @stCC.lpCustColors,offset dwCustColors</span><br><span class="line">invokeChooseColor,addr @stCC</span><br><span class="line">.if eax</span><br><span class="line">push @stCC.rgbResult</span><br><span class="line">pop dwBackColor</span><br><span class="line">invoke wsprintf,addr szBuffer,addr szFormatColor,dwBackColor</span><br><span class="line">invoke MessageBox,NULL,addr szBuffer,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>选择字体:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include Comdlg32.inc</span><br><span class="line">includelib Comdlg32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">stLogFont      LOGFONT &lt;?&gt;</span><br><span class="line">dwFontColor    dd ?</span><br><span class="line">szBuffer       db 1024 dup (?)</span><br><span class="line">szFormatFont   db &apos;字体名称：%s&apos;,0dh,0ah</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">LOCAL @stCF:CHOOSEFONT</span><br><span class="line">invoke RtlZeroMemory,addr @stCF,sizeof @stCF</span><br><span class="line">mov @stCF.lStructSize,sizeof @stCF</span><br><span class="line">mov @stCF.hwndOwner,0</span><br><span class="line">mov @stCF.lpLogFont,offset stLogFont</span><br><span class="line">push dwFontColor</span><br><span class="line">pop @stCF.rgbColors</span><br><span class="line">mov @stCF.Flags,CF_SCREENFONTS or CF_INITTOLOGFONTSTRUCT or CF_EFFECTS</span><br><span class="line">invoke ChooseFont,addr @stCF</span><br><span class="line">.if eax</span><br><span class="line">push @stCF.rgbColors</span><br><span class="line">pop dwFontColor</span><br><span class="line">invoke wsprintf,addr szBuffer,addr szFormatFont,addr stLogFont.lfFaceName,\</span><br><span class="line">dwFontColor,@stCF.iPointSize</span><br><span class="line">invoke MessageBox,NULL,addr szBuffer,0,MB_OK</span><br><span class="line">.endif</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="网络相关函数"><a href="#网络相关函数" class="headerlink" title="网络相关函数"></a>网络相关函数</h2><p><strong>服务端:</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_addr=(<span class="string">"127.0.0.1"</span>,<span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind(ip_addr)</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=server.accept()</span><br><span class="line">    print(addr)</span><br><span class="line">    send_data = input(<span class="string">"input:"</span>)</span><br><span class="line">    conn.send(bytes(send_data,encoding=<span class="string">"ascii"</span>))</span><br><span class="line"></span><br><span class="line">    recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(recv_data, encoding=<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure></p><p><strong>客户端:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include ws2_32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib ws2_32.lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TCP_PORT equ 6666</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">WSAData  WSADATA &lt;&gt;</span><br><span class="line">stSin sockaddr_in &lt;&gt;</span><br><span class="line">szServer byte &quot;127.0.0.1&quot;,0h</span><br><span class="line">sock dd ?</span><br><span class="line">Buff BYTE 256 dup (?)                ; 接收数据的缓冲区</span><br><span class="line">Send BYTE &quot;hello&quot;,0h                 ; 发送数据缓冲区</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke WSAStartup,0202h,addr WSAData</span><br><span class="line">invoke socket,AF_INET, SOCK_STREAM, 0</span><br><span class="line">.if(eax != INVALID_SOCKET)</span><br><span class="line">mov sock,eax</span><br><span class="line">.endif</span><br><span class="line">mov stSin.sin_family,AF_INET</span><br><span class="line">invoke htons,TCP_PORT</span><br><span class="line">mov stSin.sin_port,ax</span><br><span class="line">invoke inet_addr,addr szServer</span><br><span class="line">mov stSin.sin_addr,eax</span><br><span class="line">invoke connect,sock,addr stSin,sizeof stSin    ; 连接套接字</span><br><span class="line"></span><br><span class="line">invoke recv,sock,addr Buff,sizeof Buff,0       ; 接收内容</span><br><span class="line">lea eax,Buff</span><br><span class="line">invoke send,sock,addr Send,sizeof Send,0       ; 发送数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">invoke closesocket,sock</span><br><span class="line">invoke WSACleanup</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><hr><p>改进版</p><p><strong>服务端:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">ip_addr=(&quot;127.0.0.1&quot;,6666)</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind(ip_addr)</span><br><span class="line">server.listen(5)</span><br><span class="line"></span><br><span class="line">conn, addr = server.accept()</span><br><span class="line">print(addr)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    send_data = input(&quot;input:&quot;)</span><br><span class="line">    conn.send(bytes(send_data,encoding=&quot;ascii&quot;))</span><br><span class="line">    recv_data = conn.recv(1024)</span><br><span class="line">    print(str(recv_data, encoding=&quot;ascii&quot;))</span><br></pre></td></tr></table></figure></p><p><strong>客户端:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include ws2_32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib ws2_32.lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TCP_PORT equ 6666</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">WSAData  WSADATA &lt;&gt;</span><br><span class="line">stSin sockaddr_in &lt;&gt;</span><br><span class="line">szServer byte &quot;127.0.0.1&quot;,0h</span><br><span class="line">sock dd ?</span><br><span class="line">Buff BYTE 256 dup (?)                ; 接收数据的缓冲区</span><br><span class="line">Send BYTE &quot;ls&quot;,0h                 ; 发送数据缓冲区</span><br><span class="line">Send1 BYTE &quot;down&quot;,0h</span><br><span class="line">cmdls BYTE &quot;ls&quot;,0h</span><br><span class="line">cmddown BYTE &quot;down&quot;,0h</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">invoke WSAStartup,0202h,addr WSAData</span><br><span class="line">invoke socket,AF_INET, SOCK_STREAM, 0</span><br><span class="line">.if(eax != INVALID_SOCKET)</span><br><span class="line">mov sock,eax</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">invoke RtlZeroMemory,addr stSin,sizeof stSin</span><br><span class="line"></span><br><span class="line">mov stSin.sin_family,AF_INET</span><br><span class="line">invoke htons,TCP_PORT</span><br><span class="line">mov stSin.sin_port,ax</span><br><span class="line">invoke inet_addr,addr szServer</span><br><span class="line">mov stSin.sin_addr,eax</span><br><span class="line">invoke connect,sock,addr stSin,sizeof stSin    ; 连接套接字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.while(1)</span><br><span class="line">invoke RtlZeroMemory,addr Buff,sizeof Buff</span><br><span class="line">invoke recv,sock,addr Buff,sizeof Buff,0</span><br><span class="line"></span><br><span class="line">invoke lstrcmp,addr cmdls,addr Buff                    ; 对比字符串是否是ls</span><br><span class="line">.if(eax==0)</span><br><span class="line">invoke send,sock,addr Send,sizeof Send,0</span><br><span class="line">.continue</span><br><span class="line">.endif</span><br><span class="line">invoke lstrcmp,addr Buff,addr cmddown                  ; 对比是不是down</span><br><span class="line">.if(eax==0)</span><br><span class="line">invoke send,sock,addr Send1,sizeof Send1,0</span><br><span class="line">.continue</span><br><span class="line">.endif</span><br><span class="line">.endw</span><br><span class="line"></span><br><span class="line">invoke closesocket,sock</span><br><span class="line">invoke WSACleanup</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
&lt;p&gt;熟练掌握Win32 API函数的参数传递,是软件逆向的基础,本章节内容将使用MASM汇编器,逐个编译这些源程序,你可以通过使用一些调试工具,这里推荐OllyDBG来附加编译后的可执行文件,进行逐个分析,观察二进制程序逆向后的一些变化,总结吸收经验,为以后的二进制逆向,漏洞挖掘打基础.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编其他指令(4)</title>
    <link href="https://localhost/2019/04/19/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4-4/"/>
    <id>https://localhost/2019/04/19/汇编与反汇编/Win32汇编其他指令-4/</id>
    <published>2019-04-19T02:09:50.000Z</published>
    <updated>2019-09-07T00:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><a id="more"></a><p><br></p><h2 id="字串操作指令"><a href="#字串操作指令" class="headerlink" title="字串操作指令"></a>字串操作指令</h2><p>移动串指令: MOVSB、MOVSW、MOVSD ;从 ESI -&gt; EDI; 执行后, ESI 与 EDI 的地址移动相应的单位<br>比较串指令: CMPSB、CMPSW、CMPSD ;比较 ESI、EDI; 执行后, ESI 与 EDI 的地址移动相应的单位<br>扫描串指令: SCASB、SCASW、SCASD ;依据 AL/AX/EAX 中的数据扫描 EDI 指向的数据, 执行后 EDI 自动变化<br>储存串指令: STOSB、STOSW、STOSD ;将 AL/AX/EAX 中的数据储存到 EDI 给出的地址, 执行后 EDI 自动变化<br>载入串指令: LODSB、LODSW、LODSD ;将 ESI 指向的数据载入到 AL/AX/EAX, 执行后 ESI 自动变化<br>其中的 B、W、D 分别指 Byte、Word、DWord, 表示每次操作的数据的大小单位.</p><p>上述指令可以有重复前缀:<br>REP             ECX &gt; 0 时<br>REPE (或 REPZ)  ECX &gt; 0 且 ZF=1 时<br>REPNE(或 REPNZ) ECX &gt; 0 且 ZF=0 时<br>;重复前缀可以自动按单位(1、2、4)递减 ECX</p><p><strong>字符串复制(movsb):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">string1 db &quot;hello lyshark&quot;,0      ; 原始字符串</span><br><span class="line">str_len equ $ - string1 -1        ; 计算出原始字符串长度</span><br><span class="line">string2 db str_len dup(?),0       ; 目标内存地址</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">cld                       ; 清除方向标志</span><br><span class="line">mov esi,offset string1    ; 取源字符串内存地址</span><br><span class="line">mov edi,offset string2    ; 取目标字符串内存地址</span><br><span class="line">mov ecx,str_len           ; 指定循环次数,为原字符串长度</span><br><span class="line">rep movsb                 ; 逐字节复制,直到ecx=0为止</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>另一种字串复制(movsb):</strong> 不使用rep重复前缀的方式完成字串复制.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">string1 db &quot;hello lyshark&quot;,0      ; 原始字符串</span><br><span class="line">str_len equ $ - string1 -1        ; 计算出原始字符串长度</span><br><span class="line">string2 db str_len dup(?),0       ; 目标内存地址</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,string1               ; 取string1的地址</span><br><span class="line">lea edi,string2               ; 取string2的地址</span><br><span class="line">mov ecx,str_len               ; 取字符串长度,用于循环</span><br><span class="line">cld                       ; 方向-&gt;正向</span><br><span class="line">@@:movsb                     ; 每次复制一个字节BYTE</span><br><span class="line">dec ecx                   ; 每次ecx减一</span><br><span class="line">jnz @B                    ; 如果ecx不为0则循环</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>(movsd)四字节复制字串:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ddSource DWORD 10h,20h,30h               ; 定义三个四字节数据</span><br><span class="line">ddDest   DWORD lengthof ddSource dup(?)  ; 得到目标地址</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,ddSource</span><br><span class="line">lea edi,ddDest</span><br><span class="line">mov ecx,lengthof ddSource</span><br><span class="line">cld</span><br><span class="line">rep movsd</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><hr><p><strong>CMPSB:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Text1 db &quot;hello lyshark&quot;,0</span><br><span class="line">Text2 db &quot;hello lyshar1&quot;,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,Text1</span><br><span class="line">lea edi,Text2</span><br><span class="line">mov ecx,lengthof Text1</span><br><span class="line">cld</span><br><span class="line">repe cmpsb</span><br><span class="line">je L1</span><br><span class="line">xor eax,eax            ; 字串不同则清空eax</span><br><span class="line">jmp L2</span><br><span class="line">L1:xor ebx,ebx            ; 字串相同则清空ebx</span><br><span class="line">L2:ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>CMPSD:</strong> 比对两个双字数据是否相等.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 DWORD 1234h</span><br><span class="line">var2 DWORD 5678h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,var1</span><br><span class="line">lea edi,var2</span><br><span class="line">cmpsd</span><br><span class="line">je L1</span><br><span class="line">xor eax,eax      ; 两数如果相等则清空eax</span><br><span class="line">jmp L2</span><br><span class="line">L1:xor ebx,ebx      ; 两数不相等则清空ebx</span><br><span class="line">L2:ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>CMPSW:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Array1 WORD 1,2,3,4,5      ; 必须全部相等才会清空ebx</span><br><span class="line">Array2 WORD 1,3,5,7,9</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,Array1</span><br><span class="line">lea edi,Array2</span><br><span class="line">mov ecx,lengthof Array1</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">repe cmpsw</span><br><span class="line">je L1</span><br><span class="line">xor eax,eax        ; 两数不相等则清空eax</span><br><span class="line">jmp L2</span><br><span class="line">L1:xor ebx,ebx        ; 两数相等则清空ebx</span><br><span class="line">L2:ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><hr><p><strong>SCASB 扫描字串:</strong> 依据 AL/AX/EAX 中的数据扫描 EDI 指向的数据, 执行后 EDI 自动变化<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szText BYTE &quot;ABCDEFGHIJK&quot;,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">lea edi,szText</span><br><span class="line">mov al,&quot;F&quot;</span><br><span class="line">mov ecx,lengthof szText -1</span><br><span class="line">cld</span><br><span class="line">repne scasb                 ; 如果不相等则重复</span><br><span class="line">je L1</span><br><span class="line">xor eax,eax                 ; 如果没找到F则清空eax</span><br><span class="line">jmp L2</span><br><span class="line">L1:sub ecx,lengthof szText -1</span><br><span class="line">neg ecx           ; 如果找得到, 这里显示是第几个字符; 本例结果是 6</span><br><span class="line">L2:ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>STOSB 存储字串:</strong> 将 AL/AX/EAX 中的数据储存到 EDI 给出的地址, 执行后 EDI 自动变化<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">len = 10</span><br><span class="line">szText db len dup(0),0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea edi,szText                   ; EDI指向字符串</span><br><span class="line">mov al,&quot;W&quot;                       ; 定义查找字母为W</span><br><span class="line">mov ecx,len                      ; 设置查找计数器</span><br><span class="line">cld                              ; 方向=正向</span><br><span class="line">rep stosb                        ; ecx&gt;0则执行</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LODSW 载入指令:</strong> 将 ESI 指向的数据载入到 AL/AX/EAX, 执行后 ESI 自动变化,如下是累加求和<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Array WORD 1,2,3,4,5,6,7,8,9,10</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea esi,Array</span><br><span class="line">mov ecx,lengthof Array</span><br><span class="line">xor edx,edx</span><br><span class="line">xor eax,eax</span><br><span class="line">@@:lodsw</span><br><span class="line">add edx,eax</span><br><span class="line">loop @B</span><br><span class="line"></span><br><span class="line">mov eax,edx           ; 最后将相加结果放入eax</span><br><span class="line"></span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><hr><p><strong>初始化内存:</strong> 把String字符串中的,每一个字节均填充初始化为0FFh<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Count = 100                 ; 申请空间为100</span><br><span class="line">String BYTE Count DUP(?)    ; 初始化为BYTE</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov al,0FFh             ; 指定要填充的数据为0FFh</span><br><span class="line">mov edi,offset String   ; EDI寄存器指向目标内存</span><br><span class="line">mov ecx,Count           ; 循环计数</span><br><span class="line">cld                     ; 初始化：方向=前方</span><br><span class="line">rep stosb               ; 以AL中的值进行填充</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>数组的乘法:</strong> 把双字数组中的每一个元素分别乘以一个常量,程序中使用了<code>(LODSD加载),(STOSD保存)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Array DWORD 1,2,3,4,5</span><br><span class="line">Multi DWORD 10</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset Array     ; 源指针</span><br><span class="line">mov edi,esi              ; 目的指针</span><br><span class="line"></span><br><span class="line">cld                      ; 方向=向前</span><br><span class="line">mov ecx,lengthof Array   ; 循环计数器</span><br><span class="line">L1:lodsd                    ; 加载[esi]至EAX</span><br><span class="line">mul Multi                ; 将EAX乘以10</span><br><span class="line">stosd                    ; 将结果从EAX存储至[EDI]</span><br><span class="line">loop L1</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>计算字符串长度:</strong> 以下代码用于计算字符串的长度,并将结果保存在EAX寄存器中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">String BYTE &quot;hello world&quot;,0      ; 带计算字符串</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov edi,offset String    ; 取出字符串的基地址</span><br><span class="line">xor eax,eax              ; 清空eax用作计数器</span><br><span class="line"></span><br><span class="line">L1:cmp byte ptr [edi],0     ; 分别那[edi]的值和0作比较</span><br><span class="line">je L2                    ; 上一步为零则跳转得到ret</span><br><span class="line">inc edi                  ; 否则继续执行</span><br><span class="line">inc eax</span><br><span class="line">jmp L1</span><br><span class="line">L2:ret</span><br><span class="line"></span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>小写字串转大写:</strong> 将MyString变量中的小写字符串,依次转换为大写字符串.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">MyString db &quot;hello lyshark&quot;,0      ; 定义MyString字符串</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset MyString        ; 取出字符串的偏移地址</span><br><span class="line">L1:cmp byte ptr [esi],0           ; 分别拿出每一个字节,与0比较</span><br><span class="line">je L2                          ; 如果相等则跳转到L2</span><br><span class="line">and byte ptr [esi],11011111b   ; 执行按位与操作</span><br><span class="line">inc esi                        ; 每次esi指针递增1</span><br><span class="line">jmp L1                         ; 重复循环</span><br><span class="line">L2:ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>定义二维数组:</strong> 定义一个二维数组Table,并取出第一行中的第2偏移地址的元素.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Table WORD 10h,20h,30h,40h,50h    ; 定义一个数组</span><br><span class="line">Row = ($ - Table)                 ; 取出数组每行的字节数</span><br><span class="line">      WORD 60h,70h,80h,90h,0Ah    ; 继续定义数组</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">row_index = 1                 ; 表的偏移地址</span><br><span class="line">column_index = 2              ; 行的偏移地址</span><br><span class="line"></span><br><span class="line">mov ebx,offset Table          ; 取偏移地址给ebx</span><br><span class="line">add ebx,Row*row_index         ; 每行元素*偏移</span><br><span class="line"></span><br><span class="line">mov esi,column_index          ; 将行偏移赋值给esi</span><br><span class="line">mov ax,[ebx+esi*TYPE Table]   ; Table比例因子只能是2,4,8</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="位操作指令"><a href="#位操作指令" class="headerlink" title="位操作指令"></a>位操作指令</h2><p><strong>符号扩展(CBW/CWDE):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov al,7fh</span><br><span class="line">cbw                 ; 将 AL 扩展为 AX</span><br><span class="line">PrintHex ax ;007F</span><br><span class="line">mov al,80h</span><br><span class="line">cbw</span><br><span class="line">PrintHex ax ;FF80</span><br><span class="line"></span><br><span class="line">mov ax,7fffh</span><br><span class="line">cwde                 ; 将 AX 扩展为 EAX</span><br><span class="line">PrintHex eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>符号扩展(CDQ/CWD):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,7FFFFFFFh</span><br><span class="line">cdq                      ; 将 EAX 扩展为 64 位数 EDX:EAX</span><br><span class="line">PrintHex edx ;00000000</span><br><span class="line">PrintHex eax ;7FFFFFFF</span><br><span class="line"></span><br><span class="line">mov ax, 7FFFh</span><br><span class="line">cwd                       ; 将 AX 扩展为 DX:AX</span><br><span class="line">PrintHex dx ;0000</span><br><span class="line">PrintHex ax ;7FFF</span><br><span class="line"></span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>BT、BTS、BTR、BTC: 位测试指令</strong></p><p>;BT(Bit Test):                 位测试<br>;BTS(Bit Test and Set):        位测试并置位<br>;BTR(Bit Test and Reset):      位测试并复位<br>;BTC(Bit Test and Complement): 位测试并取反</p><p>;它们的结果影响 CF<br>;它们的指令格式相同:<br>BT r16/r32/m16/m32, r16/r32/m16/m32<br>BT r16/r32/m16/m32, i8<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">    ;BT 把 10000001b 的第七位复制到 CF, 得知是 1</span><br><span class="line">    mov dx, 10000001b</span><br><span class="line">    bt  dx, 7</span><br><span class="line">    lahf</span><br><span class="line">    PrintHex ah ;47 - 01000111b (CF=1)</span><br><span class="line">    ;BT 把 10000001b 的第六位复制到 CF, 得知是 0</span><br><span class="line">    bt  dx, 6</span><br><span class="line">    lahf</span><br><span class="line">    PrintHex ah ;86 - 10000110b (CF=0)</span><br><span class="line">    </span><br><span class="line">    ;BTS 在执行 BT 命令的同时, 把操作数的指定位置为 1</span><br><span class="line">    mov dx, 10000001b</span><br><span class="line">    bts dx, 6</span><br><span class="line">    PrintHex dl ;C1 - 11000001b</span><br><span class="line">    </span><br><span class="line">    ;BTR 在执行 BT 命令的同时, 把操作数的指定位置为 0</span><br><span class="line">    mov dx, 10000001b</span><br><span class="line">    btr dx, 7</span><br><span class="line">    PrintHex dl ;01 - 00000001b</span><br><span class="line">    </span><br><span class="line">    ;BTC 在执行 BT 命令的同时, 把操作数的指定位取反</span><br><span class="line">    mov dx, 10000001b</span><br><span class="line">    btc dx, 0</span><br><span class="line">    PrintHex dl ;80 - 10000000b</span><br><span class="line">    btc dx, 0</span><br><span class="line">    PrintHex dl ;81 - 10000001b</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><strong>BSF、BSR: 位扫描指令</strong></p><p>;BSF(Bit Scan Forward): 位扫描, 低 -&gt; 高<br>;BSR(Bit Scan Reverse): 位扫描, 高 -&gt; 低</p><p>;它们的结果影响 ZF</p><p>;扫描的是参数二, 找到是 1 的位后, 把位置数给参数一并置 ZF=0<br>;找不到(也就是参数二是 0)时, 置 ZF=1</p><p>;它们的指令格式相同:<br>BSF r16/r32, r16/r32/m16/m32</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">    ;扫描到时</span><br><span class="line">    mov dx, 0000111100001100b</span><br><span class="line">    bsf cx, dx</span><br><span class="line">    PrintDec cx ;2  - 也就是左数第 3 位</span><br><span class="line">    </span><br><span class="line">    bsr cx, dx</span><br><span class="line">    PrintDec cx ;11 - 也就是左数第 12 位</span><br><span class="line">    </span><br><span class="line">    ;扫描不到时</span><br><span class="line">    mov cx, 0FFFFh</span><br><span class="line">    mov dx, 0</span><br><span class="line">    bsf cx, dx</span><br><span class="line">    lahf</span><br><span class="line">    PrintHex ah ;C6 - 11000110 (ZF=1)</span><br><span class="line">    PrintHex cx ;FFFF - 找不到时不会影响到目的值</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h2 id="其他测试指令"><a href="#其他测试指令" class="headerlink" title="其他测试指令"></a>其他测试指令</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编过程与宏(3)</title>
    <link href="https://localhost/2019/04/18/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%8F-3/"/>
    <id>https://localhost/2019/04/18/汇编与反汇编/Win32汇编过程与宏-3/</id>
    <published>2019-04-18T05:45:01.000Z</published>
    <updated>2019-09-07T00:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><a id="more"></a><p><br></p><h2 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h2><p>在计算机领域,堆栈是一个不容忽视的概念,堆栈是一种<code>后进先出(LIFO,Last-In,First-Out)</code>的数据结构,这是因为最后压入堆栈的值总是最先被取出,而新数值在执行PUSH压栈时总是被加到堆栈的最顶端,数据也总是从堆栈的最顶端被取出,堆栈是个<code>特殊的存储区</code>,主要功能是暂时存放数据和地址,通常用来保护断点和现场.</p><p>当程序运行时,栈是由CPU<code>直接管理</code>的<code>线性</code>内存数组,它使用两个寄存器<code>(SS和ESP)</code>来保存堆栈的状态.在保护模式下,SS寄存器存放<code>段选择符(Segment Selector)</code>运行在保护模式下的程序不能对其进行修改,而<code>ESP寄存器</code>的值通常是指向特定位置的一个<code>32位偏移值</code>,我们很少需要直接操作ESP寄存器,相反的ESP寄存器总是由<code>CALL,RET,PUSH,POP</code>等这类指令间接性的修改.</p><blockquote><p>接着来简单介绍下关于堆栈操作的两个寄存器,CPU系统提供了两个特殊的寄存器用于标识位于系统栈顶端的栈帧.<br>ESP 栈指针寄存器: 栈指针寄存器,其内存放着一个指针,该指针永远指向系统栈最上面一个栈帧的栈顶.<br>EBP 基址指针寄存器: 基址指针寄存器,其内存放着一个指针,该指针永远指向系统栈最上面一个栈帧的底部.</p></blockquote><h3 id="◆堆栈参数传递◆"><a href="#◆堆栈参数传递◆" class="headerlink" title="◆堆栈参数传递◆"></a>◆堆栈参数传递◆</h3><p>在通常情况下ESP是可变的,随着栈的生产而逐渐变小,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变.</p><blockquote><p>1.在32位系统中,执行<code>PUSH压栈</code>时,<code>堆栈指针自动减4</code>,再将压栈的值复制到堆栈指针所指向的内存地址.<br>2.在32位系统中,执行<code>POP出栈</code>时,从栈顶移走一个值并将其复制给内存或寄存器,然后再将<code>堆栈指针自动加4</code>.<br>3.在32位系统中,执行<code>CALL调用</code>时,CPU会用堆栈保存当前被调用过程的返回地址,直到遇到RET指令再将其弹出.</p></blockquote><p><strong>PUSH/POP指令:</strong> 在32位环境下,分别将数组中的元素<code>100h-300h</code>压入堆栈,并且通过POP将元素反弹出来.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Array DWORD 100h,200h,300h,400h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">xor eax,eax</span><br><span class="line">push eax                      ; push 0</span><br><span class="line">push DWORD PTR [Array]        ; push 100</span><br><span class="line">push DWORD PTR [Array+4]      ; push 200</span><br><span class="line">push DWORD PTR [Array+8]      ; push 300</span><br><span class="line">pop eax                       ; pop 300</span><br><span class="line">pop eax                       ; pop 200</span><br><span class="line">pop eax                       ; pop 100</span><br><span class="line">pop eax                       ; pop 0</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>PUSHFD/POPFD指令:</strong> PUSHFD在堆栈上压入EFLAGS寄存器的值,POPFD将堆栈的值弹出并送至EFLAGS寄存器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">SaveFlage DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">pushfd            ; 标识入栈</span><br><span class="line">pop SaveFlage     ; 弹出并保存到内存</span><br><span class="line"></span><br><span class="line">push SaveFlage    ; 从内存取出,并入栈</span><br><span class="line">popfd             ; 恢复到EFLAGS寄存器中</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>PUSHAD/POPAD指令:</strong> 将通用寄存器按照EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI的顺序压栈保存.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">pushad</span><br><span class="line">mov eax,1000</span><br><span class="line">mov ebx,2000</span><br><span class="line">mov ecx,3000</span><br><span class="line">mov edx,4000</span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆声明局部变量◆"><a href="#◆声明局部变量◆" class="headerlink" title="◆声明局部变量◆"></a>◆声明局部变量◆</h3><p>高级语言程序中,在单个过程中创建使用和销毁的变量我们称它为<code>局部变量(local variable)</code>,局部变量是在程序运行时,由系统动态的在栈上开辟的,在内存中通常在<code>基址指针(EBP)</code>之下,尽管在汇编时不能给定默认值,但可以在运行时初始化,如下一段伪代码:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySub</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> var1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> var2 = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的一段代码经过C编译器转换后,会变成如下的样子,其中<code>EBP-4</code>必须是4的倍数,因为默认就是4字节存储.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySub PROC</span><br><span class="line">push ebp                  ; 将EBP存储在栈中</span><br><span class="line">mov ebp,esp               ; 堆栈框架的基址</span><br><span class="line">sub esp,8                 ; 创建局部变量空间</span><br><span class="line"></span><br><span class="line">mov DWORD PTR [ebp-4],10  ; var1 = 10</span><br><span class="line">mov DWORD PTR [ebp-8],20  ; var2 = 20</span><br><span class="line"></span><br><span class="line">mov esp,ebp               ; 从堆栈上删除局部变量</span><br><span class="line">pop ebp                   ; 恢复EBP指针</span><br><span class="line">ret 8                     ; 返回,清理堆栈</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><p>如果去掉了上面的<code>mov esp,ebp</code>,那么当执行<code>pop ebp</code>时将会得到EBP等于10,执行RET指令会导致控制转移到内存地址10处执行,从而程序会崩溃.</p><p>为了使代码更加的容易阅读,可以在上面的代码的基础上给每个变量的引用地址都定义一个符号并在代码中使用这些符号来完成编写.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var1_local EQU DWORD PTR [ebp-4]</span><br><span class="line">var2_local EQU DWORD PTR [ebp-8]</span><br><span class="line"></span><br><span class="line">MySub PROC</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,8</span><br><span class="line">mov var1_local,10</span><br><span class="line">mov var2_local,20</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret 8</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><h3 id="◆ENTER-LEAVE-伪指令◆"><a href="#◆ENTER-LEAVE-伪指令◆" class="headerlink" title="◆ENTER/LEAVE 伪指令◆"></a>◆ENTER/LEAVE 伪指令◆</h3><p>ENTRE指令自动为被调用过程创建堆栈框架,它为局部变量保留堆栈空间并在堆栈上保存EBP,该指令执行后会执行以下动作.</p><blockquote><p>1.在堆栈上压入EBP(push ebp)<br>2.把EBP设为堆栈框架的基指针(mov ebp,esp)<br>3.为局部变量保留适当的空间(sub esp,numbytes)</p></blockquote><p>ENTER指令有两个参数,第一个操作数是一个常量,用于指定要为局部变量保留多少堆栈空间(numbytes),第二个参数指定过程的嵌套层数,这两个操作数都是立即数,numbytes总是向上取整为4的倍数,以使ESP按照双字边界地址对其.</p><p>比如以下代码,使用ENTER为局部变量保存8字节的堆栈空间:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySub PROC</span><br><span class="line">enter 8,0</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><p>经过编译器转换后,会首先转换为以下的样子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySub PROC</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,8</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><p>上面的代码只有开头没有结尾,如果要使用ENTER指令分配空间的话,则必须在结尾加上LEAVE指令,这样程序才完整.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySub PROC</span><br><span class="line">enter 8,0</span><br><span class="line">....</span><br><span class="line">leave</span><br><span class="line">ret</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><p>下面代码和上面代码作用是相同的,它首先为局部变量保留8字节的堆栈空间然后丢弃.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySub PROC</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,8</span><br><span class="line">....</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br><span class="line">MySub ENDP</span><br></pre></td></tr></table></figure></p><h3 id="◆USES-LOCAL-伪指令◆"><a href="#◆USES-LOCAL-伪指令◆" class="headerlink" title="◆USES/LOCAL 伪指令◆"></a>◆USES/LOCAL 伪指令◆</h3><p><strong>USES操作符:</strong> 该操作符用于指定需要压栈的寄存器,其会自动生成压栈出栈代码无需手动添加.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,1</span><br><span class="line">mov ebx,2</span><br><span class="line">mov ecx,3</span><br><span class="line">call mycall</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line"></span><br><span class="line">mycall PROC USES eax ebx ecx     ; 生成压栈代码,自动压eax,ebx,ecx</span><br><span class="line">xor eax,eax              ; 压栈的寄存器可以随意修改</span><br><span class="line">xor ebx,ebx              ; 过程结束后会自动恢复这些寄存器</span><br><span class="line">ret</span><br><span class="line">mycall ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LOCAL操作符:</strong> 在过程内声明一个或多个命名局部变量,并赋予相应的尺寸属性,该语句必须紧跟PROC指令后面.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">LOCAL var1:WORD</span><br><span class="line">LOCAL var2:DWORD,var3:BYTE</span><br><span class="line"></span><br><span class="line">mov DWORD PTR [var1],1024</span><br><span class="line">mov eax,DWORD PTR [var1]</span><br><span class="line">mov [var2],1024            ; DWORD</span><br><span class="line">mov eax,[var2]</span><br><span class="line">mov [var3],10              ; BYTE</span><br><span class="line">mov al,[var3]</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>局部变量:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">lyshark PROC var1:WORD,var2:DWORD</span><br><span class="line">LOCAL @loca1:BYTE,@loca2:DWORD</span><br><span class="line">LOCAL @local_byte[100]:BYTE</span><br><span class="line"></span><br><span class="line">mov ax,var1</span><br><span class="line">mov ebx,@loca2</span><br><span class="line"></span><br><span class="line">lea ecx,@local_byte</span><br><span class="line">mov @local_byte[0],0</span><br><span class="line">mov @local_byte[1],1</span><br><span class="line">mov @local_byte[2],2</span><br><span class="line">mov @local_byte[3],3</span><br><span class="line">lyshark ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">invoke lyshark,100,10000</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LOCAL(申请数组):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">LOCAL var[3]:DWORD</span><br><span class="line"></span><br><span class="line">mov var[0],100</span><br><span class="line">mov var[1],200</span><br><span class="line"></span><br><span class="line">mov eax,var[0]</span><br><span class="line">mov ebx,var[1]</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">LOCAL ArrayDW[10]:DWORD</span><br><span class="line">LOCAL ArrayB[10]:BYTE</span><br><span class="line"></span><br><span class="line">lea eax,[ArrayDW]</span><br><span class="line">mov [ArrayDW],10</span><br><span class="line">mov [ArrayDW + 4],20</span><br><span class="line">mov [ArrayDW + 8],30</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p><br></p><h2 id="过程调用指令"><a href="#过程调用指令" class="headerlink" title="过程调用指令"></a>过程调用指令</h2><p>CALL指令指示处理器在新的内存地址执行指令,当用户调用CALL指令时,该指令会首先将CALL指令的下一条指令的内存地址压入堆栈保存,然后将EIP寄存器修改为CALL指令的调用处,等调用结束后返回从堆栈弹出CALL的下一条指令地址.</p><blockquote><p>1.当遇到CALL指令时,程序会经过计算得到CALL指令的下一条指令的地址,并将其压入堆栈.<br>2.接着会将EIP寄存器的地址指向被调用过程的地址,被调用过程被执行.<br>3.最后过程内部通过RET指令返回,将从堆栈中弹出EIP的地址,程序继续向下执行.<br>4.CALL相当于push+jmp,RET相当于pop+jmp.</p></blockquote><p><strong>普通参数传递:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">sum PROC var1:DWORD,var2:DWORD,var3:DWORD</span><br><span class="line">mov eax,var1</span><br><span class="line">mov ebx,var2</span><br><span class="line">mov ecx,var3</span><br><span class="line">ret</span><br><span class="line">sum ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">invoke sum,10,20,30      ; 调用并传递参数</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>寄存器传递参数:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">sum PROC</span><br><span class="line">add eax,ebx</span><br><span class="line">add eax,ecx</span><br><span class="line">ret</span><br><span class="line">sum ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">mov eax,10</span><br><span class="line">mov ebx,20</span><br><span class="line">mov ecx,30</span><br><span class="line">call sum</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>使用PROTO声明:</strong> 如果调用的函数在之后实现, 须用 PROTO 提前声明,否则会报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum PROTO :DWORD,:DWORD,:DWORD ; 函数声明的主要是参数类型,省略参数名</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke sum,10,20,30    ; 现在调用的是之后的函数</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line"></span><br><span class="line">sum PROC var1,var2,var3</span><br><span class="line">mov eax,var1</span><br><span class="line">add eax,var2</span><br><span class="line">add eax,var3</span><br><span class="line">ret</span><br><span class="line">sum ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>CALL/RET指令:</strong> 编写一个过程,实现对整数数组的求和,并将结果保存到EAX寄存器中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array DWORD 1000h,2000h,3000h,4000h,5000h</span><br><span class="line">theSum DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset array          ; ESI指向array</span><br><span class="line">mov ecx,lengthof array        ; ECX=array元素个数</span><br><span class="line">call ArraySum                 ; 调用求和指令</span><br><span class="line">mov theSum,eax                ; 将结果保存到内存</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line"></span><br><span class="line">ArraySum PROC</span><br><span class="line">push esi           ; 保存ESI,ECX</span><br><span class="line">push ecx</span><br><span class="line">mov eax,0          ; 初始化累加寄存器</span><br><span class="line">L1:</span><br><span class="line">add eax,[esi]      ; 每个整数都和EAX中的和相加</span><br><span class="line">add esi,TYPE DWORD ; 递增指针,继续遍历</span><br><span class="line">loop L1</span><br><span class="line">pop ecx            ; 恢复寄存器</span><br><span class="line">pop esi</span><br><span class="line">ret</span><br><span class="line">ArraySum ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p>通过该语句块配合可以生成自定义过程,下面我们创建一个名为<code>Sum</code>的过程,实现<code>EBX+ECX</code>并将结果保存在<code>EAX</code>寄存器中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">TheSum DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov ebx,100     ; 传递ebx</span><br><span class="line">mov ecx,100     ; 传递ecx</span><br><span class="line">call Sum        ; 调用过程</span><br><span class="line">mov TheSum,eax  ; 保存结果到TheSum</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line"></span><br><span class="line">Sum PROC</span><br><span class="line">xor eax,eax</span><br><span class="line">add eax,ebx</span><br><span class="line">add eax,ecx</span><br><span class="line">ret</span><br><span class="line">Sum ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>INVOKE调用系统API:</strong> 默认情况下,会将返回结果保存在eax寄存器中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">szCaption db &quot;MsgBox&quot;,0</span><br><span class="line">szText db &quot;这是一个提示框,请点击确定完成交互！&quot;,0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">.WHILE (1)</span><br><span class="line">invoke MessageBox,NULL,offset szText,offset szCaption,MB_YESNO</span><br><span class="line">.break .if(eax == IDYES)</span><br><span class="line">.ENDW</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>模块化调用:</strong> 首先创建一个<code>sum.asm</code>然后在<code>main.asm</code>中引用sum这个文件中的函数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; sum.asm 首先编译这个文件,并将其放入指定目录下</span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.code</span><br><span class="line">sum PROC v1, v2, v3</span><br><span class="line">    mov eax, v1</span><br><span class="line">    add eax, v2</span><br><span class="line">    add eax, v3</span><br><span class="line">    ret</span><br><span class="line">sum ENDP</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; main.asm 直接引用编译后的lib文件即可</span><br><span class="line">;这里的引入路径可以是全路径, 这里是相对路径</span><br><span class="line">includelib /masm32/lib/sum.lib</span><br><span class="line"></span><br><span class="line">;子程序声明</span><br><span class="line">sum proto :dword, :dword, :dword</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke sum,10,20,30    ;调用过程</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><p><br></p><h2 id="结构与联合"><a href="#结构与联合" class="headerlink" title="结构与联合"></a>结构与联合</h2><p>结构(struct)时逻辑上互相关联的一组变量的模板或模式,结构中的单个变量称为<code>域(field)</code>,程序的语句可以把结构作为一个实体进行访问,也可以对结构的单个域进行访问,结构通常包括不同类型的域,而联合(union)同样也是把多个标识符组合在一起,不过与结构不同的是,联合体共用用一块内存区域,内存的大小取决于联合体中最大的元素.</p><p><strong>引用结构变量:</strong> 通过使用<code>&lt;&gt;,{}</code>均可声明结构体,同时可以初始化,对结构体赋初值.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;定义结构</span><br><span class="line">MyPoint struct</span><br><span class="line">pos_x DWORD ?</span><br><span class="line">pos_y DWORD ?</span><br><span class="line">MyPoint ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">;声明结构, 使用 &lt;&gt;、&#123;&#125; 均可</span><br><span class="line">ptr1 MyPoint &lt;10,20&gt;</span><br><span class="line">ptr2 MyPoint &#123;30,40&#125;</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea edx, ptr1</span><br><span class="line">mov eax, (MyPoint ptr [edx]).pos_x   ; 此时eax=10</span><br><span class="line">mov ebx, (MyPoint ptr [edx]).pos_y   ; 此时ebx=20</span><br><span class="line">mov (MyPoint PTR [edx]).pos_x,100    ; 将100写入MyPoint.pos_x结构中存储</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>结构初始化:</strong> 以下定义了<code>MyStruct</code>结构,并将<code>user2</code>初始化,FName=lyshark,FAge=25.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyStruct struct</span><br><span class="line">FName db 20 dup(0)</span><br><span class="line">FAge db 100</span><br><span class="line">MyStruct ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">user1 MyStruct &lt;&gt;</span><br><span class="line">user2 MyStruct &lt;&apos;lyshark&apos;,25&gt;</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">;lea edx, user1</span><br><span class="line">;mov eax,DWORD PTR (MyStruct ptr[edx]).FName</span><br><span class="line">;mov ebx,DWORD PTR (MyStruct ptr[edx]).FAge</span><br><span class="line"></span><br><span class="line">mov eax,DWORD PTR [user2.FName]   ; eax=lyshark</span><br><span class="line">mov ebx,DWORD PTR [user2.FAge]    ; ebx=25</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>使用系统结构:</strong> 通过调用<code>GetLocalTime</code>获取系统时间,并存储到<code>SYSTEMTIM</code>结构体中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">sysTime SYSTEMTIME &lt;&gt;           ; 声明结构体</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetLocalTime,addr sysTime    ; 获取系统时间并放入sysTime</span><br><span class="line">mov eax,DWORD PTR sysTime.wYear     ; 获取年份</span><br><span class="line">mov ebx,DWORD PTR sysTime.wMonth    ; 获取月份</span><br><span class="line">mov ecx,DWORD PTR sysTime.wDay      ; 获取天数</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>结构体的嵌套定义:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyPT struct</span><br><span class="line">pt_x DWORD ?</span><br><span class="line">pt_y DWORD ?</span><br><span class="line">MyPT ends</span><br><span class="line">Rect struct</span><br><span class="line">Left MyPT &lt;&gt;</span><br><span class="line">Right MyPT &lt;&gt;</span><br><span class="line">Rect ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">LyShark1 Rect &lt;&gt;</span><br><span class="line">LyShark2 Rect &#123;&lt;10,20&gt;,&lt;100,200&gt;&#125;</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov [LyShark1.Left.pt_x],100</span><br><span class="line">mov [LyShark1.Left.pt_y],200</span><br><span class="line"></span><br><span class="line">mov [LyShark1.Right.pt_x],1000</span><br><span class="line">mov [LyShark1.Right.pt_y],2000</span><br><span class="line">mov eax,[LyShark1.Left.pt_x]</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>联合体的声明:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 定义联合体</span><br><span class="line">MyUnion union</span><br><span class="line">My_Dword DWORD ?</span><br><span class="line">My_Word WORD ?</span><br><span class="line">My_Byte BYTE ?</span><br><span class="line">MyUnion ends</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">test1 MyUnion &#123;1122h&#125;; ;只能存放初始值</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax, [test1.My_Dword]</span><br><span class="line">mov ax, [test1.My_Word]</span><br><span class="line">mov al, [test1.My_Byte]</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="关于宏汇编"><a href="#关于宏汇编" class="headerlink" title="关于宏汇编"></a>关于宏汇编</h2><p>宏过程<code>(Macro Procedure)</code>是一个命名的语汇编语句块,一旦定义后,宏过程就可以在程序中被调用任意多次,调用宏过程的时候,宏内的语句块将替换到调用的位置,宏的本质是替换,但像极了子过程,宏可定义在源程序的任意位置,但一般放在.data前面.</p><p><strong>一个简单的宏:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyCode macro</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MyCode   ; 将被替换为上面两行代码</span><br><span class="line">ret    </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>一个代替求和函数的宏</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySum macro  var1, var2, var3</span><br><span class="line">mov eax,var1</span><br><span class="line">add eax,var2</span><br><span class="line">add eax,var3</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MySum 10,20,30</span><br><span class="line">MySum 10,20,30,40   ; 多余的参数40会被忽略</span><br><span class="line">ret    </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>宏参数的默认值:</strong> 通过定义默认值,可以不给默认的变量传递参数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 参数 var1、var2 通过 REQ 标识说明是必备参数</span><br><span class="line">MySum macro  var1:req, var2:req, var3:=&lt;30&gt;    ; var3默认值是30</span><br><span class="line">mov eax,var1</span><br><span class="line">add eax,var2</span><br><span class="line">add eax,var3</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MySum 10,20</span><br><span class="line">ret    </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>使用EXITM终止宏执行:</strong> 可使用关键字exitm 终止宏代码的后面内容.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySum macro</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">exitm        ; 只会清空前三个寄存器,后面的跳过了</span><br><span class="line">xor edx,edx</span><br><span class="line">xor esi,esi</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MySum</span><br><span class="line">ret    </span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>使用PURGE取消指定宏的展开:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySum macro</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MySum           ; 这个会被展开</span><br><span class="line">purge MySum     ; 这个不会展开</span><br><span class="line">MySum           ; 这个宏也不会展开了</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>在宏内使用局部标号:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyMax macro var1,var2</span><br><span class="line">LOCAL jump</span><br><span class="line"></span><br><span class="line">mov eax,var1</span><br><span class="line">cmp eax,var2</span><br><span class="line">jge jump</span><br><span class="line">xor eax,eax</span><br><span class="line">jump:ret</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">MyMax 20,10</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>特殊操作符: &amp;、&lt;&gt;、%、!</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;  ;替换操作符</span><br><span class="line">&lt;&gt; ;字符串传递操作符</span><br><span class="line">%  ;表达式操作符, 也用于得到一个变量或常量的值</span><br><span class="line">!  ;转义操作符</span><br><span class="line">;自定义的宏</span><br><span class="line">mPrint macro Text</span><br><span class="line">    PrintText &apos;* &amp;Text&amp; *&apos;</span><br><span class="line">endm</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">    ;该宏会把参数直接替换过去</span><br><span class="line">    mPrint 1234    ;* 1234 *</span><br><span class="line">    </span><br><span class="line">    ;要保证参数的完整应该使用 &lt;&gt;</span><br><span class="line">    mPrint 12,34   ;* 12 *</span><br><span class="line">    mPrint &lt;12,34&gt; ;* 12,34 *</span><br><span class="line">    </span><br><span class="line">    ;需要计算结果应该使用 %()</span><br><span class="line">    mPrint 34+12   ;* 34+12 *</span><br><span class="line">    mPrint %(34+12)   ;* 46 *</span><br><span class="line">    </span><br><span class="line">    ;用到 &amp;、&lt;、&gt;、%、! 应该使用 ! 转义</span><br><span class="line">    mPrint 10 !% 2 = %(10/2)!! ;* 10 % 2 = 5! *</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="过程小例子"><a href="#过程小例子" class="headerlink" title="过程小例子"></a>过程小例子</h2><p><strong>整数求和:</strong> 通过使用汇编语言实现一个整数求和的小例子.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">String WORD 100h,200h,300h,400h,500h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">;lea edi,String           ; 取String数组的基址</span><br><span class="line">mov edi,offset String     ; 同上,两种方式均可</span><br><span class="line">mov ecx,lengthof String   ; 取数组中的数据个数</span><br><span class="line">mov ax,0                  ; 累加器清零</span><br><span class="line">L1:</span><br><span class="line">add ax,[edi]              ; 加上一个整数</span><br><span class="line">add edi,TYPE String       ; 指向下一个数组元素,type(2byte)</span><br><span class="line">loop L1</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>正向复制字符串:</strong> 使用汇编语言实现字符串的复制,将数据从<code>source</code>复制到<code>target</code>内存中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">source BYTE &quot;hello lyshark welcome&quot;,0h</span><br><span class="line">target BYTE SIZEOF source DUP(0),0h       ; 取源地址数据大小</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,0                  ; 使用变址寄存器</span><br><span class="line">mov ecx,sizeof source      ; 循环计数器</span><br><span class="line">L1:</span><br><span class="line">mov al,source[esi]         ; 从源地址中取一个字符</span><br><span class="line">mov target[esi],al         ; 将该字符存储在目标地址中</span><br><span class="line">inc esi                    ; 递增,将指针移动到下一个字符</span><br><span class="line">loop L1</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>反向复制字符串:</strong> 使用汇编语言实现字符串的复制,将数据从<code>source</code>复制到<code>target</code>内存中且反向存储数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">source BYTE &quot;hello lyshark welcome&quot;,0h</span><br><span class="line">target BYTE SIZEOF source DUP(0),0h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,sizeof source</span><br><span class="line">mov ecx,sizeof source</span><br><span class="line">mov ebx,0</span><br><span class="line">L1:</span><br><span class="line">mov al,source[esi]</span><br><span class="line">mov target[ebx],al</span><br><span class="line">dec esi</span><br><span class="line">inc ebx</span><br><span class="line">loop L1</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>查看内存与寄存器:</strong> 通过调用<code>DumpMem/DumpRegs</code>显示内存与寄存器的快照.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">array DWORD 1,2,3,4,5,6,7,8,9,0ah,0bh</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset array       ; 设置内存起始地址</span><br><span class="line">mov ecx,lengthof array     ; 设置元素数据,偏移</span><br><span class="line">mov ebx,type array         ; 设置元素尺寸(1=byte,2=word,4=dword)</span><br><span class="line">call DumpMem               ; 调用内存查询子过程</span><br><span class="line">call DumpRegs              ; 调用查询寄存器子过程</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>汇编实现性能度量:</strong> 通过调用库函数,实现对指定代码执行的性能度量.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">StartTime DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">call GetMseconds       ; 调用区本地时间过程</span><br><span class="line">mov StartTime,eax      ; 将返回值赋值给StartTime</span><br><span class="line"></span><br><span class="line">mov ecx,10             ; 通过调用延时过程,模拟程序的执行</span><br><span class="line">L1:</span><br><span class="line">mov eax,1000           ; 指定延时1s=1000ms</span><br><span class="line">call Delay             ; 调用延时过程</span><br><span class="line">loop L1</span><br><span class="line"></span><br><span class="line">call GetMseconds       ; 再次调用本地时间过程</span><br><span class="line">sub eax,StartTime      ; 结束时间减去开始时间</span><br><span class="line">call WriteDec          ; 以十进制形式输出eax寄存器的值</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>字符输出:</strong> <code>WriteString(字符串)</code>,<code>WriteInt(整数)</code>,<code>WriteHex(16进制)</code>,<code>WriteChar(字符)</code>,<code>WriteDec(10进制)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Message BYTE &quot;Input String:&quot;,0h</span><br><span class="line">String DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 设置控制台背景颜色</span><br><span class="line">mov eax,yellow +(blue*16)     ; 设置为蓝底黄字</span><br><span class="line">call SetTextColor             ; 调用设置过程</span><br><span class="line">call Clrscr                   ; 清除屏幕,clear</span><br><span class="line"></span><br><span class="line">; 提示用户一段话</span><br><span class="line">mov edx,offset Message        ; 指定输出的文字</span><br><span class="line">call WriteString              ; 调用回写过程</span><br><span class="line">call Crlf                     ; 调用回车</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>字符输入:</strong> <code>ReadString(字符串)</code>,<code>ReadInt(整数)</code>,<code>ReadHex(16进制)</code>,<code>ReadChar(字符)</code>,<code>ReadDec(10进制)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Buffer BYTE 21 DUP(0)          ; 输入缓冲区</span><br><span class="line">ByteCount DWORD ?              ; 存放计数器      </span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov edx,offset Buffer      ; 指向缓冲区指针</span><br><span class="line">mov ecx,sizeof Buffer      ; 指定最多读取的字符数</span><br><span class="line">call ReadString            ; 读取输入字符串</span><br><span class="line">mov ByteCount,eax          ; 保存读取的字符数</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>生成伪随机数:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov ecx,5           ; 循环生成5个随机数</span><br><span class="line">L1:</span><br><span class="line">call Random32       ; 生成随机数</span><br><span class="line">call WriteDec       ; 以十进制显示</span><br><span class="line">mov al,TAB          ; 水平制表符</span><br><span class="line">call WriteChar      ; 显示水平制表符</span><br><span class="line">loop L1</span><br><span class="line">call Crlf           ; 回车</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>生成自定义随机数:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov ecx,5           ; 循环生成5个随机数</span><br><span class="line">L1:</span><br><span class="line">mov eax,100         ; 0-99之间</span><br><span class="line">call RandomRange    ; 生成随机数</span><br><span class="line">sub eax,50          ; 范围在-50-49</span><br><span class="line">call WriteInt       ; 十进制输出</span><br><span class="line">mov al,TAB</span><br><span class="line">call WriteChar      ; 输出制表符</span><br><span class="line">loop L1</span><br><span class="line">call Crlf           ; 回车</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编算数指令(2)</title>
    <link href="https://localhost/2019/04/18/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97-2/"/>
    <id>https://localhost/2019/04/18/汇编与反汇编/Win32汇编算数运算-2/</id>
    <published>2019-04-18T05:42:43.000Z</published>
    <updated>2019-09-07T00:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><a id="more"></a><p><br></p><h2 id="移位相关指令"><a href="#移位相关指令" class="headerlink" title="移位相关指令"></a>移位相关指令</h2><p>每种汇编语言都有进行操作数移位的指令,移位和循环移位指令在控制硬件设备,加密数据,以及实现高速图形运算时特别有用,移位指令也是汇编语言中最具特征的指令集,<code>移位(Shifting)</code>的含义是在操作数内向左或向右移动数据位,Intel处理器提供了多种移位指令,具体如下表所示:</p><table><thead><tr><th style="text-align:left">指令集</th><th style="text-align:left">含义</th><th style="text-align:left">指令集</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHL</td><td style="text-align:left">逻辑左移(无符号数)</td><td style="text-align:left">SHR</td><td style="text-align:left">逻辑右移(无符号数)</td></tr><tr><td style="text-align:left">SAL</td><td style="text-align:left">算数左移(有符号数)</td><td style="text-align:left">SAR</td><td style="text-align:left">算数右移(有符号数)</td></tr><tr><td style="text-align:left">ROL</td><td style="text-align:left">循环左移(无符号数)</td><td style="text-align:left">ROR</td><td style="text-align:left">循环右移(无符号数)</td></tr><tr><td style="text-align:left">RCL</td><td style="text-align:left">循环左移(带进位的)</td><td style="text-align:left">RCR</td><td style="text-align:left">循环右移(带进位的)</td></tr><tr><td style="text-align:left">SHLD</td><td style="text-align:left">双精度左移(无符号)</td><td style="text-align:left">SHRD</td><td style="text-align:left">双精度右移(无符号)</td></tr></tbody></table><h3 id="◆SHL-SHR-逻辑移位◆"><a href="#◆SHL-SHR-逻辑移位◆" class="headerlink" title="◆SHL/SHR 逻辑移位◆"></a>◆SHL/SHR 逻辑移位◆</h3><p><strong>SHL指令:</strong> 对目标操作数执行<code>逻辑左移(针对无符号数)</code>操作,其左移后<code>最低位</code>以<code>0填充</code>,而移动出去的最高位则会送入<code>CF(进位标志)</code>中,原来的进位标志位中的值将被覆盖.</p><p>Intel处理器中定义,执行移位的源操作数的范围必须在<code>0-255</code>之间,在任何处理器上都可以使用<code>CL寄存器</code>存放移位位数,例如在下面的指令中,<code>AL寄存器</code>被左移一位,最高位被复制到了进位标志中,最低位被清零:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01251006 | B3 8F                | mov al,10001111b                            | AL = 10001111b</span><br><span class="line">01251008 | D0E3                 | shl al,1                                    | CF = 1,AL = 00011110b</span><br><span class="line"></span><br><span class="line">01251006 | B0 01                | mov al,10000000b                            | AL = 10000000b</span><br><span class="line">01251008 | C0E0 02              | shl al,2                                    | CF = 0,AL = 00000000b</span><br><span class="line"></span><br><span class="line">01251006 | B0 01                | mov al,10000000b                            | AL = 10000000b</span><br><span class="line">01251008 | C0E0 01              | shl al,1                                    | CF = 1,AL = 00000000b</span><br><span class="line"></span><br><span class="line">01251006 | B0 01                | mov al,10100000b                            | AL = 10100000b</span><br><span class="line">01251008 | C0E0 03              | shl al,2                                    | CF = 0,AL = 10000000b</span><br></pre></td></tr></table></figure></p><p>另外使用SHL指令还可以进行<code>2的次幂</code>的高速乘法运算,任何操作数左移动N位,就相当于乘以2的N次方,如下例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01311002 | B0 05                | mov al,5                                    | AL 左移动1位</span><br><span class="line">01311004 | D0E0                 | shl al,1                                    | al*2=10</span><br><span class="line"></span><br><span class="line">01311007 | B0 05                | mov al,5                                    | AL左移2位</span><br><span class="line">01311009 | C0E0 02              | shl al,2                                    | al*4=20</span><br><span class="line"></span><br><span class="line">01311007 | B0 05                | mov al,5                                    | AL左移3位</span><br><span class="line">01311009 | C0E0 03              | shl al,3                                    | al*8=40</span><br></pre></td></tr></table></figure></p><p><strong>SHR指令:</strong> 对目标操作数执行<code>逻辑右移(针对无符号数)</code>操作,移出的数据位用0代替,最低位被复制到<code>CF进位标志</code>中,原来的进位标志位丢失.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0131100D | B0 01                | mov al,10001111b                            | AL = 10001111b</span><br><span class="line">0131100F | D0E8                 | shr al,1                                    | CF = 1,AL = 01000111b</span><br><span class="line"></span><br><span class="line">0131100D | B0 01                | mov al,10001111b                            | AL = 10001111b</span><br><span class="line">0131100F | D0E8                 | shr al,2                                    | CF = 1,AL = 00100011b</span><br></pre></td></tr></table></figure></p><p>另外任何无符号操作数逻辑右移N位,就相当于该操作数<code>除以2的N次方</code>,如下例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01311012 | B2 20                | mov dl,20                                   | DL 右移1位 </span><br><span class="line">01311014 | D0EA                 | shr dl,1                                    | dl/2 = 10</span><br><span class="line"></span><br><span class="line">01311012 | B2 20                | mov dl,20                                   | DL 右移2位 </span><br><span class="line">01311014 | D0EA                 | shr dl,2                                    | dl/4 = 5</span><br></pre></td></tr></table></figure></p><h3 id="◆SAL-SAR-算数移位◆"><a href="#◆SAL-SAR-算数移位◆" class="headerlink" title="◆SAL/SAR 算数移位◆"></a>◆SAL/SAR 算数移位◆</h3><p>SAL指令与SHL指令等价,SAR指令对目标操作数执行算数右移操作,SAR/SHR指令与SHL/SHR指令格式相同,移位动作可以根据第二个操作数中的计数进行重复.</p><h3 id="◆ROL-ROR-循环移位◆"><a href="#◆ROL-ROR-循环移位◆" class="headerlink" title="◆ROL/ROR 循环移位◆"></a>◆ROL/ROR 循环移位◆</h3><p>RCL/RCR</p><p>SHALD/SHRD</p><h2 id="乘法-除法指令"><a href="#乘法-除法指令" class="headerlink" title="乘法/除法指令"></a>乘法/除法指令</h2><p>MUL和IMUL指令分别进行有符号整数和无符号整数的乘法操作,<code>MUL(无符号乘法)</code>指令有三种格式.</p><p><strong>8位乘法:</strong> 计算<code>AL寄存器</code>和<code>BL寄存器</code>相乘,积数默认放在AX寄存器中,进位标志CF清零,因为AH高位等于零.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00111002  | B0 05                    | mov al,5                                 | al = 5</span><br><span class="line">00111004  | B3 10                    | mov bl,10                                | bl = 10</span><br><span class="line">00111006  | F6E3                     | mul bl                                   | AX=50,CF=0</span><br></pre></td></tr></table></figure></p><p><strong>16位乘法:</strong> 将16操作数2000h和100h相乘,乘积高位在DX中,低位在AX中.CF=1因为乘机高半部分DX=0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0008100F  | 66:B8 0020               | mov ax,2000                              | ax=2000</span><br><span class="line">00081013  | 66:BB 0001               | mov bx,100                               | bx=100</span><br><span class="line">00081017  | 66:F7E3                  | mul bx                                   | ax*bx</span><br></pre></td></tr></table></figure></p><p><strong>32位乘法:</strong> 将32操作数12345h和1000h相乘,得到64位乘积,其高位在EDX中,低位在EAX中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0008101B  | B8 45230100              | mov eax,12345                            |</span><br><span class="line">00081020  | BB 00100000              | mov ebx,1000                             |</span><br><span class="line">00081025  | F7E3                     | mul ebx                                  |</span><br></pre></td></tr></table></figure></p><h2 id="扩展加法-减法"><a href="#扩展加法-减法" class="headerlink" title="扩展加法/减法"></a>扩展加法/减法</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Win32汇编语言基础(1)</title>
    <link href="https://localhost/2019/04/12/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/Win32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-1/"/>
    <id>https://localhost/2019/04/12/汇编与反汇编/Win32汇编语言基础-1/</id>
    <published>2019-04-12T10:38:26.000Z</published>
    <updated>2019-09-07T00:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.</p><p>该系列笔记,记录了Win32汇编的常用语法规则,有些汇编代码并没有返回任何参数,如需观察,请编译后使用OllyDBG附加进程,单步跟踪调试,该笔记是为二进制软件逆向打基础的,故简化的很多项目开发章节的内容,如果你需要使用汇编开发项目(当然那样很麻烦),你可以参考<code>《Intel 汇编语言程序设计》,《琢石成器-Win32汇编语言程序设计》</code>,当然本笔记的所有内容也是来自于这两本书的实例,不过简化了大量繁琐的文字描述,只保留了比较实用的内容.</p><a id="more"></a><p>汇编语言一直被认为是最难学的语言,其原因主要是因为汇编程序员在着眼于程序<code>逻辑实现</code>的同时还要注重其他<code>底层细节</code>,这些在学习高级语言可以不必涉及到的底层工作细节,在学习汇编语言中,便成了家常便饭,使用汇编编程,要求程序员具有对底层的清晰认识,学习汇编能够更好的<code>理解操作系统</code>的运作原理,从而帮助构建底层知识体系.</p><p>汇编语言是所有程序设计语言中<code>最古老</code>的,它与计算机<code>机器语言</code>最为接近,通过汇编语言可以<code>直接访问计算机的硬件</code>,能够直接与CPU对话,可以说汇编语言是所有编程语言中语法格式<code>最自由</code>的,但自由的代价就是需要了解计算机体系结构和操作系统的大量细节,每编写一段程序都需要考虑各种硬件的状态,从而导致使用汇编写程序<code>效率非常低</code>.<br><br></p><h2 id="微机体系概述"><a href="#微机体系概述" class="headerlink" title="微机体系概述"></a>微机体系概述</h2><blockquote><p>在学习汇编语言之前,我们必须要了解一下处理器的发展历史.</p></blockquote><p>自1946年第一台计算机问世以来,在短短的60多年中,已经历了由<code>电子管计算机(1946年),晶体管计算机(1956年),集成电路计算机(1958年),超大规模集成电路计算机(1972年)</code>,这五代的更替,而且还在不断地向巨型化,微型化,网络化,智能化这四个方向不断发展.</p><p>从当今的X86架构的CPU说起,<code>X86指令集</code>是Intel为其第一块<code>16位CPU(80x86)</code>专门开发的,IBM公司1981年推出的世界第一台PC机中的CPU—<code>i8088(i8086简化版)</code>使用的也是X86指令,同时电脑中为提高<code>浮点数据处理</code>能力而增加的<code>X87芯片</code>系列协处理器则另外使用X87指令,为了提高处理器性能,就将X86指令集和X87指令集统称为X86指令集.</p><p>虽然随着CPU技术的不断发展,Intel公司陆续研制出更新型的<code>i80386、i80486、Pentium</code>直到今天,但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源,所以Intel公司所生产的所有CPU仍然继续使用X86指令集,所以它的CPU仍属于<code>X86系列</code>,由于X86系列及其兼容CPU都使用X86指令集,所以就形成了今天庞大的X86系列及兼容CPU阵容.</p><blockquote><p>谈完了处理器的基本发展过程,再来了解一下CPU指令集的分类吧.</p></blockquote><p>处理器分为两大架构阵营,即<code>RISC(精简指令集计算机)</code>和<code>CISC(复杂指令集计算机)</code>是当前CPU的两种架构,它们的区别在于不同的CPU设计理念和方法,CPU架构是厂商给属于同一系列的CPU产品定的一个规范,主要目的是为了区分不同类型CPU的重要标示.</p><p>早期的CPU全部是<code>CISC架构</code>,它的设计目的是要用最少的机器语言指令来完成所需的计算任务.比如对于乘法运算,在CISC架构的CPU上,您可能只需要一条指令就可以得到相应的结果,这些幕后的操作全部依赖于CPU中设计的逻辑电路来完成,这种架构会<code>增加</code>CPU结构的<code>复杂性</code>和对CPU制作工艺的要求,但对于编译器的开发却十分有利.</p><p>相比CISC架构的系统,<code>RISC架构</code>则要求软件来指定各个操作步骤,上面的乘法运算如果要在RISC架构上实现,则你需要具体指定其特定的实现步骤,使用这种架构生产CPU,可以很大程度上降低CPU的复杂性以及允许在同样的工艺水平下生产出功能更强大的CPU,但对于编译器的设计有更高的要求.</p><p>总结:当精简指令集出现后,所有人都说复杂指令集已经过时,英特尔密切关注,为了谨慎.英特尔同时开发复杂指令集CPU和精简指令集CPU.精简指令处理器上市后,复杂指令集CPU依旧热销.而精简指令集CPU因为无法兼容以前的软件,而销售量不好.英特尔得出复杂指令集生命依旧强大的结论,放弃在精简指令集方面的开发工作.</p><blockquote><p>机器语言汇编语言和高级语言的区别 —-&gt; (机器语言创作了汇编)-&gt;(汇编创作了C,C撑起了整个计算机世界)</p></blockquote><p><code>机器语言(machinelanguage)</code>是一种指令集的体系,这种指令集被称为<code>机器码(machinecode)</code>,它是电脑的CPU可<code>直接解读</code>的数据,机器码有时也被称为<code>原生码(NativeCode)</code>,它与系统运行平台相关联,机器语言是计算机的设计者通过计算机的硬件结构赋予计算机的操作功能,早期的机器语言程序员在编写程序时只需要使用两种符号<code>0或1</code>,这种编程方式太枯燥,并且需要记忆大量的0101这种二进制格式的排布方式,实在是一件很痛苦的事,就是在这种环境下汇编语言诞生了.</p><p><code>汇编语言(assembly language)</code>是一种用于电子计算机、微处理器、微控制器或其他可编程器件的<code>低级语言</code>,亦称为符号语言,是机器语言的<code>符号化</code>,也就是说以往我们需要记忆大量的0101二进制,而现在则只需要记忆相应的符号,比如<code>mov eax,1</code>移动指令,人们很容易理解他的含义,尽管如此,操作汇编语言还是需要了解操作系统的大量底层实现,其在应对大型应用的开发上还是不够简单.</p><p><code>高级语言(High-level programming language)</code>相对于汇编语言,它是较接近自然语言和数学公式的编程,基本脱离了机器的硬件系统,能够用人们更易理解的方式编写程序,高级语言高度封装了底层实现细节,其语法格式自然,简单易用,屏蔽了很多底层细节的实现,开发效率明显提高,这给人们能够开发出大型应用系统提供了可能性.</p><p>总结:机器语言与汇编语言的关系属于一脉相承,指令是一对一的关系,这也给软件逆向提供了一种可能,而高级语言和汇编的关系属于一对多的关系,高级语言的一条代码,可能对应机器语言的数十条,甚至数百条.</p><p>直到现在,CPU处理器也只能识别两种电位格式0或1,计算机不理解高级语言,我们必须通过编译器转成二进制代码才能运行<code>(c/c++,java...)</code>,只学会高级语言,并不等于理解计算机实际的运行步骤.</p><hr><blockquote><p>80x86处理器的几种基本工作模式</p></blockquote><p>IA-32处理器有三种基本的工作模式:<code>实地址模式</code>,<code>系统管理模式</code>,<code>保护模式</code>,另外还有一种模式称为<code>虚拟80x86模式</code>,其实虚拟x86模式也是保护模式的一个特例,下面个将分别简要描述这几种系统模式:</p><p><strong>实地址模式:</strong> 在该模式下,IA-32处理器使用20位地址线,可以访问<code>1048576(1MB)</code>字节的内存,其地址范围是<code>0-FFFFF</code>,但8086处理器的寄存器是16位的不能存放20位的地址,为了解决这个棘手的问题提出了一种称为<code>分段内存</code>的概念,所有内存被分为了多个64kb的区域,这些区域称为<code>段(segment)</code>,我们使用<code>段地址x16+偏移地址=绝对地址</code>来计算出绝对地址.</p><p><strong>保护模式:</strong> 在该模式下,每个程序可寻址4GB的内存,地址范围是<code>0-FFFFFFFF</code>,在该模式下编程无需进行复杂的公式计算,只需要使用一个32位整数就可以存放任何指令和变量的地址,处理器会在后台进行地址的计算和转换,这些工作对于汇编程序员变得透明了起来,保护模式下有三个段:<code>CS:代码段</code>,<code>DS:数据段</code>,<code>SS:堆栈段</code>,其他的段操作系统负责维护.</p><p><strong>虚拟x86模式:</strong> 在该模式下,实际上是处理器在保护模式下创建的一个具有1MB地址空间的虚拟机,虚拟机对运行于实地址模式下的<code>80x86计算机</code>进行了模拟,在<code>Windows NT</code>系统下,打开一个控制台窗口,就创建了一个8086虚拟机,当然你也可同时打开多个控制台,他们之间是隔离的并不互相影响.</p><p><strong>平坦分段模式:</strong> 在该模式下,所有段都被映射到32位的物理地址空间中,一个程序至少需要2个段:<code>代码段(CS,数据段(DS)</code>,每个段都由一个段描述符定义,段描述符通常是一个存放在<code>全局描述符表(GDT)</code>中的一个64位地址.</p><p><strong>内存分页机制:</strong> IA-32处理器支持一种称为<code>分页(paging)</code>的特性,允许一个段被分割成称为<code>页(page)</code>的4096字节的内存块,分页机制允许同时运行的程序使用总内存远大于计算机的物理内存,操作系统映射的所有页的集合称为<code>虚拟内存</code>,操作系统通常都会包含一个虚拟内存管理器的程序,分页机制会使人产生内存无限大的错觉,然而程序如果过度依赖于分页的话,其运行效率会非常低下.</p><hr><blockquote><p>CPU内部的寄存器组,以及每个寄存器的作用</p></blockquote><p>寄存器是CPU内部的高速存储单元,由于是固化在CPU内部的组件,其访问速度快于内存,在当下的处理器中寄存器分为几种类型,其中8个通用寄存器<code>(EAX,EBX,ECX,EDX,EBP,ESP,ESI,EDI)</code>,6个段寄存器<code>(CS,SS,DS,ES,FS,GS)</code>,一个处理器状态标志寄存器<code>(EFLAGS)</code>,和一个指令指针寄存器<code>(EIP)</code>寄存器.</p><p><strong>通用寄存器:</strong> CPU内部有<code>8个通用寄存器</code>主要用于算数运算和数据的传送,这8个寄存器都可以作为一个32位的值或两个16位的值来寻址使用,还可以按照8位寄存器来使用,比如通用寄存器都可以被拆分为高低寄存器来存储数据,例如:<code>EAX寄存器</code>,可被拆分为<code>(AX)16位</code>寄存器来使用,而<code>(AX)16位</code>寄存器还可拆分为<code>AH/AL(高低8位)</code>.</p><p><strong>变址寄存器:</strong> CPU内部有2个通用寄存器<code>ESI和EDI</code>,寄存器ESI、EDI称为<code>变址寄存器(Index Register)</code>,它们主要用于存放存储单元在段内的偏移量,用它可实现多种存储器操作数的寻址方式,为以不同的地址形式访问存储单元提供方便.变址寄存器<code>不可分割</code>成8位寄存器,在字符串操作指令的执行过程中,对它们有特定的要求,而且还具有特殊的功能,该寄存器默认和<code>DS数据段</code>寄存器相关联.</p><p><strong>堆栈指针寄存器:</strong> CPU内部有2个通用寄存器<code>EBP和ESP</code>,寄存器EBP、ESP称为<code>指针寄存器(Pointer Register)</code>,主要用于<code>存放堆栈</code>内存储单元的偏移量,它们主要用于访问堆栈内的存储单元并且规定,<code>EBP为基址指针寄存器</code>,<code>ESP为堆栈指针寄存器</code>,指针寄存器<code>不可分割</code>成8位寄存器,该寄存器默认和<code>SS堆栈段</code>寄存器相关联.</p><p><strong>指令指针寄存器:</strong> CPU内部有1个指令指针寄存器<code>EIP</code>,该寄存器存放下一条要执行的指令的地址,下次要执行的指令通常已被预取到指令队列中,除非发生转移情况,所以在理解它们的功能时,不考虑存在指令队列的情况,默认情况下EIP不可手动修改,一般都是由特殊的指令<code>CALL,RET,PUSH</code>等间接性的修改.</p><p><strong>段寄存器:</strong> 段寄存器是根据内存分段的管理模式而设置的,内存单元的物理地址由段寄存器的值和一个偏移量组合而成的,这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址,常规段寄存器包括<code>CS:代码段寄存器</code>,<code>DS:数据段寄存器</code>,<code>SS:堆栈段寄存器</code>,<code>ES:附加数据段寄存器</code>这些寄存器通常是由编译器或这是操作系统来维护的.</p><p><strong>标志寄存器:</strong> 标志寄存器(EFLAGS),该寄存器用来控制CPU的操作流程,或者反应CPU某些运算的结果的独立二进制位构成,常用的标志位包括<code>CF(进位标志),ZF(零标志),PF(奇偶标志)</code>等.</p><hr><blockquote><p>手动编译一段小程序</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.386p</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">MyDef equ 1024         ; 将数值指定名称</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">Main WORD 1024      ; 定义可赋值的变量</span><br><span class="line">.data?                  ; 定义未知初始变量</span><br><span class="line">lyshark DWORD ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">xor eax,eax</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\lyshark&gt; ml /c /coff lyshark.asm</span><br><span class="line">C:\Users\lyshark&gt; link /subsystem:windows lyshark.obj</span><br></pre></td></tr></table></figure><p><br></p><h2 id="数据段的定义"><a href="#数据段的定义" class="headerlink" title="数据段的定义"></a>数据段的定义</h2><p>MASM 定义了多种内部数据类型,每种数据类型都描述了该类型的变量和表达式的取值集合,汇编语言中数据类型的基本特征是以数据位数为度量单位:<code>8,16,32,48,64,80位</code>,而除此之外其他的特征如<code>(符号,指针,浮点数)</code>主要是为了方便我们记忆变量中存储的数据类型.</p><p>接下来看下表,表中是IEEE委员会发布的标准内部数据类型:</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">作用(无符号)</th><th style="text-align:left">数据类型</th><th style="text-align:left">作用(有符号)</th></tr></thead><tbody><tr><td style="text-align:left">BYTE</td><td style="text-align:left">8位无符号整数</td><td style="text-align:left">SBYTE</td><td style="text-align:left">8位有符号整数</td></tr><tr><td style="text-align:left">WORD</td><td style="text-align:left">16位无符号整数</td><td style="text-align:left">SWORD</td><td style="text-align:left">16位有符号整数</td></tr><tr><td style="text-align:left">DWORD</td><td style="text-align:left">32位无符号整数</td><td style="text-align:left">SWORD</td><td style="text-align:left">32位有符号整数</td></tr><tr><td style="text-align:left">FWORD</td><td style="text-align:left">48位整数(远指针)</td><td style="text-align:left">QWORD</td><td style="text-align:left">64位整数定义</td></tr><tr><td style="text-align:left">REAL4</td><td style="text-align:left">32位(4字节)短实数</td><td style="text-align:left">REAL8</td><td style="text-align:left">64位(8字节)长实数</td></tr></tbody></table><p>数据类型定义语句为变量在内存中保留存储空间,并且可以选择为变量指定一个名字,在汇编语言中所有的数据无非就是<code>BYTE</code>的集合,数据的定义语句格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[变量名] 数据定义伪指令 初始值[....]</span><br></pre></td></tr></table></figure></p><p>在数据定义语句中使用<code>BYTE(定义字节)</code>和<code>SBYTE(定义有符号字节)</code>伪指令,可以为每一个或多个有符号或无符号字节分配存储空间,每个<code>初始值必须是8位整数</code>表达式或字符常量,例如下面的定义:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 BYTE &apos;A&apos;      ; 定义字符常量</span><br><span class="line">var2 BYTE ?        ; 定义未初始化变量</span><br><span class="line">var3 BYTE 0        ; 最小的无符号字节常量</span><br><span class="line">var4 BYTE 255      ; 最大的无符号字节常量</span><br><span class="line">var5 SBYTE -128    ; 最小的有符号字节常量</span><br><span class="line">var6 SBYTE +127    ; 最大的有符号字节常量</span><br></pre></td></tr></table></figure></p><p>如果一条数据定义语句中有多个初始值,那么标号仅仅代表第一个初始值的偏移,如下我们首先定义一个BYTE数组,然后通过反汇编查看地址的偏移变化就能看到效果啦:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">list BYTE 10,20,30,40,50</span><br><span class="line"></span><br><span class="line">00E71000 | B8 0030E700        | mov eax,main.E73000                 | E73000=10</span><br><span class="line">00E71005 | B8 0130E700        | mov eax,main.E73001                 | E73001=20</span><br><span class="line">00E7100A | B8 0230E700        | mov eax,main.E73002                 | E73002=30</span><br><span class="line">00E7100F | B8 0330E700        | mov eax,main.E73003                 | E73003=40</span><br><span class="line">00E71014 | B8 0430E700        | mov eax,main.E73004                 | E73004=50</span><br></pre></td></tr></table></figure></p><p>并非所有的数据定义都需要标号,如果想继续定义以list开始的字节数组,可以在随后的行上接着上面的定义:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">list BYTE 10,20,30,40,50</span><br><span class="line">list BYTE 60,70,80,90,100</span><br></pre></td></tr></table></figure></p><p>当然除了定义整数字符以外,还可以定义字符串,要想定义字符串应将一组字符用单引号或双引号括起来.最常见的字符串是以空格结尾<code>0h</code>,在C/C++,JAVA中定义字符串无需添加结尾0h,这是因为编译器会在编译的时候自动的在字符串后面填充了0h,在汇编语言中我们需要手动添加字符串结尾的标志:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">string1 BYTE &quot;hello lyshark&quot;,0h</span><br><span class="line">string2 BYTE &quot;good night&quot;,0h</span><br><span class="line"></span><br><span class="line">00F23000  68 65 6C 6C 6F 20 6C 79 73 68 61 72 6B 00 67 6F hello lyshark.go </span><br><span class="line">00F23010  6F 64 20 6E 69 67 68 74 00 00 00 00 00 00 00 00 od night........</span><br></pre></td></tr></table></figure></p><p>字符串也可以占用多行,而无须为每行都提供一个编号,如下代码也是合法的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">string1 BYTE &quot;welcom to the Demo program&quot;</span><br><span class="line">BYTE &quot;created by lyshark&quot;,0dh,0ah,</span><br><span class="line">BYTE &quot;url:lyshark&quot;</span><br><span class="line">BYTE &quot;send me a copy&quot;,0dh,0ah,0</span><br></pre></td></tr></table></figure></p><p>十六进制<code>0dh,0ah</code>也称为<code>CR/LF(回车换行符)</code>,或者是行结束的字符,在向标准输出设备上写的时候,回车换行符可以将光标移动到下一行的开头位置,从而继续填充新的字符串.</p><p>有时我们需要初始化一些空值的内存空间,在为内存地址分配空间的时候,DUP伪指令就显得尤为重要,初始化和未初始化数据均可使用DUP指令定义,其定义语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">string1 BYTE 20 DUP(0)       ; 分配20字节,全部填充0</span><br><span class="line">BYTE 20 DUP(?)       ; 分配20字节,且未初始化</span><br><span class="line">BYTE 50 DUP(&quot;stack&quot;) ; 分配50字节,&quot;stackstack...&quot;</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">smallArray DOWRD 10 DUP(0) ; 分配40字节</span><br><span class="line">bigArray DOWOR 5000 DUP(?) ; 分配20000字节</span><br></pre></td></tr></table></figure></p><p>除了上面的例子以外,我们也可以直接定义常量,常量是不可以动态修改的数据类型,一般情况下一旦定义,那么在程序运行期间不可以被修改,常量的定义很简单,只需要将<code>.data</code>换成<code>.const</code>即可.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.const</span><br><span class="line">var1 BYTE  &quot;hello world&quot;,0h   ; 初始化为BYTE的字符串</span><br><span class="line">var2 DWORD 10                 ; 初始化为10的DWORD类型</span><br><span class="line">var3 DWORD 100 dup(1,2)       ; 200个DWORD的缓冲区</span><br><span class="line">var4 BYTE  1024 dup(?)        ; 1024字节的缓冲区</span><br><span class="line">var5 BYTE &quot;welcome&quot;,0dh,0ah,0 ; 0dh,0ah为换行符</span><br></pre></td></tr></table></figure></p><p>有时我们需要计算数组的大小,但手动计算显得特别麻烦,此时我们可以使用MASM提供的$符号来进行数组大小的计算过程,如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">list BYTE 10,20,30,40,50</span><br><span class="line">listsize = ($ - list)       ; 计算字节数据大小</span><br><span class="line">.data</span><br><span class="line">list WORD 1000h,2000h,3000h,4000h</span><br><span class="line">listsize = ($ - list) /2    ; 计算字数据大小</span><br><span class="line">.data</span><br><span class="line">list DWORD 100000h,200000h,300000h,400000h</span><br><span class="line">listsize = ($ - list) /4    ; 计算双字数据大小</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Post_1 equ 1000</span><br><span class="line">Post_2 equ 2000</span><br><span class="line">Post_3 equ 3000</span><br></pre></td></tr></table></figure><p><br></p><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p><strong>StdIn/StdOut:</strong> 使用<code>masm32.inc</code>提供的函数实现标准的输入与输出.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line"></span><br><span class="line">include masm32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib masm32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">len equ 20</span><br><span class="line">OutText dw ?</span><br><span class="line">ShowText db <span class="string">"请输入一个数: "</span>,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke StdOut, addr ShowText    ; 输出提示信息</span><br><span class="line">invoke StdIn, addr OutText,len  ; 等待用户的输入</span><br><span class="line">invoke StdOut, addr OutText     ; 输出刚才输入的内容</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>WriteFile:</strong> 通过调用系统的API函数,来实现具体的输出,其过程比较复杂不推荐使用.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">.data</span><br><span class="line">szText db <span class="string">"hello lyshark!"</span>,0</span><br><span class="line">.data?</span><br><span class="line">hOut dd ?     ; 保存句柄</span><br><span class="line">hLen dd ?     ; 保存字符长度</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">invoke GetStdHandle,STD_OUTPUT_HANDLE     ; 获取设备控制台句柄</span><br><span class="line">mov hOut,eax                              ; 把获取到的句柄给hOut</span><br><span class="line">invoke lstrlen,addr szText                ; 取出字符串的长度</span><br><span class="line">mov hLen,eax</span><br><span class="line">invoke WriteFile,hOut,addr szText,hLen,0,0 ;具体的输出</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>crt_printf:</strong> 使用微软C标准库中的printf函数; msvscrt.inc 把它声明做 crt_printf<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line"></span><br><span class="line">include msvcrt.inc</span><br><span class="line">includelib msvcrt.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">PrintText db <span class="string">"EAX=%d;EBX=%d;EDX=%d | InPut -&gt;: "</span>,0</span><br><span class="line">ScanFomat db <span class="string">"%s"</span>,0</span><br><span class="line">PrintTemp db ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,10</span><br><span class="line">mov ebx,20</span><br><span class="line">mov ecx,30</span><br><span class="line">invoke crt_printf,addr PrintText,eax,ebx,ecx        ; 打印提示内容</span><br><span class="line">invoke crt_scanf, addr ScanFomat, addr PrintTemp    ; 输入内容并接收参数</span><br><span class="line">invoke crt_printf, addr PrintTemp                   ; 输出输入的内容</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><p><strong>MOV指令:</strong> 从源操作数向目标操作数之间复制数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00A41000 | B8 24100000        | mov eax,1024                        |</span><br><span class="line">00A41005 | 8BD8               | mov ebx,eax                         |</span><br><span class="line">00A41007 | 66:B9 0010         | mov cx,1000                         |</span><br></pre></td></tr></table></figure></p><p><strong>MOVZX指令:</strong> 零扩展传送,该指令将源操作数的内容复制到目标操作数中,并将该值<code>零扩展(zero-extend)</code>至16位或者32位,该指令适用于<code>无符号整数</code>,其基本格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01301000 | 66:BB 9BA6         | mov bx,A69B                         | BX = 0A69B</span><br><span class="line">01301004 | 0FB7C3             | movzx eax,bx                        | EAX = 0000A69B</span><br><span class="line">01301007 | 0FB6D3             | movzx edx,bl                        | EDX = 0000009B</span><br><span class="line">0130100A | 66:0FB6CB          | movzx cx,bl                         | CX = 009B</span><br></pre></td></tr></table></figure></p><p><strong>MOVSX指令:</strong> 符号扩展传送,该指令将源操作数的内容复制到目标操作数中,并将该值<code>符号扩展(sign-extend)</code>至16位或者是32位,该指令只能用于<code>有符号整数</code>,其基本格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00FD1000 | 66:BB 9BA6         | mov bx,A69B                         | BX = 0A69B</span><br><span class="line">00FD1004 | 0FBFC3             | movsx eax,bx                        | EAX = FFFFA69B</span><br><span class="line">00FD1007 | 0FBED3             | movsx edx,bl                        | EDX = FFFFFF0B</span><br><span class="line">00FD100A | 66:0FBECB          | movsx cx,bl                         | CX = FF9B</span><br></pre></td></tr></table></figure></p><p><strong>XCHG指令:</strong> 数据交换指令,该指令用于交换两个操作数中的内容,但该指令不接受立即数操作数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00D71000 | B8 00100000        | mov eax,1000                        | EAX = 1000h</span><br><span class="line">00D71005 | BB 00200000        | mov ebx,2000                        | EBX = 2000h</span><br><span class="line">00D7100A | 93                 | xchg ebx,eax                        | EAX = 2000h;EBX = 1000h</span><br></pre></td></tr></table></figure></p><p><strong>INC/DEC指令:</strong> 数据递增与递减,<code>INC指令</code>用于对寄存器或内存数据的递增,<code>DEC指令</code>用于对寄存器或内存数据递减.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00881000 | B8 00100000        | mov eax,1000                        | EAX = 1000h</span><br><span class="line">00881005 | 40                 | inc eax                             | EAX = 1001h</span><br><span class="line">00881006 | 40                 | inc eax                             | EAX = 1002h</span><br><span class="line">00881007 | BB 00200000        | mov ebx,2000                        | EBX = 2000h</span><br><span class="line">0088100C | 4B                 | dec ebx                             | EBX = 1FFFF</span><br><span class="line">0088100D | 4B                 | dec ebx                             | EBX = 1FFFE</span><br><span class="line">0088100E | 4B                 | dec ebx                             | EBX = 1FFFD</span><br></pre></td></tr></table></figure></p><p><strong>ADD指令:</strong> 操作数增加,该指令用于将<code>源操作数和目的操作数相加</code>,且不影响源操作数的值,而是改变目的操作数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00BC1000 | B8 00100000        | mov eax,1000                        | EAX = 1000</span><br><span class="line">00BC1005 | BB 00200000        | mov ebx,2000                        | EBX = 2000</span><br><span class="line">00BC100A | 03D8               | add ebx,eax                         | EBX = EBX+EAX = 3000</span><br></pre></td></tr></table></figure></p><p><strong>SUB指令:</strong> 操作数减少,该指令用于将<code>源操作数和目的操作数相减</code>,且不影响源操作数的值,而是改变目的操作数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00811000 | B8 00200000        | mov eax,2000                        | EAX = 2000</span><br><span class="line">00811005 | BB 00100000        | mov ebx,1000                        | EBX = 1000</span><br><span class="line">0081100A | 2BC3               | sub eax,ebx                         | EAX = EAX-EBX = 1000</span><br></pre></td></tr></table></figure></p><p><strong>AND/OR/XOR指令:</strong> 逻辑与/逻辑或/逻辑异或.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00DD100E | B8 01000000        | mov eax,1                              |</span><br><span class="line">00DD1013 | BB 01000000        | mov ebx,1                              |</span><br><span class="line">00DD1018 | B9 00000000        | mov ecx,0                              |</span><br><span class="line">00DD101D | 21D8               | and eax,ebx                            |</span><br><span class="line">00DD101F | 09CB               | or ebx,ecx                             |</span><br><span class="line">00DD1021 | 31C0               | xor eax,eax                            |</span><br></pre></td></tr></table></figure></p><p><strong>OFFSET操作符:</strong> 返回数据标号的偏移地址,偏移地址代表标号距数据基址的距离,单位是字节.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 BYTE ?</span><br><span class="line">var2 WORD ?</span><br><span class="line">var3 DWORD ?</span><br><span class="line">var4 DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset var1</span><br><span class="line">mov esi,offset var2</span><br><span class="line">mov esi,offset var3</span><br><span class="line">mov esi,offset var4</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>PTR操作符:</strong> 用来重载声明操作数的默认尺寸,这在试图以不同与变量声明时所使用的尺寸来访问变量时很有用.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">temp DWORD 12345678h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,DWORD PTR [temp]  ; 将temp以双字取值并存储到eax</span><br><span class="line">mov ax,WORD PTR [temp]    ; 将temp以字为单位取值并存储到ax</span><br><span class="line">mov bx,WORD PTR [temp+2]  ; 在偏移基础上+2</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br><span class="line"></span><br><span class="line">00C11000 | A1 0030C100        | mov eax,dword ptr ds:[C13000]       | EAX = 12345678</span><br><span class="line">00C11005 | 66:A1 0030C100     | mov ax,word ptr ds:[C13000]         | AX = 5678</span><br><span class="line">00C1100B | 66:8B1D 0230C100   | mov bx,word ptr ds:[C13002]         | BX = 1234</span><br></pre></td></tr></table></figure></p><p><strong>LENGTHOF操作符:</strong> 计算数组元素的数目,元素由出现在的同一行的值定义.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayDW DWORD 1000,2000,3000,4000,5000,6000,7000,8000,9000,0h</span><br><span class="line">ArrayBT BYTE 1,2,3,4,5,6,7,8,9,0h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">mov eax,lengthof ArrayDW</span><br><span class="line">mov eax,lengthof ArrayBT</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>TYPE操作符:</strong> 返回按照字节计算的单个元素的大小.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 BYTE ?</span><br><span class="line">var2 WORD ?</span><br><span class="line">var3 DWORD ?</span><br><span class="line">var4 QWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,TYPE var1       ; 1</span><br><span class="line">mov ebx,TYPE var2       ; 2</span><br><span class="line">mov ecx,TYPE var3       ; 4</span><br><span class="line">mov edx,TYPE var4       ; 8</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>SIZEOF操作符:</strong> 返回等于<code>LENGTHOF(总元素数)和TYPE(每个元素占用字节)</code>返回值的乘基.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">var1 WORD 32 DUP(0)        ; 32*2</span><br><span class="line">var2 BYTE 10,20,30,40      ; 3</span><br><span class="line">var3 WORD 30 DUP(?),0,0    ; 30+2</span><br><span class="line">var4 DWORD 1,2,3,4         ; 4</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,SIZEOF var1</span><br><span class="line">mov eax,SIZEOF var2</span><br><span class="line">mov eax,SIZEOF var3</span><br><span class="line">mov eax,SIZEOF var4</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LOOP循环(普通循环):</strong> 该指令检测<code>ECX</code>寄存器的变化,每次循环寄存器<code>自动减1</code>,当<code>ECX=0</code>循环结束,否则继续循环.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov ecx,10      ; 计数循环寄存器初始化为10</span><br><span class="line">top:                    ; 循环标号,编译器会将其转换成一个地址</span><br><span class="line">xor eax,eax</span><br><span class="line">mov eax,ecx</span><br><span class="line">loop top        ; loop跳转到指定地址,此处为top</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LOOP循环(循环中使用ECX):</strong> 如果用光了所有的通用寄存器,但又必须要使用ECX的话,可以在循环开始将ECX保存.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">count DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">mov ecx,10</span><br><span class="line">top:</span><br><span class="line">mov count,ecx       ; 将ecx寄存器放入count变量</span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov ecx,1000        ; 重置ecx寄存器的数值</span><br><span class="line">add eax,ecx</span><br><span class="line"></span><br><span class="line">mov ecx,count       ; 处理完成后,恢复ECX寄存器</span><br><span class="line">loop top            ; 继续循环</span><br><span class="line"></span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>LOOP循环(嵌套循环):</strong> 在循环内部创建另一个循环的时候,必须考虑外层ECX中的外层循环计数该如何处理,把外层循环计数保存在内存中,是非常的理想的.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">count DWORD ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">mov ecx,10        ; 设置外层循环计数</span><br><span class="line">L1:</span><br><span class="line">mov count,ecx     ; 保存外层循环计数</span><br><span class="line">mov ecx,20    ; 设置内层循环计数</span><br><span class="line">L2:</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor edx,edx</span><br><span class="line">loop L2      ; 重复内层循环计数</span><br><span class="line"></span><br><span class="line">mov ecx,count    ; 恢复外层循环计数器</span><br><span class="line">loop L1          ; 执行外层循环跳转</span><br><span class="line">push 0</span><br><span class="line">call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>IF-ENDIF(伪指令):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,100</span><br><span class="line">mov ebx,200</span><br><span class="line">.IF (eax == ebx) &amp;&amp; (ebx == ebx)</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">.ELSEIF (eax &gt;= 100) || (ebx == ebx)</span><br><span class="line">add eax,100</span><br><span class="line">add ebx,100</span><br><span class="line">.ENDIF</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>WHILE-ENDW(伪指令):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Count DWORD 10</span><br><span class="line">SumNum DWORD 0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">xor eax,eax</span><br><span class="line">.WHILE (eax &lt; Count)</span><br><span class="line">add SumNum,1</span><br><span class="line">inc eax</span><br><span class="line">.ENDW</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>REPEAT-UNTIL(伪指令):</strong> 以下代码利用循环伪指令,完成了1-10相加.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Count DWORD 10</span><br><span class="line">SumNum DWORD 0</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">xor eax,eax</span><br><span class="line">.REPEAT</span><br><span class="line">inc eax</span><br><span class="line">add SumNum,1</span><br><span class="line">.UNTIL (eax &gt;= Count)</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>BREAK(伪指令):</strong> 以下是个死循环,当eax寄存器的值等于5时,则执行.break结束程序的运行.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,10</span><br><span class="line">.while (1)</span><br><span class="line">dec eax</span><br><span class="line">.break .if(eax == 5)</span><br><span class="line">.endw</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>CONTINUE(伪指令):</strong> 当EAX的值小于等于5时执行continue,否则执行<code>inc ebx</code>,总循环数为10.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,0</span><br><span class="line">mov ebx,0</span><br><span class="line">.repeat</span><br><span class="line">inc eax</span><br><span class="line">.continue .if(eax &lt;= 5)</span><br><span class="line">inc ebx</span><br><span class="line">.until (eax &gt;= 10)</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>FOR 字符替换(伪指令):</strong> 该伪指令并不是循环,而是分别将指定的指令批量的替换到程序中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">for num,&lt;1,2,3&gt;</span><br><span class="line">xor eax,eax</span><br><span class="line">add eax,DWORD PTR [num]</span><br><span class="line">endm</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>FORC字串替换(伪指令):</strong> 该伪指令并不是循环,而是分别将指定的字串批量的替换到程序中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">forc code,&lt;@#$%^&amp;*()&lt;&gt;&gt;</span><br><span class="line">BYTE &quot;&amp;code&quot;</span><br><span class="line">endm</span><br><span class="line">ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="内存寻址方式"><a href="#内存寻址方式" class="headerlink" title="内存寻址方式"></a>内存寻址方式</h2><p>Windows系统默认运行于保护模式下,当处理器运行于保护模式下时,每个程序可以寻址4GB的内存范围,地址范围是从十六进制数的<code>0-FFFFFFFF</code>,微软汇编器的平坦模式,适用于保护模式编程,在平坦模式下其内存寻址的方式包括,<code>直接寻址</code>,<code>间接寻址</code>,<code>基址变址寻址</code>,<code>比例因子寻址</code>等,接下来将分别来演示.</p><h3 id="◆直接寻址◆"><a href="#◆直接寻址◆" class="headerlink" title="◆直接寻址◆"></a>◆直接寻址◆</h3><p>在声明变量名称的后面加上一个偏移地址,可以创建<code>直接偏移(direct-offset)</code>操作数,可以通过它来访问没有显示标号的内存地址,接下来看一个实验例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayB BYTE 10h,20h,30h,40h,50h</span><br><span class="line">ArrayW WORD 100h,200h,300h,400h</span><br><span class="line">ArrayDW DWORD 1h,2h,3h,4h</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">; 针对字节的寻址操作</span><br><span class="line">mov al,[ArrayB]           ; al=10</span><br><span class="line">mov al,[ArrayB+1]         ; al=20</span><br><span class="line">mov al,[ArrayB+2]         ; al=30</span><br><span class="line">; 针对内存单元字存储操作</span><br><span class="line">mov bx,[ArrayW]           ; bx=100</span><br><span class="line">mov bx,[ArrayW+2]         ; bx=200</span><br><span class="line">mov bx,[ArrayW+4]         ; bx=300</span><br><span class="line">; 针对内存单元双字存储操作</span><br><span class="line">mov eax,[ArrayDW]         ; eax=00000001</span><br><span class="line">mov eax,[ArrayDW+4]       ; eax=00000002</span><br><span class="line">mov eax,[ArrayDW+8]       ; eax=00000003</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆间接寻址◆"><a href="#◆间接寻址◆" class="headerlink" title="◆间接寻址◆"></a>◆间接寻址◆</h3><p>在处理数组操作时完全使用直接寻址是不切实际的,我们不大可能为数组的每个元素都提供一个不同的标号,也不太可能使用非常多的常量偏移地址去寻址数组的各个元素,处理数组唯一可行的方法是用寄存器作为指针并操作寄存器的值,这种方法称为<code>间接寻址(indirect addressing)</code>,操作数使用间接寻址时,就称为<code>间接操作数(indirect operand)</code>.</p><p><strong>通过ESI内存寻址:</strong> 通过使用ESI寄存器,外加偏移地址<code>(此处DWORD=4字节)</code>,实现寻址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayDW DWORD 10000h,20000h,300000h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset ArrayDW  ; 获取数据段的内存基址</span><br><span class="line">mov eax,[esi]           ; 取出[esi]地址中的数据,并赋值给eax</span><br><span class="line">add esi,4               ; 每次esi指针加4,因为数据格式为DWORD</span><br><span class="line">mov eax,[esi]</span><br><span class="line">add esi,4</span><br><span class="line">mov eax,[esi]</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>通过ESP堆栈寻址:</strong> 通过ESP堆栈寄存器,实现寻址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov eax,100                ; eax=1</span><br><span class="line">mov ebx,200                ; ebx=2</span><br><span class="line">mov ecx,300                ; ecx=3</span><br><span class="line">push eax                   ; push 1</span><br><span class="line">push ebx                   ; push 2</span><br><span class="line">push ecx                   ; push 3</span><br><span class="line"></span><br><span class="line">mov edx,[esp + 8]          ; EDX = [ESP+8]=1</span><br><span class="line">mov edx,[esp + 4]          ; EDX = [ESP+4]=2 </span><br><span class="line">mov edx,[esp]              ; EDX = [ESP]=3</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="◆变址寻址◆"><a href="#◆变址寻址◆" class="headerlink" title="◆变址寻址◆"></a>◆变址寻址◆</h3><p>变址寻址,<code>变址操作数(indexed operand)</code>把常量和寄存器相加以得到一个有效地址,任何32位通用寄存器都可以作为<code>变址寄存器</code>,MASM允许使用两种不同的变址操作数据格式.</p><p><strong>变量名+寄存器:</strong> 通过变量名和寄存器结合,变量名代表变量偏移地址的常量,通过变更<code>ESI寄存器</code>的值进行数据寻址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayDW DWORD 10000h,20000h,300000h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,0</span><br><span class="line">mov eax,[ArrayDW + esi]     ; 通过变量名+esi寄存器寻址</span><br><span class="line"></span><br><span class="line">mov ebx,8                   ; 增加8字节</span><br><span class="line">mov eax,[ArrayDW + ebx]     ; 定位第三个DW数据内存</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>基址+偏移:</strong> 通过把<code>变址寄存器</code>和<code>内存偏移常量</code>结合,用寄存器存放数组基址,用常量标识各个数组元素.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayW WORD 1000h,2000h,3000h,4000h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,offset ArrayW    ; 获取基址</span><br><span class="line">mov ax,[esi]             ; 显示第一个数据</span><br><span class="line">mov ax,[esi + 2]         ; 显示第二个数据</span><br><span class="line">mov ax,[esi + 4]         ; 最后一个</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>基址变址寻址:</strong> 通过计算公式,这里数组中每个元素占用4字节,所以需要乘以4,寄存器ECX为需要定位的元素偏移.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">Array DWORD 1000h,2000h,3000h,4000h,0h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">lea eax,Array</span><br><span class="line">mov ecx,2</span><br><span class="line">mov edx,DWORD PTR [eax + ecx * 4]      ;edx=3000h</span><br><span class="line"></span><br><span class="line">mov ecx,1</span><br><span class="line">mov edx,DWORD PTR [eax + ecx * 4]      ;edx=2000h</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>比例因子寻址:</strong> 通过使用比例因子,以下例子<code>每个DWORD=4字节</code>,且<code>总元素下标=0-3</code>,得出比例因子<code>3* type arrayDW</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayDW DWORD 1000h,2000h,3000h,4000h</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line"></span><br><span class="line">; 第1种比例因子寻址</span><br><span class="line">mov esi,3*type ArrayDW        ；总共3个下标x每个元素的类型</span><br><span class="line">mov eax,ArrayDW[esi]</span><br><span class="line">; 第2种比例因子寻址</span><br><span class="line">mov esi,3                      ; 变更ESI下标,可实现定位不同的数据</span><br><span class="line">mov eax,ArrayDW[esi*4]         ; 其中4代表每个数据类型4字节</span><br><span class="line">; 第3种比例因子寻址</span><br><span class="line">mov esi,3</span><br><span class="line">mov eax,ArrayDW[esi*type ArrayDW]</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><strong>指针寻址:</strong> 变量地址的变量称为<code>指针变量(pointer variable)</code>,Intel处理器使用两种基本类型的指针,即<code>near(近指针)</code>和<code>far(远指针)</code>,保护模式下使用<code>Near指针</code>,所以它被存储在双字变量中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">ArrayB BYTE 10,20,30,40,50</span><br><span class="line">ArrayD DWORD 1,2,3,4,5</span><br><span class="line"></span><br><span class="line">ptrB DWORD OFFSET ArrayB    ; 指针ptrB --&gt; ArrayB</span><br><span class="line">ptrD DWORD OFFSET ArrayD    ; 指针ptrD --&gt; ArrayD</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">mov esi,ptrB      ; 指向数组ArrayB</span><br><span class="line">mov al,[esi]      ; 取出 10h</span><br><span class="line">mov esi,ptrD      ; 指向数组ArrayD</span><br><span class="line">mov eax,[esi]     ; 取出 1h</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="标志测试指令"><a href="#标志测试指令" class="headerlink" title="标志测试指令"></a>标志测试指令</h2><p>在学习数据比较指令之前,需要先来了解一下标识寄存器这个东西,<code>标志寄存器</code>又称程序状态寄存器(Program Status Word,PSW),这是一个存放条件码标志,控制标志和系统标志的寄存器.</p><p>标志寄存器中存放的有条件标志,也有控制标志,它对于处理器的运行和整个过程的控制有着非常重要的作用.条件标志主要包括进位标志、奇偶标志、辅助进位标志、零标志、符号标志、溢出标志等,控制标志主要有跟踪标志,因为有标志寄存器的存在才能实现各种华丽的判断循环等,常用的标志有以下6个:</p><table><thead><tr><th style="text-align:left">标志位</th><th style="text-align:left">标志全称</th><th style="text-align:center">标志序号</th><th style="text-align:left">标志位说明</th></tr></thead><tbody><tr><td style="text-align:left">CF(Carry Flag)</td><td style="text-align:left">进位标志位</td><td style="text-align:center">0</td><td style="text-align:left">当执行一个加法(或减法)运算,使最高位产生进位(或借位)时,CF为1;否则为0</td></tr><tr><td style="text-align:left">PF(Parity Flag)</td><td style="text-align:left">奇偶标志位</td><td style="text-align:center">2</td><td style="text-align:left">当运算结果中,所有bit位(例:1001010)中1的个数为偶数时,则PF=1;为基数PF=0</td></tr><tr><td style="text-align:left">AF(Auxiliary Flag)</td><td style="text-align:left">辅助进位标志</td><td style="text-align:center">4</td><td style="text-align:left">执行加法(减法)运算,结果的低4位向高4位有进位(借位)时,则AF=1;否则AF=0</td></tr><tr><td style="text-align:left">ZF(Zero Flag)</td><td style="text-align:left">零标志位</td><td style="text-align:center">6</td><td style="text-align:left">若当前的运算结果为零,则ZF=1;否则ZF=0</td></tr><tr><td style="text-align:left">SF(Sign Flag)</td><td style="text-align:left">符号标志位</td><td style="text-align:center">7</td><td style="text-align:left">若运算结果为负数,则SF=1;若为非负数则SF=0</td></tr><tr><td style="text-align:left">TF(Trap Flag)</td><td style="text-align:left">陷阱标志位</td><td style="text-align:center">8</td><td style="text-align:left">为方便程序调试而设计的,TF=1单步执行指令,TF=0则CPU正常执行程序</td></tr><tr><td style="text-align:left">IF(Interrupt)</td><td style="text-align:left">中断允许标志</td><td style="text-align:center">9</td><td style="text-align:left">当IF=1CPU可响应可屏蔽中断请求,当设置IF=0则CPU不响应可屏蔽中断请求</td></tr><tr><td style="text-align:left">DF(Direction)</td><td style="text-align:left">方向标志位</td><td style="text-align:center">10</td><td style="text-align:left">当DF=0时为正向传送数据(cld),否则为逆向传送数据(std)</td></tr><tr><td style="text-align:left">OF(Overflow)</td><td style="text-align:left">溢出标志位</td><td style="text-align:center">11</td><td style="text-align:left">记录是否产生了溢出,当补码运算有溢出时OF=1;否则OF=0</td></tr></tbody></table><p><strong>ZF零标志位:</strong> ZF标志相关指令执行后,结果为0则ZF=1;若结果不为0则ZF=0.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C31000 | 90                   | nop                                              | ZF = 0</span><br><span class="line">00C31001 | B8 01000000          | mov eax,1                                        | ZF = 0</span><br><span class="line">00C31006 | 83E8 01              | sub eax,1                                        | ZF = 1</span><br><span class="line"></span><br><span class="line">00C31000 | 90                   | nop                                              | ZF = 0</span><br><span class="line">00C31001 | B8 02000000          | mov eax,2                                        | ZF = 0</span><br><span class="line">00C31006 | 83E8 01              | sub eax,1                                        | ZF = 0</span><br></pre></td></tr></table></figure></p><p><strong>PF奇偶标志位:</strong> PF标志相关指令执行后,其结果所有bit位中的1若为偶数,则PF=1;若为奇数PF=0.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C31000 | 90                   | nop                                              | PF = 0</span><br><span class="line">00C31001 | B8 00000000          | mov eax,00000000                                 | PF = 0</span><br><span class="line">00C31006 | 83C0 6F              | add eax,00000111                                 | PF = 1</span><br><span class="line"></span><br><span class="line">00C31000 | 90                   | nop                                              | PF = 0</span><br><span class="line">00C31001 | B8 00000000          | mov eax,00000000                                 | PF = 0</span><br><span class="line">00C31006 | 83C0 6F              | add eax,00000011                                 | PF = 0</span><br></pre></td></tr></table></figure></p><p><strong>SF符号标志位:</strong> SF标志相关指令执行后,其结果是否为负,若为负则SF=1;若为非负SF=0.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C3100B | 90                   | nop                                              | SF = 0</span><br><span class="line">00C3100C | B8 E8030000          | mov eax,3E8                                      | SF = 0</span><br><span class="line">00C31011 | 2D E9030000          | sub eax,3E9                                      | SF = 1</span><br><span class="line"></span><br><span class="line">00C3100B | 90                   | nop                                              | SF = 0</span><br><span class="line">00C3100C | B8 E8030000          | mov eax,3E8                                      | SF = 0</span><br><span class="line">00C31011 | 2D E9030000          | sub eax,3E8                                      | SF = 0</span><br></pre></td></tr></table></figure></p><p><strong>CF进位标志位:</strong> CF标志相关指令执行后,在进行无符号运算时,如果表达式发生进位或借位则CF=1.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C31016 | 90                   | nop                                              | CF = 0</span><br><span class="line">00C31017 | 66:B8 FFFF           | mov ax,FFFF                                      | CF = 0</span><br><span class="line">00C3101B | 66:83C0 01           | add ax,1                                         | CF = 1</span><br><span class="line"></span><br><span class="line">00C31016 | 90                   | nop                                              | CF = 0</span><br><span class="line">00C31017 | 66:B8 FFFF           | mov ax,FFFF                                      | CF = 0</span><br><span class="line">00C3101B | 66:83C0 01           | sub ax,1                                         | CF = 0</span><br></pre></td></tr></table></figure></p><p><strong>OF溢出标志位:</strong> OF标志相关指令执行后,超出机器所能表示的范围称为溢出若发生了溢出OF=1;否则OF=0.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00C3101B | 90                   | nop                                              | OF = 0</span><br><span class="line">00C3101C | B0 40                | mov al,64                                        | OF = 0</span><br><span class="line">00C3101E | 04 40                | add al,64                                        | OF = 1</span><br><span class="line"></span><br><span class="line">00C31020 | 90                   | nop                                              | OF = 0</span><br><span class="line">00C31021 | B0 3F                | mov al,63                                        | OF = 0</span><br><span class="line">00C31023 | 04 40                | add al,64                                        | OF = 0</span><br></pre></td></tr></table></figure></p><p><strong>TEST指令:</strong> 该操作与AND指令类似,唯一不同的是它不保存结果,常用来测试标志位状态.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00DD103B | B8 01000000        | mov eax,1                              | EAX = 1</span><br><span class="line">00DD1040 | BB 00000000        | mov ebx,0                              | EBX = 0</span><br><span class="line">00DD1045 | 85D8               | test eax,ebx                           | ZF = 1</span><br><span class="line"></span><br><span class="line">00DD1051 | B8 01000000        | mov eax,1                              |</span><br><span class="line">00DD1056 | A9 00000000        | test eax,0                             | ZF = 1</span><br><span class="line">00DD105B | 83E0 00            | and eax,0                              | ZF = 1</span><br><span class="line">00DD1062 | 83C8 01            | or eax,1                               | ZF = 0</span><br></pre></td></tr></table></figure></p><p><strong>CMP指令:</strong> 在源操作数和目标操作数进行减法操作,只影响标志位.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00DD1001 | B8 00010000        | mov eax,100                            | EAX = 100</span><br><span class="line">00DD1006 | BB 50000000        | mov ebx,50                             | EBX = 50</span><br><span class="line">00DD100B | 39D8               | cmp eax,ebx                            | eax - ebx</span><br><span class="line">00DD100D | 0F87 EDFF62FF      | ja 401000                              | jump</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h2><table><thead><tr><th style="text-align:left">注记符</th><th style="text-align:left">跳转条件</th><th style="text-align:left">描述信息</th></tr></thead><tbody><tr><td style="text-align:left">JZ/JE</td><td style="text-align:left">ZF=1</td><td style="text-align:left">为零则跳转,(leftOp - rightOp = 0)</td></tr><tr><td style="text-align:left">JNZ/JNE</td><td style="text-align:left">ZF=0</td><td style="text-align:left">不为零则跳转,(leftOp - rightOp != 0)</td></tr><tr><td style="text-align:left">JC/JNC</td><td style="text-align:left">CF=1/0</td><td style="text-align:left">设置进位标志则跳/未设置进位标志则跳</td></tr><tr><td style="text-align:left">JO/JNO</td><td style="text-align:left">OF=1/0</td><td style="text-align:left">设置溢出标志则跳/未设置溢出标志则跳</td></tr><tr><td style="text-align:left">JS/JNS</td><td style="text-align:left">SF=1/0</td><td style="text-align:left">设置符号标志则跳/未设置符号标志则跳</td></tr><tr><td style="text-align:left">JP/JNP</td><td style="text-align:left">PF=1/0</td><td style="text-align:left">设置奇偶标志则跳(偶)/未设置奇偶标志则跳(基)</td></tr></tbody></table><table><thead><tr><th style="text-align:left">无符号模式</th><th style="text-align:left">有符号模式</th><th style="text-align:left">跳转条件</th><th style="text-align:left">描述信息</th></tr></thead><tbody><tr><td style="text-align:left">JA</td><td style="text-align:left">JG</td><td style="text-align:left">(left &gt; right)</td><td style="text-align:left">大于则跳转</td></tr><tr><td style="text-align:left">JAE</td><td style="text-align:left">JGE</td><td style="text-align:left">(left &gt;= right)</td><td style="text-align:left">大于或等于则跳转</td></tr><tr><td style="text-align:left">JB</td><td style="text-align:left">JL</td><td style="text-align:left">(left &lt; right)</td><td style="text-align:left">小于则跳转</td></tr><tr><td style="text-align:left">JBE</td><td style="text-align:left">JLE</td><td style="text-align:left">(left &lt;= right)</td><td style="text-align:left">小于或等于则跳转</td></tr></tbody></table><p><strong>JZ/JE通用跳转:</strong> 检测到<code>ZF=1</code>也就说明表达式返回了0,则程序跳转,否则不跳转.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B8 00010000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB 00010000        | mov ebx,64                      | ebx=100</span><br><span class="line">0103100B | 39D8               | cmp eax,ebx                     | eax-ebx </span><br><span class="line">0103100D | 0F84 EDFF3CFF      | je 401000                       | jump</span><br><span class="line">01031013 | 0F84 E7FF3CFF      | jz 401000                       | jump</span><br></pre></td></tr></table></figure></p><p><strong>JNZ/JNE通用跳转:</strong> 检测到<code>ZF=0</code>也就说明表达式返回了1,则程序跳转,否则不跳转.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B8 00010000        | mov eax,65                      | eax=101</span><br><span class="line">01031006 | BB 00010000        | mov ebx,64                      | ebx=100</span><br><span class="line">0103100B | 39D8               | cmp eax,ebx                     | eax-ebx </span><br><span class="line">0103100D | 0F84 EDFF3CFF      | jne 401000                      | not jump</span><br><span class="line">01031013 | 0F84 E7FF3CFF      | jnz 401000                      | not jump</span><br></pre></td></tr></table></figure></p><p><strong>JA/JB无符号跳转:</strong> 基于<code>无符号</code>数的<code>跳转</code>指令,<code>JA大于则跳转</code>或<code>JB小于则跳转</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB C8000000        | mov ebx,C8                      | ebx=200</span><br><span class="line">0103100B | 3BD8               | cmp ebx,eax                     | ebx-eax</span><br><span class="line">0103100D | 0F87 EDFF3CFF      | ja 401000                       | ebx&gt;eax jump</span><br><span class="line"></span><br><span class="line">0103100F | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031014 | BB 32000000        | mov ebx,32                      | ebx=50</span><br><span class="line">01031019 | 3BD8               | cmp ebx,eax                     | ebx-eax</span><br><span class="line">0103101B | 0F82 DFFF3CFF      | jb 401000                       | ebx&lt;eax jump</span><br><span class="line"></span><br><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB 64000000        | mov ebx,64                      | ebx=100</span><br><span class="line">0103100B | 3BC3               | cmp eax,ebx                     | eax-ebx</span><br><span class="line">0103100D | 0F87 EDFF3CFF      | ja 401000                       | eax=ebx not jump</span><br><span class="line">01031013 | 0F82 E7FF3CFF      | jb 401000                       | eax=ebx not jump</span><br></pre></td></tr></table></figure></p><p><strong>JAE/JBE无符号跳转:</strong> 基于<code>无符号</code>数的<code>跳转</code>指令,<code>JAE大于等于则跳转</code>或<code>JBE小于等于则跳转</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB 64000000        | mov ebx,64                      | ebx=100</span><br><span class="line">01031010 | 3BC3               | cmp eax,ebx                     | eax-ebx</span><br><span class="line">01031012 | 0F83 E8FF3CFF      | jae 401000                      | eax&gt;=ebx jump</span><br><span class="line"></span><br><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB C8000000        | mov ebx,C8                      | ebx=200</span><br><span class="line">0103100B | 3BD8               | cmp ebx,eax                     | ebx-eax</span><br><span class="line">0103100D | 0F83 EDFF3CFF      | jae 401000                      | ebx&gt;=eax jump</span><br><span class="line"></span><br><span class="line">01031001 | B8 C8000000        | mov eax,C8                      | eax=200</span><br><span class="line">01031006 | BB 64000000        | mov ebx,64                      | ebx=100</span><br><span class="line">0103100B | 3BD8               | cmp ebx,eax                     | ebx-eax</span><br><span class="line">0103100D | 0F86 EDFF3CFF      | jbe 401000                      | ebx&lt;=eax jump</span><br></pre></td></tr></table></figure></p><p><strong>JG/JL有符号跳转:</strong> 基于<code>有符号</code>数的<code>跳转</code>指令,<code>JG大于则跳转</code>或<code>JL小于则跳转</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B0 7F              | mov al,7F                       | al=0x7F(+127)</span><br><span class="line">01031003 | B3 80              | mov bl,80                       | bl=0x80(-128)</span><br><span class="line">01031005 | 3AC3               | cmp al,bl                       | (+128)-(-127)</span><br><span class="line">01031007 | 0F87 F3FF3CFF      | ja 401000                       | 不跳转,因为7Fh不大于80h</span><br><span class="line">0103100D | 0F8F EDFF3CFF      | jg 401000                       | 跳转,因为(+128)大于(-127)</span><br><span class="line"></span><br><span class="line">01031001 | B0 9C              | mov al,9C                       | al=(-100)</span><br><span class="line">01031003 | B3 32              | mov bl,32                       | bl=(50)</span><br><span class="line">01031005 | 3AC3               | cmp al,bl                       | (-100)-(50)</span><br><span class="line">01031007 | 0F82 F3FF3CFF      | jb 401000                       | 不跳转,因为9ch不小于32h</span><br><span class="line">0103100D | 0F8C EDFF3CFF      | jl 401000                       | 跳转,因为(-100)小于(32)</span><br></pre></td></tr></table></figure></p><p><strong>JGE/JLE有符号跳转:</strong> 基于<code>有符号</code>数的<code>跳转</code>指令,<code>JGE大于等于则跳转</code>或<code>JLE小于等于则跳转</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB 64000000        | mov ebx,64                      | ebx=100</span><br><span class="line">0103100B | 3BC3               | cmp eax,ebx                     | eax-ebx</span><br><span class="line">0103100D | 0F83 EDFF3CFF      | jae 401000                      | 跳转,无符号100=100</span><br><span class="line">01031013 | 0F8D E7FF3CFF      | jge 401000                      | 跳转,有符号100=100</span><br><span class="line"></span><br><span class="line">01031001 | B8 64000000        | mov eax,64                      | eax=100</span><br><span class="line">01031006 | BB 9CFFFFFF        | mov ebx,FFFFFF9C                | ebx=(-100)</span><br><span class="line">0103100B | 3BD8               | cmp ebx,eax                     | ebx-eax</span><br><span class="line">0103100D | 0F8E EDFF3CFF      | jle 401000                      | 跳转,有符号数(-100)&lt;(100)</span><br></pre></td></tr></table></figure></p><p><strong>JCXZ/JECXZ跳转指令:</strong> <code>检测ECX</code>寄存器的值,如果<code>等于零则执行跳转</code>,否则跳过执行.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01031001 | B9 01000000        | mov ecx,1                       | ecx=1</span><br><span class="line">01031006 | E3 F8              | jecxz &lt;a.EntryPoint&gt;            | not jump</span><br><span class="line"></span><br><span class="line">0103100A | B9 00000000        | mov ecx,0                       | ecx=0</span><br><span class="line">0103100F | E3 EF              | jecxz &lt;a.EntryPoint&gt;            | jump</span><br></pre></td></tr></table></figure></p><p><strong>其他测试指令:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(eax==ebx)&amp;&amp; zero?    如果eax=ebx并且ZF=0则执行</span><br><span class="line">(eax==ebx)&amp;&amp; !zero?   如果eax=ebx并且ZF!=0则执行</span><br><span class="line"></span><br><span class="line">CARRY? carry位是否置位</span><br><span class="line">overflow?   溢出</span><br><span class="line">parity?</span><br><span class="line">sign?</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言,亦称为符号语言.在汇编语言中,用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或标号(Label)代替指令或操作数的地址.在不同的设备中,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令,普遍地说,特定的汇编语言和特定的机器语言指令集是相互对应的,不同平台之间不可直接移植.&lt;/p&gt;
&lt;p&gt;该系列笔记,记录了Win32汇编的常用语法规则,有些汇编代码并没有返回任何参数,如需观察,请编译后使用OllyDBG附加进程,单步跟踪调试,该笔记是为二进制软件逆向打基础的,故简化的很多项目开发章节的内容,如果你需要使用汇编开发项目(当然那样很麻烦),你可以参考&lt;code&gt;《Intel 汇编语言程序设计》,《琢石成器-Win32汇编语言程序设计》&lt;/code&gt;,当然本笔记的所有内容也是来自于这两本书的实例,不过简化了大量繁琐的文字描述,只保留了比较实用的内容.&lt;/p&gt;
    
    </summary>
    
      <category term="汇编与反汇编" scheme="https://localhost/categories/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编与反汇编" scheme="https://localhost/tags/%E6%B1%87%E7%BC%96%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>华为防火墙配置笔记</title>
    <link href="https://localhost/2019/04/11/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://localhost/2019/04/11/网络设备配置/华为防火墙配置笔记/</id>
    <published>2019-04-11T02:42:41.000Z</published>
    <updated>2019-05-30T09:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>防火墙（Firewall）也称防护墙，是由Check Point创立者Gil Shwed于1993年发明并引入国际互联网（US5606668（A）1993-12-15）防火墙是位于内部网和外部网之间的屏障，它按照系统管理员预先定义好的规则来控制数据包的进出。防火墙是系统的第一道防线，其作用是防止非法用户的进入。</p><a id="more"></a><p><br></p><h2 id="初始化防火墙"><a href="#初始化防火墙" class="headerlink" title="初始化防火墙"></a>初始化防火墙</h2><p><strong>初始化防火墙:</strong> 默认用户名为<code>admin</code>,默认的密码<code>Admin@123</code>,这里修改密码为<code>LyShark@163</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username:admin</span><br><span class="line">Password:*****</span><br><span class="line">The password needs to be changed. Change now? [Y/N]: y</span><br><span class="line">Please enter old password: Admin@123</span><br><span class="line">Please enter new password: LyShark@163</span><br><span class="line">Please confirm new password: LyShark@163</span><br><span class="line"></span><br><span class="line">&lt;FW1&gt; system-view                      // 进入系统视图</span><br><span class="line">[FW1] sysname FW1                      // 给防火墙命名</span><br><span class="line">[FW1] undo info-center enable          // 关闭日志弹出功能</span><br><span class="line">[FW1] quit</span><br><span class="line">&lt;FW1&gt; language-mode Chinese            // 将提示修改为中文</span><br><span class="line">Change language mode, confirm? [Y/N] y</span><br><span class="line">提示：改变语言模式成功.</span><br></pre></td></tr></table></figure></p><p><strong>开启Web管理界面:</strong> 默认防火墙console接口IP地址是192.168.0.1.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt; system-view</span><br><span class="line">[FW1] web-manager enable                                // 开启图形管理界面</span><br><span class="line">[FW1] interface GigabitEthernet 0/0/0</span><br><span class="line">[FW1-GigabitEthernet0/0/0] ip address 192.168.0.1 24    // 给接口配置IP地址</span><br><span class="line">[FW1-GigabitEthernet0/0/0] service-manage all permit    // 放行该端口的请求</span><br><span class="line">[FW1-GigabitEthernet0/0/0] display this</span><br></pre></td></tr></table></figure></p><p><strong>配置Console口登陆:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt; system-view                                               // 进入系统视图</span><br><span class="line">[FW1] user-interface console 0                                  // 进入console0的用户配置接口</span><br><span class="line">[FW1-ui-console0] authentication-mode password                  // 使用密码验证模式</span><br><span class="line">[FW1-ui-console0] set authentication password cipher Admin1234  // 设置密码为Admin1234</span><br><span class="line">[FW1-ui-console0] quit                                          // 退出用户配置接口</span><br></pre></td></tr></table></figure></p><p><strong>配置telnet密码认证:</strong> 配置密码认证模式,此处配置密码为<code>Admin@123</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt; system-view</span><br><span class="line"></span><br><span class="line">[FW1] telnet server enable                              // 开启Telnet支持</span><br><span class="line">[FW1] interface GigabitEthernet 0/0/0                   // 选择配置接口</span><br><span class="line">[FW1-GigabitEthernet0/0/0] service-manage telnet permit // 允许telnet</span><br><span class="line">[FW1-GigabitEthernet0/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW1] user-interface vty 0 4                                  // 开启虚拟终端</span><br><span class="line">[FW1-ui-vty0-4] protocol inbound telnet                       // 允许telnet</span><br><span class="line">[FW1-ui-vty0-4] authentication-mode password                  // 设置为密码认证模式</span><br><span class="line">[FW1-ui-vty0-4] set authentication password cipher Admin@123  // 设置用户密码</span><br><span class="line"></span><br><span class="line">[USG6000V1] firewall zone trust                                // 选择安全区域</span><br><span class="line">[USG6000V1-zone-trust] add interface GE0/0/0                   // 添加到安全区域</span><br></pre></td></tr></table></figure></p><p><strong>配置telnet用户名密码认证:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt; system-view                                       // 进入系统视图</span><br><span class="line">[FW1] interface GigabitEthernet 0/0/0                   // 进入接口配置</span><br><span class="line">[FW1-GigabitEthernet0/0/0] ip address 192.168.0.1 24    // 配置接口IP</span><br><span class="line">[FW1-GigabitEthernet0/0/0] service-manage telnet permit // 允许telnet</span><br><span class="line">[FW1-GigabitEthernet0/0/0] service-manage ping permit   // 允许ping</span><br><span class="line">[FW1-GigabitEthernet0/0/0] quit                         //退出</span><br><span class="line"></span><br><span class="line">[FW1] firewall zone trust                              // 进入trust安全域配置</span><br><span class="line">[FW1-zone-trust] add interface GigabitEthernet 0/0/0   // 把GE0/0/0加入到trust安全域</span><br><span class="line">[FW1-zone-trust] quit</span><br><span class="line"></span><br><span class="line">[FW1] telnet server enable                // 启用telnet服务</span><br><span class="line">[FW1] user-interface vty 0 4              // 进入vty0-4的用户配置接口</span><br><span class="line">[FW1-ui-vty0-4] authentication-mode aaa   // 使用AAA验证模式</span><br><span class="line">[FW1-ui-vty0-4] user privilege level 3    // 配置用户访问的命令级别为3</span><br><span class="line">[FW1-ui-vty0-4] protocol inbound telnet   // 配置telnet</span><br><span class="line">[FW1-ui-vty0-4] quit                      // 退出用户配置接口</span><br><span class="line"></span><br><span class="line">[FW1] aaa                                 // 进入AAA配置视图</span><br><span class="line">[FW1-aaa] manager-user lyshark            // 创建用户vtyadmin</span><br><span class="line">[FW1-aaa-manager-user-lyshark] password cipher admin@123   // 配置用户密码</span><br><span class="line">[FW1-aaa-manager-user-lyshark] service-type telnet         // 配置服务类型</span><br><span class="line">[FW1-aaa-manager-user-lyshark] quit                        // 退出</span><br><span class="line"></span><br><span class="line">[FW1-aaa] bind manager-user lyshark role system-admin     // 绑定管理员角色</span><br><span class="line">[FW1-aaa] quit                                             // 退出AAA视图</span><br></pre></td></tr></table></figure></p><p><strong>常用查询命令:</strong> 查询防火墙的其他配置,常用的几个命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] display ip interface brief            // 查默认接口信息</span><br><span class="line">[FW1] display ip routing-table              // 显示路由表</span><br><span class="line">[FW1] display zone                          // 显示防火墙区域</span><br><span class="line">[FW1] display firewall session table        // 显示当前会话</span><br><span class="line">[FW1] display security-policy rule all      // 显示安全策略</span><br></pre></td></tr></table></figure></p><p>配置到这里,我们就可以在浏览器中访问了,其访问地址是<code>http://192.168.0.1</code><br><br></p><h2 id="防火墙基本配置"><a href="#防火墙基本配置" class="headerlink" title="防火墙基本配置"></a>防火墙基本配置</h2><p><img src="/picture/20190423164101.jpg" alt="blockchain"></p><p><strong>初始化防火墙:</strong> 初始化配置,并设置好防火墙密码,此处用户名<code>admin</code>密码是<code>Lyshark@123</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username:admin</span><br><span class="line">Password:*****</span><br><span class="line">The password needs to be changed. Change now? [Y/N]: y</span><br><span class="line">Please enter old password: Admin@123</span><br><span class="line">Please enter new password: Lyshark@163</span><br><span class="line">Please confirm new password: Lyshark@163</span><br><span class="line"></span><br><span class="line">&lt;USG6000V1&gt; system-view                                 // 进入系统视图</span><br><span class="line">[USG6000V1] sysname FW1                                 // 给防火墙命名</span><br><span class="line">[FW1] undo info-center enable                           // 关闭日志弹出功能</span><br><span class="line">[FW1] quit</span><br><span class="line">&lt;FW1&gt; language-mode Chinese                             // 将提示修改为中文</span><br><span class="line">[FW1] web-manager enable                                // 开启图形管理界面</span><br><span class="line">[FW1] interface GigabitEthernet 0/0/0</span><br><span class="line">[FW1-GigabitEthernet0/0/0] service-manage all permit    // 放行该端口的请求</span><br></pre></td></tr></table></figure></p><p><strong>配置内网接口:</strong> 配置内网的接口信息,这里包括个<code>GE 1/0/0 and GE 1/0/1</code>这两个内网地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt; system-view</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/0</span><br><span class="line">[FW1-GigabitEthernet1/0/0] ip address 192.168.1.1 255.255.255.0</span><br><span class="line">[FW1-GigabitEthernet1/0/0] undo shutdown</span><br><span class="line">[FW1-GigabitEthernet1/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW1] interface GigabitEthernet 1/0/1</span><br><span class="line">[FW1-GigabitEthernet1/0/1] ip address 192.168.2.1 255.255.255.0</span><br><span class="line">[FW1-GigabitEthernet1/0/1] undo shutdown</span><br><span class="line">[FW1-GigabitEthernet1/0/1] quit</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------------</span><br><span class="line">[FW1] firewall zone trust                                       // 将前两个接口加入trust区域</span><br><span class="line">[FW1-zone-trust] add interface GigabitEthernet  1/0/0</span><br><span class="line">[FW1-zone-trust] add interface GigabitEthernet  1/0/1</span><br></pre></td></tr></table></figure></p><p><strong>配置外网接口:</strong> 配置外网接口<code>GE 1/0/2</code>接口的IP地址,并将其加入到<code>untrust区域</code>中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] interface GigabitEthernet 1/0/2                            // 选择外网接口</span><br><span class="line">[FW1-GigabitEthernet1/0/2] undo shutdown                         // 开启外网接口</span><br><span class="line">[FW1-GigabitEthernet1/0/2] ip address 10.10.10.10 255.255.255.0  // 配置IP地址</span><br><span class="line">[FW1-GigabitEthernet1/0/2] gateway 10.10.10.20                   // 配置网关</span><br><span class="line">[FW1-GigabitEthernet1/0/2] undo service-manage enable</span><br><span class="line">[FW1-GigabitEthernet1/0/2] quit</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------------</span><br><span class="line">[FW1] firewall zone untrust                                      // 选择外网区域</span><br><span class="line">[FW1-zone-untrust] add interface GigabitEthernet 1/0/2           // 将接口加入到此区域</span><br></pre></td></tr></table></figure></p><p><strong>配置安全策略:</strong> 配置防火墙安全策略,放行<code>trust(内网)--&gt;untrust(外网)</code>的数据包.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] security-policy                                         // 配置安全策略</span><br><span class="line">[FW1-policy-security] rule name lyshark                       // 规则名称</span><br><span class="line">[FW1-policy-security-rule-lyshark] source-zone trust          // 原安全区域(内部)</span><br><span class="line">[FW1-policy-security-rule-lyshark] destination-zone untrust   // 目标安全区域(外部)</span><br><span class="line"></span><br><span class="line">[FW1-policy-security-rule-lyshark] source-address any         // 原地址区域</span><br><span class="line">[FW1-policy-security-rule-lyshark] destination-address any    // 目标地址区域</span><br><span class="line">[FW1-policy-security-rule-lyshark] service any                // 放行所有服务</span><br><span class="line">[FW1-policy-security-rule-lyshark] action permit              // 放行配置</span><br><span class="line">[FW1-policy-security-rule-lyshark] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置源NAT:</strong> 配置原NAT地址转换,仅配置源地址访问<code>内网 --&gt; 公网</code>的转换.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] nat-policy                                                      // 配置NAT地址转换</span><br><span class="line">[FW1-policy-nat] rule name lyshark                                    // 指定策略名称</span><br><span class="line">[FW1-policy-nat-rule-lyshark] egress-interface GigabitEthernet 1/0/2  // 外网接口IP</span><br><span class="line">[FW1-policy-nat-rule-lyshark] action source-nat easy-ip               // 源地址转换</span><br><span class="line">[FW1-policy-nat-rule-lyshark] display this</span><br></pre></td></tr></table></figure></p><p><strong>配置目标NAT:</strong> 外网访问<code>10.10.10.10</code>自动映射到内网的<code>192.168.2.1</code>这台主机上.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] firewall zone untrust                                      // 选择外网区域</span><br><span class="line">[FW1-zone-untrust] add interface GigabitEthernet 1/0/2           // 将接口加入到此区域</span><br><span class="line"></span><br><span class="line"># ----NAT规则---------------------------------------------------</span><br><span class="line"># 外网主机访问10.10.10.10主机自动映射到内部的192.168.2.2</span><br><span class="line">[FW1] firewall detect ftp</span><br><span class="line">[FW1] nat server lyshark global 10.10.10.10 inside 192.168.2.2 no-reverse</span><br><span class="line"></span><br><span class="line"># ----放行规则---------------------------------------------------</span><br><span class="line">[FW1] security-policy                                         // 配置安全策略</span><br><span class="line">[FW1-policy-security] rule name untrs-trs                     // 规则名称</span><br><span class="line">[FW1-policy-security-rule-lyshark] source-zone untrust        // 原安全区域(外部)</span><br><span class="line">[FW1-policy-security-rule-lyshark] destination-zone trust     // 目标安全区域(内部)</span><br><span class="line">[FW1-policy-security-rule-lyshark] action permit              // 放行配置</span><br><span class="line">[FW1-policy-security-rule-lyshark] quit</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h2><p><img src="/picture/20190424094023.jpg" alt="blockchain"></p><p><strong>配置内网区域:</strong> 分别配置防火墙内网接口<code>GE1/0/0 and GE1/0/1</code>设置IP地址,并加入指定区域内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FW1&gt;system-view</span><br><span class="line">[FW1]undo info-center enable</span><br><span class="line"></span><br><span class="line"># ----配置IP地址-----------------------------------------------</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/0</span><br><span class="line">[FW1-GigabitEthernet1/0/0] ip address 192.168.1.1 24</span><br><span class="line">[FW1-GigabitEthernet1/0/0] quit</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/1</span><br><span class="line">[FW1-GigabitEthernet1/0/1] ip address 192.168.2.1 24</span><br><span class="line">[FW1-GigabitEthernet1/0/1] quit</span><br><span class="line"></span><br><span class="line"># ----加入到指定区域--------------------------------------------</span><br><span class="line">[FW1] firewall zone trust</span><br><span class="line">[FW1-zone-trust] add interface GigabitEthernet 1/0/0</span><br><span class="line"></span><br><span class="line">[FW1] firewall zone dmz</span><br><span class="line">[FW1-zone-dmz] add interface GigabitEthernet 1/0/1</span><br></pre></td></tr></table></figure></p><p><strong>配置外网区域:</strong> 然后配置外网地址,将<code>Gig 1/0/2</code>加入到untrust区域内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] interface GigabitEthernet 1/0/2</span><br><span class="line">[FW1-GigabitEthernet1/0/2] ip address 10.10.10.10 8</span><br><span class="line"></span><br><span class="line">[FW1] firewall zone untrust</span><br><span class="line">[FW1-zone-dmz] add interface GigabitEthernet 1/0/2</span><br></pre></td></tr></table></figure></p><p><strong>配置源NAT:</strong> 配置原NAT地址转换,仅配置源地址访问<code>内网 --&gt; 公网</code>的转换.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置源NAT转换---------------------------------------------</span><br><span class="line">[FW1] nat-policy                                                      // 配置NAT地址转换</span><br><span class="line">[FW1-policy-nat] rule name lyshark                                    // 指定策略名称</span><br><span class="line">[FW1-policy-nat-rule-lyshark] egress-interface GigabitEthernet 1/0/2  // 外网接口IP</span><br><span class="line">[FW1-policy-nat-rule-lyshark] action source-nat easy-ip               // 源地址转换</span><br><span class="line">[FW1-policy-nat-rule-lyshark] display this</span><br><span class="line"></span><br><span class="line"># ----放行相关安全策略------------------------------------------</span><br><span class="line">[FW1] security-policy</span><br><span class="line">[FW1-policy-security] rule name trust_untrust</span><br><span class="line">[FW1-policy-security-rule] source-zone trust</span><br><span class="line">[FW1-policy-security-rule] destination-zone untrust</span><br><span class="line">[FW1-policy-security-rule] action permit</span><br></pre></td></tr></table></figure></p><p><strong>配置目标NAT:</strong> 外网访问<code>10.10.10.10</code>自动映射到内网的<code>192.168.2.2</code>这台主机上.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----NAT规则---------------------------------------------------</span><br><span class="line"># 外网主机访问10.10.10.10主机自动映射到内部的192.168.2.2</span><br><span class="line">[FW1] firewall detect ftp</span><br><span class="line">[FW1]nat server lyshark global 10.10.10.10 inside 192.168.2.2 no-reverse </span><br><span class="line"></span><br><span class="line"># ----放行规则---------------------------------------------------</span><br><span class="line">[FW1] security-policy                                           // 配置安全策略</span><br><span class="line">[FW1-policy-security] rule name untrs-DMZ                       // 规则名称</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] source-zone untrust        // 原安全区域(外部)</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] destination-zone trust     // 目标安全区域(内部)</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] destination-address 192.168.2.2 24</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] service any</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] action permit              // 放行配置</span><br><span class="line">[FW1-policy-security-rule-untrs-DMZ] quit</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="配成交换机"><a href="#配成交换机" class="headerlink" title="配成交换机"></a>配成交换机</h2><p><img src="/picture/20190424174537.jpg" alt="blockchain"></p><p><strong>配置两台交换机:</strong> 分别配置两台交换机,并划分到相应的VLAN区域内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置LSW1交换机--------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[LSW1] vlan 10                                     // 创建VLAN10</span><br><span class="line">[LSW1] quit</span><br><span class="line">[LSW1] interface Ethernet 0/0/1                    // 将该接口配置为trunk</span><br><span class="line">[LSW1-Ethernet0/0/1] port link-type trunk</span><br><span class="line">[LSW1-Ethernet0/0/1] port trunk allow-pass vlan 10 // 加入到vlan 10</span><br><span class="line">[LSW1-Ethernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[LSW1] port-group group-member Eth0/0/2 to Eth0/0/3</span><br><span class="line">[LSW1-port-group] port link-type access</span><br><span class="line">[LSW1-port-group] port default vlan 10</span><br><span class="line">[LSW1-port-group] quit</span><br><span class="line"></span><br><span class="line"># ----配置LSW2交换机--------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[LSW2] vlan 20</span><br><span class="line">[LSW1] quit</span><br><span class="line"></span><br><span class="line">[LSW2] interface Ethernet 0/0/1</span><br><span class="line">[LSW2-Ethernet0/0/1] port link-type trunk</span><br><span class="line">[LSW2-Ethernet0/0/1] port trunk allow-pass vlan 20</span><br><span class="line">[LSW2-Ethernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[LSW2] port-group group-member Eth0/0/2 to Eth0/0/3</span><br><span class="line">[LSW2-port-group] port link-type access</span><br><span class="line">[LSW2-port-group] port default vlan 20</span><br><span class="line">[LSW2-port-group] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置防火墙:</strong> 配置<code>Gig1/0/0和Gig1/0/1</code>接口为trunk模式,并分别配置好网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] vlan 10</span><br><span class="line">[FW1-vlan10] quit</span><br><span class="line">[FW1] vlan 20</span><br><span class="line">[FW1-vlan20] quit</span><br><span class="line"></span><br><span class="line"># ----配置防火墙接口地址-----------------------------------------</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/0</span><br><span class="line">[FW1-GigabitEthernet1/0/0] portswitch</span><br><span class="line">[FW1-GigabitEthernet1/0/0] port link-type trunk</span><br><span class="line">[FW1-GigabitEthernet1/0/0] port trunk allow-pass vlan 10</span><br><span class="line"></span><br><span class="line">[FW1] interface GigabitEthernet 1/0/1</span><br><span class="line">[FW1-GigabitEthernet1/0/1] portswitch</span><br><span class="line">[FW1-GigabitEthernet1/0/1] port link-type trunk</span><br><span class="line">[FW1-GigabitEthernet1/0/1] port trunk allow-pass vlan 20</span><br><span class="line"></span><br><span class="line"># ----分别给VLAN配置IP地址---------------------------------------</span><br><span class="line">[FW1]interface Vlanif 10</span><br><span class="line">[FW1-Vlanif10]</span><br><span class="line">[FW1-Vlanif10]ip address 192.168.10.1 255.255.255.0</span><br><span class="line">[FW1-Vlanif10]alias vlan 10</span><br><span class="line">[FW1-Vlanif10]service-manage ping permit</span><br><span class="line"></span><br><span class="line">[FW1] interface Vlanif 20</span><br><span class="line">[FW1-Vlanif20]</span><br><span class="line">[FW1-Vlanif20] ip address 192.168.20.1 255.255.255.0</span><br><span class="line">[FW1-Vlanif20] alias vlan 20</span><br><span class="line">[FW1-Vlanif20] service-manage ping permit</span><br></pre></td></tr></table></figure></p><p><strong>添加防火墙区域:</strong> 将vlan10和vlan20添加到trust区域内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1]firewall zone trust</span><br><span class="line">[FW1-zone-trust] add interface Vlanif 10</span><br><span class="line">[FW1-zone-trust] add interface Vlanif 20</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="主备双机热备"><a href="#主备双机热备" class="headerlink" title="主备双机热备"></a>主备双机热备</h2><p><img src="/picture/20190424174539.jpg" alt="blockchain"></p><p><strong>放行所有数据包(两台墙):</strong> 为了演示实验,需要手动放行数据包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 将默认防火墙规则,设置为允许所有</span><br><span class="line">[FW1] security-policy </span><br><span class="line">[FW1-policy-security] rule name anyall                   // 指定规则名称</span><br><span class="line">[FW1-policy-security-rule-anyall] source-zone any        // 源地址允许所有</span><br><span class="line">[FW1-policy-security-rule-anyall] destination-zone any   // 目标地址允许所有</span><br><span class="line">[FW1-policy-security-rule-anyall] action permit          // 放行</span><br><span class="line">[FW1-policy-security-rule-anyall] quit </span><br><span class="line">[FW1-policy-security] quit</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 将指定的接口加入到指定的区域内</span><br><span class="line">[FW1] firewall zone trust                                // 选择trust区域</span><br><span class="line">[FW1-zone-trust] add interface GigabitEthernet 1/0/0     // 添加内部的端口</span><br><span class="line">[FW1-zone-trust] quit</span><br><span class="line">[FW1] firewall zone untrust                              // 添加untru区域                            </span><br><span class="line">[FW1-zone-untrust] add interface GigabitEthernet 1/0/1   // 添加外部接口</span><br><span class="line">[FW1-zone-trust] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置IP地址(两台)</strong> 给防火墙的两个接口配置好IP地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW1</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/0                       // 选择内部接口</span><br><span class="line">[FW1-GigabitEthernet1/0/0] ip address 192.168.1.253 24      // 配置防火墙IP</span><br><span class="line">[FW1-GigabitEthernet1/0/0] service-manage ping permit       // 开启接口ping</span><br><span class="line">[FW1-GigabitEthernet1/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW1] interface GigabitEthernet1/0/1</span><br><span class="line">[FW1-GigabitEthernet1/0/1] ip address 10.10.10.20 8</span><br><span class="line">[FW1-GigabitEthernet1/0/1] service-manage ping permit</span><br><span class="line">[FW1-GigabitEthernet1/0/1] quit</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW2</span><br><span class="line">[FW2] interface GigabitEthernet 1/0/0                       // 选择内部接口</span><br><span class="line">[FW2-GigabitEthernet1/0/0] ip address 192.168.1.254 24      // 配置防火墙IP</span><br><span class="line">[FW2-GigabitEthernet1/0/0] service-manage ping permit       // 开启接口ping</span><br><span class="line">[FW2-GigabitEthernet1/0/0] quit</span><br><span class="line">[FW2-GigabitEthernet1/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW2] interface GigabitEthernet1/0/1</span><br><span class="line">[FW2-GigabitEthernet1/0/1] ip address 10.10.10.30 8</span><br><span class="line">[FW2-GigabitEthernet1/0/1] service-manage ping permit</span><br><span class="line">[FW2-GigabitEthernet1/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>开启源NAT地址</strong>:将内网数据映射到外网.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW1</span><br><span class="line">[FW1] nat-policy                                                       // 配置NAT地址转换</span><br><span class="line">[FW1-policy-nat] rule name tru_untr                                    // 指定策略名称</span><br><span class="line">[FW1-policy-nat-rule-tru_untr] egress-interface GigabitEthernet 1/0/1  // 外网接口IP</span><br><span class="line">[FW1-policy-nat-rule-tru_untr] action source-nat easy-ip               // 源地址转换</span><br><span class="line">[FW1-policy-nat-rule-tru_untr] display this</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW2</span><br><span class="line">[FW2] nat-policy                                                       // 配置NAT地址转换</span><br><span class="line">[FW2-policy-nat] rule name tru_untr                                    // 指定策略名称</span><br><span class="line">[FW2-policy-nat-rule-tru_untr] egress-interface GigabitEthernet 1/0/1  // 外网接口IP</span><br><span class="line">[FW2-policy-nat-rule-tru_untr] action source-nat easy-ip               // 源地址转换</span><br><span class="line">[FW2-policy-nat-rule-tru_untr] display this</span><br></pre></td></tr></table></figure></p><p><strong>开启VRRP支持(两台)</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW1</span><br><span class="line">[FW1] interface GigabitEthernet 1/0/0                                 // 选择内部接口</span><br><span class="line">[FW1-GigabitEthernet1/0/0] vrrp vrid 1 virtual-ip 192.168.1.1 active  // 配置虚拟接口为主</span><br><span class="line">[FW1-GigabitEthernet1/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW1] interface GigabitEthernet 1/0/1                                 // 选择外部接口</span><br><span class="line">[FW1-GigabitEthernet1/0/1] vrrp vrid 2 virtual-ip 10.10.10.10 active</span><br><span class="line">[FW1-GigabitEthernet1/0/1] quit</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW12</span><br><span class="line">[FW2] interface GigabitEthernet 1/0/0                                 // 选择内部接口</span><br><span class="line">[FW2-GigabitEthernet1/0/0] vrrp vrid 1 virtual-ip 192.168.1.1 standby // 配置虚拟接口为备</span><br><span class="line">[FW2-GigabitEthernet1/0/0] quit</span><br><span class="line"></span><br><span class="line">[FW2] interface GigabitEthernet 1/0/1</span><br><span class="line">[FW2-GigabitEthernet1/0/1] vrrp vrid 2 virtual-ip 10.10.10.10 standby</span><br><span class="line">[FW2-GigabitEthernet1/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>HRP配置(两台):</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW1</span><br><span class="line">[FW1] hrp enable</span><br><span class="line">HRP_S[FW1] hrp interface GigabitEthernet 0/0/0 remote 172.16.1.2   // 指定接口和对端IP</span><br><span class="line">HRP_M[FW1] interface GigabitEthernet 0/0/0                         // 选择虚拟接口</span><br><span class="line">HRP_M[FW1-GigabitEthernet0/0/0] ip address 172.16.1.1 24           // 配置本端IP地址</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 配置防火墙FW2</span><br><span class="line">[FW2] hrp enable</span><br><span class="line">HRP_S[FW2] hrp standby-device</span><br><span class="line">HRP_S[FW2] hrp interface GigabitEthernet 0/0/0 remote 172.16.1.1</span><br><span class="line">HRP_S[FW2] interface GigabitEthernet 0/0/0</span><br><span class="line">HRP_S[FW2-GigabitEthernet0/0/0] ip address 172.16.1.2 24</span><br></pre></td></tr></table></figure></p><p><strong>检查配置：</strong></p><p>注意1：默认处于 standby 状态的设备不允许配置安全策略，只允许在主设<br>备配置安全策略，且安全策略会自动同步到备设备上面。</p><p>开启命令：hrp standby config enable</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HRP_M[FW1] display hrp state</span><br><span class="line"> Role: active, peer: standby</span><br><span class="line"> Running priority: 45000, peer: 45000</span><br><span class="line"> Core state: normal, peer: normal</span><br><span class="line"> Backup channel usage: 0.00%</span><br><span class="line"> Stable time: 0 days, 0 hours, 0 minutes</span><br><span class="line"> Last state change information: 2019-05-06 1:37:41 HRP core state changed, old_s</span><br><span class="line">tate = abnormal(active), new_state = normal, local_priority = 45000, peer_priori</span><br><span class="line">ty = 45000.</span><br><span class="line"></span><br><span class="line">HRP_S[FW2] display hrp state</span><br><span class="line"> Role: standby, peer: active</span><br><span class="line"> Running priority: 45000, peer: 45000</span><br><span class="line"> Core state: normal, peer: normal</span><br><span class="line"> Backup channel usage: 0.00%</span><br><span class="line"> Stable time: 0 days, 0 hours, 1 minutes</span><br><span class="line"> Last state change information: 2019-05-06 1:37:42 HRP link changes to up.</span><br></pre></td></tr></table></figure><p><br></p><h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p><img src="/picture/20190508150335.jpg" alt="blockchain"></p><p><strong>配置防火墙接口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1]interface GigabitEthernet 1/0/0</span><br><span class="line">[FW1-GigabitEthernet1/0/0]ip address 192.168.1.1 24</span><br><span class="line">[FW1-GigabitEthernet1/0/0]service-manage ping permit </span><br><span class="line">[FW1-GigabitEthernet1/0/0]service-manage http permit</span><br><span class="line">[FW1-GigabitEthernet1/0/0]quit</span><br><span class="line"></span><br><span class="line">[FW1]interface GigabitEthernet 1/0/1</span><br><span class="line">[FW1-GigabitEthernet1/0/1]ip address 10.10.10.10 8</span><br><span class="line">[FW1-GigabitEthernet1/0/1]service-manage ping permit </span><br><span class="line">[FW1-GigabitEthernet1/0/1]service-manage http permit</span><br><span class="line">[FW1-GigabitEthernet1/0/1]quit</span><br></pre></td></tr></table></figure></p><p><strong>加入相应的区域内:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1]firewall zone trust</span><br><span class="line">[FW1-zone-trust]add interface  GigabitEthernet 1/0/0</span><br><span class="line">[FW1-zone-trust]quit</span><br><span class="line"></span><br><span class="line">[FW1]firewall zone untrust</span><br><span class="line">[FW1-zone-untrust]add interface GigabitEthernet 1/0/1</span><br><span class="line">[FW1-zone-untrust]quit</span><br></pre></td></tr></table></figure></p><p><strong>放行数据包:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1]security-policy</span><br><span class="line">[FW1-policy-security]rule name any_trust</span><br><span class="line">[FW1-policy-security-rule-any_trust]source-zone any</span><br><span class="line">[FW1-policy-security-rule-any_trust]destination-zone trust</span><br><span class="line"></span><br><span class="line">[FW1-policy-security-rule-any_trust]service http</span><br><span class="line">[FW1-policy-security-rule-any_trust]service icmp</span><br><span class="line">[FW1-policy-security-rule-any_trust]action permit</span><br></pre></td></tr></table></figure></p><p><strong>配置负载均衡:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[FW1] slb enable                                  // 启用SLB服务</span><br><span class="line">[FW1] slb                                         // 进入SLB配置视图</span><br><span class="line">[FW1-slb] group 1 WebServer                       // 创建服务器组webServer</span><br><span class="line">[FW1-slb-group-1] metric weight-least-connection  // 使用加权轮询算法</span><br><span class="line"></span><br><span class="line"># -------------------------------------------------------</span><br><span class="line">// 以下为真实服务设置   IP地址  端口 权重值 别名//</span><br><span class="line"></span><br><span class="line">[FW1-slb-group-1] rserver 1 rip 192.168.1.2 port 80 weight 1 description server1</span><br><span class="line">[FW1-slb-group-1] rserver 2 rip 192.168.1.3 port 80 weight 1 description server2</span><br><span class="line">[FW1-slb-group-1] rserver 3 rip 192.168.1.3 port 80 weight 1 description server3</span><br><span class="line">[FW1-slb-group-1]</span><br><span class="line">[FW1-slb-group-1] health-check type icmp tx-interval 5 times 3 // 配置服务健康检查参数  </span><br><span class="line">[FW1-slb-group-1] persistence type source-ip aging-time 180    // 配置会话保持时间</span><br><span class="line">[FW1-slb-group-1] quit                                         // 返回SLB视图</span><br><span class="line">[FW1-slb]</span><br><span class="line">[FW1-slb] vserver 1 WebServer            // 创建虚拟服务器WebServer</span><br><span class="line">[FW1-slb-vserver-1] protocol tcp         // 配置虚拟服务器的协议类型</span><br><span class="line">[FW1-slb-vserver-1] vip 1 10.10.10.100   // 设置虚拟服务器IP地址</span><br><span class="line">[FW1-slb-vserver-1] vport 80             // 设置虚拟服务器端</span><br><span class="line">[FW1-slb-vserver-1] group WebServer      // 关联真实服务器组</span><br><span class="line">[FW1-slb-vserver-1] quit                 // 返回SLB视图</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;防火墙（Firewall）也称防护墙，是由Check Point创立者Gil Shwed于1993年发明并引入国际互联网（US5606668（A）1993-12-15）防火墙是位于内部网和外部网之间的屏障，它按照系统管理员预先定义好的规则来控制数据包的进出。防火墙是系统的第一道防线，其作用是防止非法用户的进入。&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="huawei" scheme="https://localhost/tags/huawei/"/>
    
  </entry>
  
  <entry>
    <title>华为设备ACL与NAT技术</title>
    <link href="https://localhost/2019/04/10/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87ACL%E4%B8%8ENAT%E6%8A%80%E6%9C%AF/"/>
    <id>https://localhost/2019/04/10/网络设备配置/华为设备ACL与NAT技术/</id>
    <published>2019-04-10T01:33:47.000Z</published>
    <updated>2019-04-16T06:12:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>ACL 访问控制列表(Access Control Lists),是应用在路由器(或三层交换机)接口上的指令列表,用来告诉路由器哪些数据可以接收,哪些数据是需要被拒绝的,ACL的定义是基于协议的,它适用于所有的路由协议,并根据预先定义好的规则对数据包进行过滤,从而更好的控制数据的流入与流出.</p><p>NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.</p><a id="more"></a><p><br></p><h2 id="华为ACL访问控制"><a href="#华为ACL访问控制" class="headerlink" title="华为ACL访问控制"></a>华为ACL访问控制</h2><p>路由器接口的访问控制取决于应用在其上的ACL,数据在进出网络前,路由器会根据ACL对其进行匹配,匹配成功将对数据进行过滤或者是转发,匹配失败则丢弃数据包,目前主要有三种ACL控制,标准ACL,扩展ACL,命名ACL,我们只介绍前两种.</p><p>在路由器上应用ACL时,可以为每种协议,每个端口,每个方向,和每个接口,配置一个ACL,一般称为3p原则.</p><p><img src="/picture/20190410094952.jpg" alt="blockchain"></p><h3 id="◆标准ACL配置◆"><a href="#◆标准ACL配置◆" class="headerlink" title="◆标准ACL配置◆"></a>◆标准ACL配置◆</h3><p>标准ALCL只能通过源地址进行访问过滤与控制,因此只能阻止/允许来自指定IP地址的访问请求.</p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Eth0/0/0和Eth0/0/1端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.254 255.255.255.0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] quit</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] ip address 192.168.2.254 255.255.255.0</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置拒绝ACL规则:</strong> 这里我们在路由器上配置一条标准的ACL规则,<code>禁止PC1</code>访问<code>Server1</code>服务器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">[Huawei] acl 2000                                                 // 指定一个序号 2000-2999</span><br><span class="line">[Huawei-acl-basic-2000] rule deny source 192.168.1.1 0.0.0.0      // 拒绝源地址访问</span><br><span class="line">[Huawei-acl-basic-2000] rule deny source 192.168.1.1 0.0.0.255    // 拒绝整个网段</span><br><span class="line">[Huawei-acl-basic-2000] rule permit source 192.168.1.1 0.0.0.0    // 允许源地址访问</span><br><span class="line">[Huawei-acl-basic-2000] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] traffic-filter outbound acl 2000   // 在出口方向应用规则</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] traffic-filter inbound acl 2000    // 在入口方向应用规则</span><br></pre></td></tr></table></figure></p><p><strong>测试过滤效果:</strong> 配置完规则以后,我们测试一下效果,使用<code>PC1无法访问Server1服务器</code>而是用PC2则可以访问.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC1&gt; ping 192.168.2.1</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line"></span><br><span class="line">PC2&gt; ping 192.168.2.1</span><br><span class="line">From 192.168.2.1: bytes=32 seq=1 ttl=254 time=47 ms</span><br><span class="line">From 192.168.2.1: bytes=32 seq=1 ttl=254 time=47 ms</span><br></pre></td></tr></table></figure></p><p>这里需要注意一点,如果你有两个路由器相连,那么ACL规则应该设置在距离限制的目标较近的路由器上,否则可能会出现有效数据在到达目标之前就被过滤掉了.</p><h3 id="◆拓展ACL配置◆"><a href="#◆拓展ACL配置◆" class="headerlink" title="◆拓展ACL配置◆"></a>◆拓展ACL配置◆</h3><p>标准ACL只能使用源地址作为匹配条件,无法对访问进行精确的控制,为了解决这一问题,可以采用扩展ACL来对数据加以限制,接下来我们将配置扩展ACL,其拓扑结构图还是使用上图.</p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Eth0/0/0和Eth0/0/1端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] ip address 192.168.1.254 255.255.255.0</span><br><span class="line">[Huawei-GigabitEthernet0/0/0] quit</span><br><span class="line"></span><br><span class="line">[Huawei]interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] ip address 192.168.2.254 255.255.255.0</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置禁止ICMP:</strong> 禁止<code>192.168.1.1</code>访问<code>192.168.2.1</code>的<code>icmp</code>协议.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] acl 3000</span><br><span class="line">[Huawei-acl-adv-3000] rule deny icmp source 192.168.1.1 0 destination 192.168.2.1 0</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] traffic-filter outbound acl 3000</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[Huawei] display acl all</span><br><span class="line"> Total quantity of nonempty ACL number is 1 </span><br><span class="line"> rule 5 deny icmp source 192.168.1.1 0 destination 192.168.2.1 0 (27 matches)</span><br></pre></td></tr></table></figure></p><p><strong>禁止指定端口:</strong> 禁止<code>TCP协议</code>,的<code>源地址192.168.1.1</code>至<code>目标地址192.168.2.1</code>,端口号80的协议.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] acl 3000</span><br><span class="line">[Huawei-acl-3000] rule deny tcp source 192.168.1.1 0 destination 192.168.2.1 0 destination-port eq 80</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] traffic-filter outbound acl 3000</span><br><span class="line"></span><br><span class="line">[Huawei]display acl all</span><br><span class="line"> Total quantity of nonempty ACL number is 1 </span><br><span class="line"> rule 5 deny icmp source 192.168.1.1 0 destination 192.168.2.1 0 (27 matches)</span><br></pre></td></tr></table></figure></p><p><strong>测试过滤效果:</strong> 配置完规则以后,我们测试一下效果,使用<code>PC1无法访问Server1服务器</code>而是用PC2则可以访问.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC1&gt; ping 192.168.2.1</span><br><span class="line">Request timeout!</span><br><span class="line">Request timeout!</span><br><span class="line"></span><br><span class="line">PC2&gt; ping 192.168.2.1</span><br><span class="line">From 192.168.2.1: bytes=32 seq=1 ttl=254 time=47 ms</span><br><span class="line">From 192.168.2.1: bytes=32 seq=1 ttl=254 time=47 ms</span><br></pre></td></tr></table></figure></p><p>与标准ACL相比,扩展ACL能够更加精确的匹配和过滤数据包,因此扩展ACL的放置位置应该离源地址越近越好,这样才能够有效的提高链路的使用效率.<br><br></p><h2 id="华为NAT地址转换"><a href="#华为NAT地址转换" class="headerlink" title="华为NAT地址转换"></a>华为NAT地址转换</h2><p>NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.</p><p>NAT技术中有四种地址即,内部本地地址,内部全局地址,外部本地地址,外部全局地址.</p><h3 id="◆配置静态NAT◆"><a href="#◆配置静态NAT◆" class="headerlink" title="◆配置静态NAT◆"></a>◆配置静态NAT◆</h3><p>静态NAT是指将内部本地地址与内部全局地址进行对应转换,某个本地地址只能转换为某个全局地址,通过配置静态NAT可以实现内部网络对外部网络的访问,也可以实现外部网络对内部网络中某个设备的访问.</p><p><img src="/picture/20190410121854.jpg" alt="blockchain"></p><p><strong>配置路由器:</strong> 配置路由器,开启R1路由器的<code>Eth0/0/0</code>和<code>Ser0/0/0</code>端口,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置R1路由器-----------------------------</span><br><span class="line">&lt;R1&gt; system-view</span><br><span class="line">[R1] interface GigabitEthernet 0/0/0</span><br><span class="line">[R1-GigabitEthernet0/0/0] ip address 192.168.1.1 255.255.255.0</span><br><span class="line">[R1-Ethernet0/0/0] quit</span><br><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1] ip address 10.10.10.1 255.0.0.0</span><br><span class="line">[R1-Ethernet0/0/0] quit</span><br><span class="line"></span><br><span class="line"># ----配置R2路由器-----------------------------</span><br><span class="line">&lt;R2&gt; system-view</span><br><span class="line">[R2] interface GigabitEthernet 0/0/0</span><br><span class="line">[R2-GigabitEthernet0/0/0] ip address 10.10.10.2 255.0.0.0</span><br><span class="line">[R2-Ethernet0/0/0] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置静态NAT:</strong> 在路由器R1上配置静态NAT,将私有地址转为全局地址<code>(内网地址--&gt;外网地址)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat static enable   //启用静态nat</span><br><span class="line">[R1-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat static global 10.10.10.20 inside 192.168.1.2</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat static global 10.10.10.20 inside 192.168.1.2</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat static global 10.10.10.20 inside 192.168.1.2</span><br></pre></td></tr></table></figure></p><p><strong>查询NAT配置:</strong> 配置完成后,使用<code>display nat static 命令</code>可以查询端口情况.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] display nat static</span><br><span class="line"></span><br><span class="line">  Static Nat Information:</span><br><span class="line">  Interface  : GigabitEthernet0/0/1</span><br><span class="line">    Global IP/Port     : 10.10.10.20/---- </span><br><span class="line">    Inside IP/Port     : 192.168.1.2/----</span><br><span class="line">    Protocol : ----     </span><br><span class="line">    VPN instance-name  : ----                            </span><br><span class="line">    Acl number         : ----</span><br><span class="line">    Netmask  : 255.255.255.255 </span><br><span class="line">    Description : ----</span><br><span class="line"></span><br><span class="line">  Total :    1</span><br></pre></td></tr></table></figure></p><p><strong>测试通信情况:</strong> 此时在<code>PC1主机</code>可Ping通<code>R2路由器</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC1&gt; ping 10.10.10.2</span><br><span class="line"></span><br><span class="line">Ping 10.10.10.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 10.10.10.2: bytes=32 seq=1 ttl=254 time=47 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.10.2 ping statistics ---</span><br><span class="line">  1 packet(s) transmitted</span><br><span class="line">  1 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 47/47/47 ms</span><br></pre></td></tr></table></figure></p><h3 id="◆配置动态NAT◆"><a href="#◆配置动态NAT◆" class="headerlink" title="◆配置动态NAT◆"></a>◆配置动态NAT◆</h3><p>动态NAT是指内部本地地址与内部全局地址进行转换时,内部地址可以随机转换为指定的外部全局地址,此过程是动态分配的不需要认为干预,从而减少了配置的工作量.</p><p>但需要注意的是,配置动态NAT只能实现内部网络对互联网的访问,无法实现互联网中的主机对内部网络中的主机的访问,它是一种单向的NAT技术.</p><p>动态NAT是在出口路由器上做了一个地址池,内网PC访问外网时会从地址池内获取一个公网IP,此种技术也无法节约公网IP地址资源,接下来还是使用上面的拓扑图,但需要清空规则.</p><p><strong>配置路由器:</strong> 配置路由器,开启R1路由器的<code>Eth0/0/0</code>和<code>Ser0/0/0</code>端口,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置R1路由器-----------------------------</span><br><span class="line">&lt;R1&gt; system-view</span><br><span class="line">[R1] interface GigabitEthernet 0/0/0</span><br><span class="line">[R1-GigabitEthernet0/0/0] ip address 192.168.1.1 255.255.255.0</span><br><span class="line">[R1-Ethernet0/0/0] quit</span><br><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line">[R1-GigabitEthernet0/0/1] ip address 10.10.10.1 255.0.0.0</span><br><span class="line">[R1-Ethernet0/0/0] quit</span><br><span class="line"></span><br><span class="line"># ----配置R2路由器-----------------------------</span><br><span class="line">&lt;R2&gt; system-view</span><br><span class="line">[R2] interface GigabitEthernet 0/0/0</span><br><span class="line">[R2-GigabitEthernet0/0/0] ip address 10.10.10.2 255.0.0.0</span><br><span class="line">[R2-Ethernet0/0/0] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置动态NAT:</strong> 在路由器R1上配置动态NAT,将私有地址转为全局地址<code>(内网地址--&gt;外网地址)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] nat address-group 1 10.10.10.20 10.10.10.40                 // 创建公网地址池</span><br><span class="line">[R1] acl 2000                                                    // 定义访问控制列表</span><br><span class="line">[R1-acl-basic-2000] rule permit source 192.168.1.0 0.0.0.255     // 定义ACL列表</span><br><span class="line">[R1-acl-basic-2000] quit</span><br><span class="line"></span><br><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line"></span><br><span class="line">// 将ACL与地址池关联,no-pat表示不可反复使用</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat outbound 2000 address-group 1 no-pat</span><br><span class="line"></span><br><span class="line">// 将ACL与地址池关联,可反复使用</span><br><span class="line">[R1-GigabitEthernet0/0/1] nat outbound 2000 address-group 1</span><br></pre></td></tr></table></figure></p><p><strong>拓展(端口映射):</strong> 将内网的<code>192.168.1.1:8080</code>映射到外网的<code>10.10.10.1:80</code>,配置如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] interface GigabitEthernet 0/0/1</span><br><span class="line">[R1] nat server protocol tcp global 10.10.10.1 80 inside 192.168.1.1 8080</span><br></pre></td></tr></table></figure></p><p><strong>测试通信情况:</strong> 此时在<code>PC1主机</code>可Ping通<code>R2路由器</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC1&gt; ping 10.10.10.2</span><br><span class="line"></span><br><span class="line">Ping 10.10.10.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 10.10.10.2: bytes=32 seq=1 ttl=254 time=47 ms</span><br><span class="line"></span><br><span class="line">--- 10.10.10.2 ping statistics ---</span><br><span class="line">  1 packet(s) transmitted</span><br><span class="line">  1 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 47/47/47 ms</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ACL 访问控制列表(Access Control Lists),是应用在路由器(或三层交换机)接口上的指令列表,用来告诉路由器哪些数据可以接收,哪些数据是需要被拒绝的,ACL的定义是基于协议的,它适用于所有的路由协议,并根据预先定义好的规则对数据包进行过滤,从而更好的控制数据的流入与流出.&lt;/p&gt;
&lt;p&gt;NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="huawei" scheme="https://localhost/tags/huawei/"/>
    
  </entry>
  
  <entry>
    <title>华为路由器配置笔记</title>
    <link href="https://localhost/2019/04/09/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://localhost/2019/04/09/网络设备配置/华为路由器配置笔记/</id>
    <published>2019-04-09T01:30:12.000Z</published>
    <updated>2019-04-16T06:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>路由器(Router),是连接因特网中各局域网、广域网的设备,它会根据信道的情况自动选择和设定路由,以最佳路径,按前后顺序发送信号,路由器工作在网络层,用来跨网段通信,路由器具有判断网络地址和选择IP路径的功能,它能在多网络互联环境中,建立灵活的连接,可用完全不同的数据分组和介质访问方法连接各种子网,路由器只接受源站或其他路由器的信息,属网络层的一种互联设备,因此路由器是互联网中必不可少的网络设备之一.</p><a id="more"></a><p>路由器,其最重要的功能就是路由,路由是指路由器接收到数据时选择最佳路径将数据穿过网络传输到目标地址的行为,每个路由器负责自己的本地数据的路由或转发,通过多个路由器依次接力将数据最终传递到目标主机,路由的工作流程包括<code>路由选择</code>和<code>路由转发</code>两个方面.<br><br></p><h2 id="路由器基本配置"><a href="#路由器基本配置" class="headerlink" title="路由器基本配置"></a>路由器基本配置</h2><p>路由器与交换机不同,交换机不需要配置也可以正常工作,但是<code>路由器必须经过配置后才可以正常使用</code>,路由器的登陆方式基本和交换机保持一致,下面将用一个实例实现路由器的基本配置,包括配置路由器的主机名称,密码,控制台端口,WAN接口和LAN接口等,来实现一个基本的路由结构.</p><p>首先我们准备<code>两台路由器(Router)</code>,需要注意的是设备之间的连接所选用的线路类型,一般情况下<code>路由器和PC之间使用交叉线</code>,<code>两台路由器相连接使用串行线</code>,配置成以下拓扑结构即可:</p><p><img src="/picture/20190409121020.jpg" alt="blockchain"></p><p><strong>配置WAN接口:</strong> 路由器通过WAN接口接入到互联网上,而常见的WAN接口都是串行接口用<code>Serial</code>表示,如下将按照上图接口进行配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">&lt;R1&gt; system-view</span><br><span class="line">[R1] interface Serial 0/0/0                           // 选择外网接口</span><br><span class="line">[R1-Serial0/0/0]</span><br><span class="line">[R1-Serial0/0/0] ip address 10.10.10.10 255.255.255.0 // 配置外网地址</span><br><span class="line"></span><br><span class="line">#----在Router2上操作-------------------------</span><br><span class="line">&lt;R2&gt; system-view</span><br><span class="line">[R2] interface Serial 0/0/0</span><br><span class="line">[R2-Serial0/0/0]</span><br><span class="line">[R2-Serial0/0/0] ip address 10.10.10.20 255.255.255.0</span><br></pre></td></tr></table></figure></p><p><strong>配置LAN接口:</strong> LAN接口用来指定内网通讯的地址,接下来分别对两台路由器做配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">&lt;R1&gt; system-view</span><br><span class="line">[R1]interface Ethernet 0/0/0</span><br><span class="line">[R1-Ethernet0/0/0]</span><br><span class="line">[R1-Ethernet0/0/0] ip address 192.168.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">#----在Router2上操作-------------------------</span><br><span class="line">&lt;R2&gt; system-view</span><br><span class="line">[R2]interface Ethernet 0/0/0</span><br><span class="line">[R2-Ethernet0/0/0]</span><br><span class="line">[R2-Ethernet0/0/0]ip address 192.168.1.1 255.255.255.0</span><br></pre></td></tr></table></figure></p><p><strong>查看路由表:</strong> 最后可以使用<code>display ip routing-table</code>命令,查看路由器的路由信息,确定网络是否正确连接.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] display ip routing-table </span><br><span class="line">Route Flags: R - relay, D - download to fib</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">     10.10.10.0/24  Direct  0    0           D   10.10.10.10     Serial0/0/0</span><br><span class="line">    10.10.10.10/32  Direct  0    0           D   127.0.0.1       Serial0/0/0</span><br><span class="line">    10.10.10.20/32  Direct  0    0           D   10.10.10.20     Serial0/0/0</span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">    192.168.1.0/24  Direct  0    0           D   192.168.1.1     Ethernet0/0/0</span><br><span class="line">    192.168.1.1/32  Direct  0    0           D   127.0.0.1       Ethernet0/0/0</span><br></pre></td></tr></table></figure></p><p><strong>查接口信息:</strong> 也可以使用<code>display ip interface brief</code>命令,查看路由器的接口信息.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] display ip interface brief </span><br><span class="line"></span><br><span class="line">Interface                         IP Address/Mask      Physical   Protocol  </span><br><span class="line">Ethernet0/0/0                     192.168.1.1/24       up         up        </span><br><span class="line">Ethernet0/0/1                     unassigned           down       down      </span><br><span class="line">GigabitEthernet0/0/0              unassigned           down       down</span><br><span class="line">NULL0                             unassigned           up         up(s) </span><br><span class="line">Serial0/0/0                       10.10.10.10/24       up         up</span><br><span class="line">Serial0/0/1                       unassigned           down       down</span><br></pre></td></tr></table></figure></p><p><strong>最后测试通信:</strong> 在路由器<code>R1</code>上可以ping通<code>R2</code>,每个主机也可以ping通自己网段的路由器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] ping 10.10.10.20</span><br><span class="line">  PING 10.10.10.20: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 10.10.10.20: bytes=56 Sequence=1 ttl=255 time=30 ms</span><br><span class="line">    Reply from 10.10.10.20: bytes=56 Sequence=2 ttl=255 time=40 ms</span><br><span class="line">    Reply from 10.10.10.20: bytes=56 Sequence=3 ttl=255 time=70 ms</span><br><span class="line">    Reply from 10.10.10.20: bytes=56 Sequence=4 ttl=255 time=30 ms</span><br><span class="line">    Reply from 10.10.10.20: bytes=56 Sequence=5 ttl=255 time=30 ms</span><br></pre></td></tr></table></figure></p><p>上述小实验到这里就算配置成功了,但是这里留下了一个疑问,那就是<code>PC0</code>Ping<code>PC1</code>无法通信,这就涉及到<code>路由器没有相应的路由条目</code>的问题,这些问题将在后面小实验中做解释.<br><br></p><h2 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h2><p>静态路由需要管理员根据实际需求一条条自己手动配置,路由器不会自动生成所需的静态路由,静态路由中包括目标节点或目标网络的IP地址,还可以包括下一跳IP地址,以及在本路由器上使用该静态路由时的数据包出接口等,但是手动配置静态路由需要管理员非常了解网络的拓扑结构才能够完成配置,在网络规模较大时还需要耗费大量的经历和时间去维护,所以并不是所有的网络都适合配置静态路由.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 一般情况下以下几种情况可以考虑使用静态路由</p><blockquote><p>1.网络的拓扑结构相对较简单,比如就一台路由器和交换机的情况,可使用静态路由.<br>2.网络保密性要求较高,网络管理员需要控制链路或者控制路由表,则可使用静态路由.<br>3.网络仅通过单个ISP接入Internet,则该ISP就是网络唯一的出口,所以不需要配置静态路由.<br>4.路由资源有限,无法运行路由选择协议,在这种情况下,需要手动配置路由条目来更新路由表数据.</p></blockquote></blockquote><p>接下来以一个实例具体介绍静态路由的配置流程,在思科模拟器中选择3台<code>Router路由器</code>,按照以下网络拓扑结构构建网路,然后为每台路由器配置静态路由,实现不同网络间的数据互通.</p><p><img src="/picture/20190409151533.jpg" alt="blockchain"></p><p><strong>配置路由器:</strong> 根据以上拓扑图配置路由器,通过<code>ip address</code>给路由器的每个接口配置好IP地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Ethernet 0/0/0</span><br><span class="line">[Huawei-Ethernet0/0/0] ip address 192.168.1.1 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/0] quit</span><br><span class="line">[Huawei] interface Ethernet 0/0/1</span><br><span class="line">[Huawei-Ethernet0/0/1] ip address 10.10.10.1 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Ethernet 0/0/0</span><br><span class="line">[Huawei-Ethernet0/0/0] ip address 10.10.10.2 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/0] quit</span><br><span class="line">[Huawei] interface Ethernet 0/0/1</span><br><span class="line">[Huawei-Ethernet0/0/1] ip address 20.20.20.2 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R3上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Ethernet 0/0/0</span><br><span class="line">[Huawei-Ethernet0/0/0] ip address 192.168.2.1 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/0] quit</span><br><span class="line">[Huawei] interface Ethernet 0/0/1</span><br><span class="line">[Huawei-Ethernet0/0/1] ip address 20.20.20.3 255.255.255.0</span><br><span class="line">[Huawei-Ethernet0/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>检查配置结果:</strong> 配置完路由器的IP地址后,我们在每个路由器上测试相邻的接口是否可连通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] ping 10.10.10.2</span><br><span class="line">  PING 10.10.10.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 10.10.10.2: bytes=56 Sequence=1 ttl=255 time=130 ms</span><br><span class="line"></span><br><span class="line">[R2] ping 20.20.20.3</span><br><span class="line">  PING 20.20.20.3: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 20.20.20.3: bytes=56 Sequence=1 ttl=255 time=110 ms</span><br></pre></td></tr></table></figure></p><p><strong>配置静态路由:</strong> 接下来我们需要在两台路由器上分别配置路由条目,使用<code>ip route-static命令</code>配置,如果想要删除路由可使用<code>undo ip route命令</code>即可删除指定路由条目.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">                            [目的网络]   [目的掩码]     [下一跳地址]</span><br><span class="line">[Huawei] ip route-static   192.168.2.0  255.255.255.0   10.10.10.2</span><br><span class="line">[Huawei] display ip routing-table</span><br><span class="line"></span><br><span class="line">#----在R2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.2.0 255.255.255.0 20.20.20.3</span><br><span class="line">[Huawei] ip route-static 192.168.1.0 255.255.255.0 10.10.10.1</span><br><span class="line">[Huawei] display ip routing-table</span><br><span class="line"></span><br><span class="line">#----在R1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.1.0 255.255.255.0 20.20.20.2</span><br><span class="line">[Huawei] display ip routing-table</span><br></pre></td></tr></table></figure></p><p><strong>测试阶段:</strong> 最后在主机<code>PC1</code>上面Ping测试<code>PC2</code>发现数据包可以正常的传递.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC1&gt; ping 192.168.2.2 -t</span><br><span class="line"></span><br><span class="line">Ping 192.168.2.2: 32 data bytes, Press Ctrl_C to break</span><br><span class="line">From 192.168.2.2: bytes=32 seq=1 ttl=125 time=125 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.2.2 ping statistics ---</span><br><span class="line">  1 packet(s) transmitted</span><br><span class="line">  1 packet(s) received</span><br><span class="line">  0.00% packet loss</span><br><span class="line">  round-trip min/avg/max = 125/125/125 ms</span><br></pre></td></tr></table></figure></p><p>以上的路由配置方法,适用于小型网络环境,在大型网络环境中这种静态路由的配置方式很不适合维护,一旦设备过多,则可能自己都搞不清头绪,所以在生产环境中,我们会使用动态路由的方式来实现路由器的配置,接下来继续学习动态路由的配置方式吧.<br><br></p><h2 id="RIP-动态路由"><a href="#RIP-动态路由" class="headerlink" title="RIP 动态路由"></a>RIP 动态路由</h2><p>动态路由是基于某种协议实现的,常见的路由协议有内<code>内部网关协议(IGP)</code>和<code>边界网关协议(BGP)</code>,其中内部网关协议又分为<code>路由信息协议(RIP)</code>和<code>开放式最短路径优先协议(OSPF)协议</code>.</p><p>其中<code>RIP(路由信息协议)</code>是最先被广泛应用的内部网关路由协议,RIP使用跳数来衡量到达目标地址的距离,跳数是指数据从源地址到达目标地址之间经过的路由器个数.从路由器到直接连接的网络的跳数定义为1,每经过一个路由器则数值会增加1,RIP允许的<code>最大跳数是15跳</code>,超过15跳的网络将无法到达,因此RIP适合用于小型的网络环境中.</p><p>RIP协议默认会<code>每隔30秒</code>就会与其他相连的网络广播自己的路由表,收到广播的路由器会将收到的信息与自己路由表进行比较,判断是否将其中的路由条目加入到自己的路由表中,目前RIP共有3中版本,<code>RIPv1,RIPv2,RIPng</code>,其中RIPng应用于IPv6网络环境中,RIPv1是有类路由协议,RIPv2则是无类路由协议.</p><p><img src="/picture/20190409193556.jpg" alt="blockchain"></p><p><strong>配置路由器:</strong> 首先根据上图将四台路由器的IP地址配置在相应的接口上.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.10.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line"></span><br><span class="line">#----在R2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.10.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line">[Huawei] interface Serial 0/0/1</span><br><span class="line">[Huawei-Serial0/0/1] ip address 192.168.20.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R3上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.20.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line">[Huawei] interface Serial 0/0/1</span><br><span class="line">[Huawei-Serial0/0/1] ip address 192.168.30.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R4上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.30.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置并启用RIP路由:</strong> 接着我们分别在每台路由器上启用并配置好<code>RIP动态路由</code>,并指定直连网络号.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上启用RIP路由协议并配置-------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] rip 1                         // 启动RIP进程1</span><br><span class="line">[Huawei-rip-1] version 2              // 指定使用RIP版本为RIPv2</span><br><span class="line">[Huawei-rip-1] network 192.168.10.0   // 声明与R1直连的网络号</span><br><span class="line">[Huawei-rip-1] quit</span><br><span class="line"></span><br><span class="line">#----在R2上启用RIP路由协议并配置-------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] rip 1                        // 启动RIP进程1</span><br><span class="line">[Huawei-rip-1] version 2              // 指定使用RIP版本为RIPv2</span><br><span class="line">[Huawei-rip-1] network 192.168.10.0   // 声明与R2直连的网络号</span><br><span class="line">[Huawei-rip-1] network 192.168.20.0   // 声明与R3直连的网络号</span><br><span class="line">[Huawei-rip-1] quit</span><br><span class="line"></span><br><span class="line">#----在R3上启用RIP路由协议并配置-------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] rip 1                        // 启动RIP进程1</span><br><span class="line">[Huawei-rip-1] version 2              // 指定使用RIP版本为RIPv2</span><br><span class="line">[Huawei-rip-1] network 192.168.20.0   // 声明与R3直连的网络号</span><br><span class="line">[Huawei-rip-1] network 192.168.30.0   // 声明与R4直连的网络号</span><br><span class="line">[Huawei-rip-1] quit</span><br><span class="line"></span><br><span class="line">#----在R4上启用RIP路由协议并配置-------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] rip 1                         // 启动RIP进程1</span><br><span class="line">[Huawei-rip-1] version 2              // 指定使用RIP版本为RIPv2</span><br><span class="line">[Huawei-rip-1] network 192.168.30.0   // 声明与R4直连的网络号</span><br><span class="line">[Huawei-rip-1] quit</span><br></pre></td></tr></table></figure></p><p><strong>检查配置信息:</strong> 配置完成后RIP会自动生成路由条目,可执行<code>display ip routing-table</code>查询配置结果.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] display ip routing-table</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.10.0/24  Direct  0    0           D   192.168.10.2    Serial0/0/0</span><br><span class="line">   192.168.10.1/32  Direct  0    0           D   192.168.10.1    Serial0/0/0</span><br><span class="line">   192.168.10.2/32  Direct  0    0           D   127.0.0.1       Serial0/0/0</span><br><span class="line">   192.168.20.0/24  Direct  0    0           D   192.168.20.1    Serial0/0/1</span><br><span class="line">   192.168.20.1/32  Direct  0    0           D   127.0.0.1       Serial0/0/1</span><br><span class="line">   192.168.20.2/32  Direct  0    0           D   192.168.20.2    Serial0/0/1</span><br><span class="line">   192.168.30.0/24  RIP     100  1           D   192.168.20.2    Serial0/0/1</span><br></pre></td></tr></table></figure></p><p><strong>测试连通性:</strong> 此时我们在<code>R1路由器</code>Ping<code>路由器R4</code>是可以通信的,说明配置成功了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] ping 192.168.30.2</span><br><span class="line">  PING 192.168.30.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 192.168.30.2: bytes=56 Sequence=1 ttl=253 time=100 ms</span><br><span class="line">    Reply from 192.168.30.2: bytes=56 Sequence=2 ttl=253 time=80 ms</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="OSPF-动态路由"><a href="#OSPF-动态路由" class="headerlink" title="OSPF 动态路由"></a>OSPF 动态路由</h2><p>在上面的配置试验中我们通过使用<code>RIP协议</code>完成了一个路由器之间的数据通信,但是RIP协议最大仅仅支持15个路由节点,虽然在中小型网络中这些节点足够使用了,但是在一些大型企业中往往需更多的跳数,就是因为这种需求我们的<code>OSPF协议</code>就由此诞生啦.</p><p><code>OSPF(开放式最短路径优先)</code>,该协议是基于链路状态的协议规范,因此也可以称为<code>链路状态协议</code>,和RIP协议相同,OSPF协议<code>同样使用跳数</code>计量路径开销,但是与RIP不同的是,OSPF协议不受物理跳数的限制,其路径开销与网络中的链路开销等相关.</p><p>OSPF协议采用了<code>FPS算法</code>来计算最短路径数,SPF算法将每一个路由作为<code>根(ROOT)</code>,来计算其数据包到达每一个目标路由器之间的距离,每个路由器根据一个<code>统一的数据库LSDB</code>计算出<code>路由域</code>的拓扑结构图,该结构很像是一颗树,所以就叫做最短路径树.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> OSPF协议的优点</p><blockquote><p>1.OSPF采用了SPF算法,从而可以很好的避免路由器环路的产生.<br>2.OSPF协议虽然也使用跳数作为计量单位,但不受物理跳数的限制.<br>3.当网络链路状态发生变化时,OSPF能够迅速捕捉并应用,收敛快,路由信息流量小.<br>4.OSPF路由协议支持路由认证体系,且还可以定义不同的认证方式,提高了网络安全性.<br>5.OSPF协议提供了较好的负载均衡性,其数据更新比较智能,相应的减小了网络流量的带宽.</p></blockquote></blockquote><p>在配置OSPF路由之前还有一个小知识点需要补充,在下面的配置试验中你会看到例如<code>0.0.0.255</code>这样的网络号,这种网络号被称作<code>通配符掩码</code>,通常情况下通配符掩码可由,<code>255.255.255.255(广播地址)</code>减去当前的<code>255.255.255.0(子网掩码)</code>,来获得,此处小实验的通配符掩码为<code>0.0.0.255 area 0</code>.</p><p>接下来开始步入正题,我们还是<code>使用RIP路由的拓扑结构</code>以<code>及IP地址</code>的配置都相同,但是这里在配置动态路由的时候,我们使用OSPF的方式来配置,过程如下:</p><p><strong>配置路由器:</strong> 首先根据上图将四台路由器的IP地址配置在相应的接口上.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.10.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line"></span><br><span class="line">#----在R2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.10.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line">[Huawei] interface Serial 0/0/1</span><br><span class="line">[Huawei-Serial0/0/1] ip address 192.168.20.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R3上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.20.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br><span class="line">[Huawei] interface Serial 0/0/1</span><br><span class="line">[Huawei-Serial0/0/1] ip address 192.168.30.1 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----在R4上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Serial 0/0/0</span><br><span class="line">[Huawei-Serial0/0/0] ip address 192.168.30.2 255.255.255.0</span><br><span class="line">[Huawei-Serial0/0/0] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置并启用OSPF路由:</strong> 在每台路由器上启用并配置好OSPF动态路由.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在R1上启用OSPF路由协议并配置-------------------</span><br><span class="line">[Huawei] ospf 1                                              // 启用OSPF路由,并设置进程号为1</span><br><span class="line">[Huawei-ospf-1] area 0.0.0.0                                 // 为R1配置RID编号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0]</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.10.0 0.0.0.255  // 声明与R1直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] quit</span><br><span class="line"></span><br><span class="line">#----在R2上启用OSPF路由协议并配置-------------------</span><br><span class="line">[Huawei] ospf 1                                              // 启用OSPF路由,并设置进程号为1</span><br><span class="line">[Huawei-ospf-1] area 0.0.0.0                                 // 为R2-R3配置RID编号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0]</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.10.0 0.0.0.255  // 声明与R2直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.20.0 0.0.0.255  // 声明与R3直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] quit</span><br><span class="line"></span><br><span class="line">#----在R3上启用OSPF路由协议并配置-------------------</span><br><span class="line">[Huawei] ospf 1                                              // 启用OSPF路由,并设置进程号为1</span><br><span class="line">[Huawei-ospf-1] area 0.0.0.0                                 // 为R3-R4配置RID编号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0]</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.20.0 0.0.0.255  // 声明与R3直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.30.0 0.0.0.255  // 声明与R4直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] quit</span><br><span class="line"></span><br><span class="line">#----在R4上启用OSPF路由协议并配置-------------------</span><br><span class="line">[Huawei] ospf 1                                              // 启用OSPF路由,并设置进程号为1</span><br><span class="line">[Huawei-ospf-1] area 0.0.0.0                                 // 为R1配置RID编号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0]</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] network 192.168.30.0 0.0.0.255  // 声明与R4直连的网络号</span><br><span class="line">[Huawei-ospf-1-area-0.0.0.0] quit</span><br></pre></td></tr></table></figure></p><p><strong>检查配置信息:</strong> 配置完成后RIP会自动生成路由条目,可执行<code>display ip routing-table</code>查询配置结果.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] display ip routing-table </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface</span><br><span class="line"></span><br><span class="line">      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0</span><br><span class="line">   192.168.10.0/24  Direct  0    0           D   192.168.10.2    Serial0/0/0</span><br><span class="line">   192.168.10.1/32  Direct  0    0           D   192.168.10.1    Serial0/0/0</span><br><span class="line">   192.168.10.2/32  Direct  0    0           D   127.0.0.1       Serial0/0/0</span><br><span class="line">   192.168.20.0/24  Direct  0    0           D   192.168.20.1    Serial0/0/1</span><br><span class="line">   192.168.20.1/32  Direct  0    0           D   127.0.0.1       Serial0/0/1</span><br><span class="line">   192.168.20.2/32  Direct  0    0           D   192.168.20.2    Serial0/0/1</span><br><span class="line">   192.168.30.0/24  OSPF    10   3124        D   192.168.20.2    Serial0/0/1</span><br></pre></td></tr></table></figure></p><p><strong>测试连通性:</strong> 此时我们在<code>R1路由器</code>Ping<code>路由器R4</code>是可以通信的,说明配置成功了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[R1] ping 192.168.30.2</span><br><span class="line">  PING 192.168.30.2: 56  data bytes, press CTRL_C to break</span><br><span class="line">    Reply from 192.168.30.2: bytes=56 Sequence=1 ttl=253 time=100 ms</span><br><span class="line">    Reply from 192.168.30.2: bytes=56 Sequence=2 ttl=253 time=80 ms</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由器(Router),是连接因特网中各局域网、广域网的设备,它会根据信道的情况自动选择和设定路由,以最佳路径,按前后顺序发送信号,路由器工作在网络层,用来跨网段通信,路由器具有判断网络地址和选择IP路径的功能,它能在多网络互联环境中,建立灵活的连接,可用完全不同的数据分组和介质访问方法连接各种子网,路由器只接受源站或其他路由器的信息,属网络层的一种互联设备,因此路由器是互联网中必不可少的网络设备之一.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="huawei" scheme="https://localhost/tags/huawei/"/>
    
  </entry>
  
  <entry>
    <title>华为生成树与端口聚合</title>
    <link href="https://localhost/2019/04/06/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E5%8D%8E%E4%B8%BA%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%81%9A%E5%90%88/"/>
    <id>https://localhost/2019/04/06/网络设备配置/华为生成树与端口聚合/</id>
    <published>2019-04-06T07:54:13.000Z</published>
    <updated>2019-04-16T06:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.</p><a id="more"></a><p><br></p><h2 id="STP-技术简介"><a href="#STP-技术简介" class="headerlink" title="STP 技术简介"></a>STP 技术简介</h2><h3 id="◆冗余技术概述◆"><a href="#◆冗余技术概述◆" class="headerlink" title="◆冗余技术概述◆"></a>◆冗余技术概述◆</h3><p>冗余技术又称为储备技术,是利用并联模型来提高网络可靠性的一种手段,它通过向网络中增加备用的链路,当一条通信信道出现故障时,自动切换到备用的通信信道,从而提高网络的稳定性和可靠性.</p><p>冗余技术虽然可以提高网络的稳定性和可靠性,但是也会产生许多的问题,如果两个交换机相连的话会造成交换机环路,出现的问题就是随机出现网络不通的现象,严重的话还会导致网络广播风暴,重复拷贝帧,MAC地址表不稳地等情况,但如果是智能交换机的话则不会出现此种情况,以下将分别介绍这几种环路的基本原理.</p><p><strong>广播风暴:</strong> 在物理网络中出现环路现象,且没有采取解决措施的情况下,一旦域内有某个主机发送了广播帧,则当域内的交换机接收到数据后,就会不停的发送和转发广播帧,从而形成网络广播风暴,网络广播风暴会长时间占用网络带宽,和交换机CPU资源,影响网络性能,甚至引起整个网络瘫痪.</p><p><strong>重复拷贝帧:</strong> 重复拷贝帧也称多帧复制,是指单播帧可能被多次复制传送到目标主机上去,此时数据帧的多个副本会保存在目标主机上,从而造成主机资源的浪费,甚至会造成目的主机无法选择其他来源的数据帧而导致数据丢失,简单的来讲就是数据分别从两个口进入了目的主机,导致目的主机MAC地址表中存在多个数据帧,有时还会导致数据的多次覆盖,从而无法接收到准确的数据.</p><p><strong>MAC地址表不稳定:</strong> 一般情况下交换机接收到数据时,会将接收数据帧的端口与发送主机MAC地址的对应关系添加到本机的MAC地址表中,那么如果交换机在不同的端口接收到同一个数据帧的多份副本,将造成MAC地址表在短时间内被多次修改,和循环重复的覆盖,从而影响MAC地址表的稳定性.</p><p>以上几种情况是冗余技术的技术瓶颈所在,在实际的应用中网络的结构往往会很复杂,有更多的冗余链路,从而会产生更多的交换机环路,因此所带来的网络广播风暴,多帧复制会更加的严重,就因为这种需求,STP就由此诞生了.</p><h3 id="◆STP生成树协议◆"><a href="#◆STP生成树协议◆" class="headerlink" title="◆STP生成树协议◆"></a>◆STP生成树协议◆</h3><p>为了解决网络冗余链路所产生的问题,IEEE定义了802.1D协议,即生成树协议STP,利用生成树协议可以避免帧在环路中的增生和无限循环,生成树的主要思想是,当两个交换机之间存在多条链路时,通过一定的算法只激活其中最主要的一条链路,而将其他冗余链路阻塞掉变为备用链路,当主链路出现问题时,生成树协议将自动启用备用链路,整个过程不需要认为干预.</p><p>STP协议中定义了,根桥(RootBridge),根端口(Root Port),指定端口(Designated Port),路径开销(Path Cost)等概念,目的在于通过构建一棵自然树的方法阻塞冗余链路,同时实现链路备份和链路最优化.</p><p>STP协议的通信,是通过桥协议数据单元(BPDU)进行通信的,它是运行STP的交换机之间交流消息帧,所有的支持STP协议的交换机都能接收并处理BPDU报文.</p><blockquote><p><strong>STP工作过程:</strong> 选举根桥-&gt;选举根端口-&gt;选举指定端口-&gt;STP阻塞非根</p><blockquote><p>1.选举根桥:交换机假定自己是根,然后发送BPDU报文给其他交换机,最终选出ID号最小的交换机作为根桥.<br>2.选举根端口:每台非根交换机都会选举出一个根端口,并且仅有一个根端口,并按照优先级选择一个根端口.<br>3.选举指定端口:选择一条网桥到根桥的路径成本最小的路径,或者发送方的网桥ID最大的作为指定端口.<br>4.选择阻塞端口:至此,就会根据STP算法,从多个链路中选择性的阻塞掉一些端口的数据通信.</p></blockquote></blockquote><blockquote><p><strong>STP端口状态:</strong></p><blockquote><p>1.阻塞(Blocking):端口只接受BPDU,不能接收或发送数据,也不能把学习到的MAC地址天机到MAC地址表中.<br>2.转发(Forwarding):端口能够接收并转发数据,也能够学习MAC地址,并添加到MAC地址表中.<br>3.侦听(Listening):该状态是从阻塞到转发状态过程中的临时状态,该状态只能发送和接受BPDU数据.<br>4.学习(Learning):该状态是从阻塞到转发状态过程中的临时状态,该状态不能够发送或接收数据.<br>5.关闭(Disable):该状态端口只提供网络管理服务,不能接受发送任何数据,也就是停止服务的状态.</p></blockquote></blockquote><h3 id="◆RSTP-快速生成树◆"><a href="#◆RSTP-快速生成树◆" class="headerlink" title="◆RSTP 快速生成树◆"></a>◆RSTP 快速生成树◆</h3><p>STP协议虽然解决了链路闭合引起的死循环问题,但是在端口从阻塞状态到转发状态间经过了一个只学习MAC地址但不参与转发的过程,产生了转发延时(默认15秒),从而使得生成树的收敛过程需要较长的时间,一般是转发延时的两倍.</p><p>为了解决STP收敛时间过长的缺点,IEEE又推出了802.1w标准,定义了<code>RSTP(快速生成树)</code>协议.RSTP协议在网络配置参数发生变化时,能够显著的减少网络的收敛时间,由于RSTP是从STP发展而来的,其与STP协议保持高度的兼容性,RSTP协议规定,在某些情况下,处于阻塞状态的端口不必经历<code>阻塞-&gt;侦听-&gt;学习-&gt;转发</code>这一个过程,就可以直接进入转发状态.</p><blockquote><p><strong>RSTP协议只有以下三种:</strong></p><blockquote><p>1.丢弃(Discarding):RSTP将STP中的阻塞,禁用,和侦听统称为丢弃模式.<br>2.学习(Learning):拓扑有所变动情况下,端口处于学习状态并学习MAC地址,将其添加到MAC地址表.<br>3.转发(Forwarding):在网络拓扑稳定后,端口处于转发状态,并开始转发数据包.</p></blockquote></blockquote><p>以上就是生成树协议的常用内容,对比后会发现,RSTP的收敛时间明显低于STP,解决了数据同步过慢的问题所在.<br><br></p><h2 id="生成树的配置"><a href="#生成树的配置" class="headerlink" title="生成树的配置"></a>生成树的配置</h2><p>接下来通过一个具体的实例,来完成生成树的配置命令和配置流程的实践,以下实验我们将把<code>LSW1(三层交换)</code>配置成根桥,将<code>LSW2(二层交换)</code>配置为备份根桥,实验拓扑结构如下图:</p><p><img src="/picture/20190408095242.jpg" alt="blockchain"></p><p><strong>判断根桥:</strong> 首先我们需要判断当前的根桥是哪一个设备,我们分别在四台交换机上执行<code>display stp</code>命令或者执行<code>display stp brief</code>命令,来查询默认那一台是根桥设备,以下根据查询到的结果可以知道,<code>32768.4c1f-cc07-18c4</code>的MAC地址为根桥设备.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LSW1&gt; display stp                                              // 判断根桥命令</span><br><span class="line">&lt;LSW2&gt; display stp</span><br><span class="line">&lt;LSW3&gt; display stp</span><br><span class="line">&lt;LSW4&gt; display stp</span><br><span class="line">-------[CIST Global Info][Mode MSTP]-------</span><br><span class="line">CIST Bridge         :32768.4c1f-cc25-08bd                         // 本机优先级</span><br><span class="line">Config Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20      // 数据包发送时间</span><br><span class="line">Active Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20</span><br><span class="line">CIST Root/ERPC      :32768.4c1f-cc07-18c4 / 20000                 // 根桥MAC地址</span><br><span class="line">CIST RegRoot/IRPC   :32768.4c1f-cc25-08bd / 0                     // 备份根桥MAC地址</span><br><span class="line"></span><br><span class="line">&lt;LSW1&gt; display stp brief                                          // 查询接口状态</span><br><span class="line"> MSTID  Port                        Role  STP State     Protection</span><br><span class="line">   0    GigabitEthernet0/0/1        DESI  FORWARDING      NONE</span><br><span class="line">   0    GigabitEthernet0/0/2        ROOT  FORWARDING      NONE</span><br></pre></td></tr></table></figure></p><p><strong>指定根桥:</strong> 我们想让<code>LSW1(三层交换)</code>作为根桥设备,此时可在三层交换机上,直接通过以下命令,更换根桥设备.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LSW1&gt; system-view</span><br><span class="line">[LSW1] stp root primary</span><br><span class="line">[LSW1] display stp</span><br><span class="line">-------[CIST Global Info][Mode MSTP]-------</span><br><span class="line">CIST Bridge         :0    .4c1f-cc25-08bd                       // 本机桥ID</span><br><span class="line">Config Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20</span><br><span class="line">Active Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20</span><br><span class="line">CIST Root/ERPC      :0    .4c1f-cc25-08bd / 0                   // 根桥ID</span><br><span class="line">CIST RegRoot/IRPC   :0    .4c1f-cc25-08bd / 0</span><br></pre></td></tr></table></figure></p><p><strong>指定备份根桥:</strong> 接下来将<code>LSW2(二层交换)</code>指定为备份根桥,当<code>LSW1(三层交换)</code>出现故障后,<code>LSW2(二层交换)</code>将被选举为根桥设备,从而保证网络的正常运转,修改方式通过以下命令即可实现.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LSW2&gt; system-view</span><br><span class="line">[LSW2] stp root secondary</span><br><span class="line"></span><br><span class="line">[LSW2] display stp</span><br><span class="line">-------[CIST Global Info][Mode MSTP]-------</span><br><span class="line">CIST Bridge         :4096 .4c1f-cc45-2199</span><br><span class="line">Config Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20</span><br><span class="line">Active Times        :Hello 2s MaxAge 20s FwDly 15s MaxHop 20</span><br><span class="line">CIST Root/ERPC      :0    .4c1f-cc25-08bd / 200000            // 根桥MAC地址</span><br><span class="line">CIST RegRoot/IRPC   :4096 .4c1f-cc45-2199 / 0                 // 备份根桥MAC地址</span><br><span class="line">CIST RootPortId     :128.1</span><br></pre></td></tr></table></figure></p><p>此时配置到这里,我们可以手动关闭<code>LSW1(三层交换)</code>,然后去查看<code>LSW2(二层交换)</code>,通过<code>display stp</code>命令,你会发现当三层交换机关机的时候,二层交换机默认变成了根桥,顶替了<code>LSW1(三层交换)</code>的工作,当<code>LSW1(三层交换)</code>启动后,默认会将<code>LSW1(三层交换)</code>再次恢复成根桥.<br><br></p><h2 id="配置端口聚合"><a href="#配置端口聚合" class="headerlink" title="配置端口聚合"></a>配置端口聚合</h2><p>在我们的实际生产环境中,常常将交换机之间用多条链路连接起来,以获得更高的传输能力和网络性能,但根据之前的生成树协议,当交换机之间有冗余链路时,实际工作的链路只有一条,也就是说生成树协议阻碍了网络传输能力的提高.</p><p>为了解决生成树协议的传输能力的不足,出现了一种名为<code>端口聚合</code>的技术,它将多条物理链路组合成一条逻辑线路,实现链路带宽的增加,且还具有冗余作用,当其中部分链路出现故障时,其他链路还可以继续传输数据.</p><blockquote><p>但是并不是所有的端口都可以任意聚合,端口聚合需要满足以下条件.</p><blockquote><p>1.聚合的端口配置需要相同,包括端口速率和传输介质等.<br>2.聚合的端口必须属于同一个VLAN,也就是不许再一个虚拟局域网中.<br>3.聚合的端口类型必须相同,二层端口只能二层聚合,三层端口只能三层聚合.</p></blockquote></blockquote><p>端口聚合形成的逻辑端口称为<code>聚合端口</code>,端口聚合后原来端口的属性就会被聚合端口的属性所覆盖,也不能在源端口上做任何配置,实现端口聚合后,即使网络链路出现故障,只要不是所有链路都故障,网络还是可以继续运行的,只不过网络传输速度会降低而已.</p><p>下面将用一个具体的实例讲解端口聚合的配置方法和配置过程,包括创建聚合端口,配置聚合端口的工作方式和配置负载平衡,首先分别创建<code>两个三层交换机</code>,并通过网线<code>Gig 0/0/1-3</code>三条冗余链路相连接,拓扑图如下:</p><p><img src="/picture/20190408120823.jpg" alt="blockchain"></p><p><strong>创建聚合端口:</strong> 在两台交换机上创建<code>Eth-Trunk接口</code>并加入成员接口,配置如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在LSW1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname LSW1                                         // 重命名交换机</span><br><span class="line">[LSW1] interface Eth-Trunk 1                                  // 配置聚合号</span><br><span class="line">[LSW1-Eth-Trunk1] trunkport GigabitEthernet 0/0/1 to 0/0/3    // 选择1-3号端口</span><br><span class="line">[LSW1-Eth-Trunk1] quit</span><br><span class="line"></span><br><span class="line">#----在LSW2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname LSW2</span><br><span class="line">[LSW2] interface Eth-Trunk 1</span><br><span class="line">[LSW2-Eth-Trunk1] trunkport GigabitEthernet 0/0/1 to 0/0/3</span><br><span class="line">[LSW2-Eth-Trunk1] quit</span><br></pre></td></tr></table></figure></p><p><strong>创建VLAN:</strong> 在两台交换机上分别创建<code>VLAN10</code>和<code>VLAN20</code>并将主机加入到相应的虚拟局域网内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在LSW1上操作-------------------------</span><br><span class="line">[LSW1] vlan batch 10 20                                        // 创建VLAN10与20</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/4                         // 选择Gig0/0/4端口</span><br><span class="line">[LSW1-GigabitEthernet0/0/4] port link-type trunk               // 配置成trunk</span><br><span class="line">[LSW1-GigabitEthernet0/0/4] port trunk allow-pass vlan 10      // 应用到vlan10</span><br><span class="line">[LSW1-GigabitEthernet0/0/4] quit</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/5</span><br><span class="line">[LSW1-GigabitEthernet0/0/5] port link-type trunk</span><br><span class="line">[LSW1-GigabitEthernet0/0/5] port trunk allow-pass vlan 20</span><br><span class="line">[LSW1-GigabitEthernet0/0/5] quit</span><br><span class="line"></span><br><span class="line">#----在LSW2上操作-------------------------</span><br><span class="line">[LSW2] vlan batch 10 20</span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/4</span><br><span class="line">[LSW2-GigabitEthernet0/0/4] port link-type trunk</span><br><span class="line">[LSW2-GigabitEthernet0/0/4] port trunk allow-pass vlan 10</span><br><span class="line">[LSW2-GigabitEthernet0/0/4] quit</span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/5</span><br><span class="line">[LSW2-GigabitEthernet0/0/5] port link-type trunk</span><br><span class="line">[LSW2-GigabitEthernet0/0/5] port trunk allow-pass vlan 20</span><br><span class="line">[LSW2-GigabitEthernet0/0/5] quit</span><br></pre></td></tr></table></figure></p><p><strong>配置端口聚合:</strong> 配置<code>Eth-Trunk1</code>接口允许<code>VLAN10和VLAN20</code>通过,两台交换机都需要配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在LSW1上操作-------------------------</span><br><span class="line">[LSW1] interface Eth-Trunk 1</span><br><span class="line">[LSW1-Eth-Trunk1] port link-type trunk                   // 将接口设置为trunk</span><br><span class="line">[LSW1-Eth-Trunk1] port trunk allow-pass vlan 10 20       // 配置允许的VLAN</span><br><span class="line">[LSW1-Eth-Trunk1] load-balance src-dst-mac               // 配置负载平衡方式</span><br><span class="line"></span><br><span class="line">#----在LSW2上操作-------------------------</span><br><span class="line">[LSW2] interface Eth-Trunk 1</span><br><span class="line">[LSW2-Eth-Trunk1] port link-type trunk</span><br><span class="line">[LSW2-Eth-Trunk1] port trunk allow-pass vlan 10 20</span><br><span class="line">[LSW2-Eth-Trunk1] load-balance src-dst-mac</span><br></pre></td></tr></table></figure></p><p><strong>查询端口聚合:</strong> 配置完成后,可以查询所有的集合列表情况,查看所有聚合表命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[LSW1] display interface Eth-Trunk</span><br><span class="line"></span><br><span class="line">Eth-Trunk1 current state : UP</span><br><span class="line">Line protocol current state : UP</span><br><span class="line">Description:</span><br><span class="line">Switch Port, PVID :    1, Hash arithmetic : According to SA-XOR-DA,Maximal BW: 3</span><br><span class="line">G, Current BW: 3G, The Maximum Frame Length is 9216</span><br><span class="line">IP Sending Frames&apos; Format is PKTFMT_ETHNT_2, Hardware address is 4c1f-cc22-6944</span><br><span class="line">Current system time: 2019-04-08 12:42:34-08:00</span><br><span class="line">    Input bandwidth utilization  :    0%</span><br><span class="line">    Output bandwidth utilization :    0%</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">PortName                      Status      Weight</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">GigabitEthernet0/0/1          UP          1</span><br><span class="line">GigabitEthernet0/0/2          UP          1</span><br><span class="line">GigabitEthernet0/0/3          UP          1</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">The Number of Ports in Trunk : 3</span><br><span class="line">The Number of UP Ports in Trunk : 3</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="配置边缘端口"><a href="#配置边缘端口" class="headerlink" title="配置边缘端口"></a>配置边缘端口</h2><p>对于运行生成树协议的二层网络,与终端相连的端口不用参与生成树计算,这些端口参与计算会影响网络拓扑的收敛速度,而且这些端口的状态改变也可能会引起网络震荡,导致用户流最中断.此时,可以通过执行命令<code>stp edged-port enable</code>将当前端口配置成<code>边缘端口</code>,该端口便不再参与生成树计算,从而帮助加快网络拓扑的收敛时间以及加强网络的稳定性.</p><p>需要注意:当前端口配置成边缘端口后,如果收到<code>BPDU报文</code>,那么交换设备会自动将边缘端口设置为非边缘端口,并重新进行生成树计算,接下来将通过一个实验来演示边缘端口的配置,其配置拓扑图如下所示:</p><p><img src="/picture/20190408150929.jpg" alt="blockchain"></p><p><strong>给指定端口配置:</strong> 这里我们指定配置两台交换机的边缘端口,将<code>Ge0/0/2</code>配置为边缘端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在LSW1上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[LSW1] stp mode rstp                                   // 设置成快速生成树</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/2                 // 选择要配置的接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] stp edged-port enable      // 配置成边缘接口</span><br><span class="line"></span><br><span class="line">#----在LSW2上操作-------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[LSW2] stp mode rstp                                   // 设置成快速生成树</span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/2                 // 选择要配置的接口</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] stp edged-port enable      // 配置成边缘接口</span><br></pre></td></tr></table></figure></p><p><strong>给全局端口配置:</strong> 也可以给将边缘端口配置为全局模式,以下案例将配置全局端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[LSW1] stp mode rstp                  // 配置成快速生成树</span><br><span class="line">[LSW1] stp edged-port default         // 配置边缘端口为全局模式</span><br><span class="line"></span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/1              // 选择接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] stp edged-port disable  // 配置为非边缘端口</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="配置端口隔离"><a href="#配置端口隔离" class="headerlink" title="配置端口隔离"></a>配置端口隔离</h2><p>端口隔离可以将两个或多个主机或群组实现物理隔离,从而禁止同网段主机的数据通信,下面的小案例将实现端口隔离,其效果是<code>PC1与PC2之间不能互相访问</code>,<code>PC1与PC3之间可以互相访问</code>,<code>PC2与PC3之间可以互相访问</code>,其拓扑结构如下:</p><p><img src="/picture/20190408153847.jpg" alt="blockchain"></p><p><strong>配置模式:</strong> 配置端口隔离模式为二层隔离三层互通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">[Huawei]port-isolate mode l2</span><br></pre></td></tr></table></figure></p><p><strong>配置隔离:</strong> 配置<code>GE0/0/1</code>和<code>GE0/0/2</code>的端口隔离功能.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] interface GigabitEthernet 0/0/1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] port-isolate enable group 1</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2] port-isolate enable group 1</span><br><span class="line">[Huawei-GigabitEthernet0/0/2] quit</span><br></pre></td></tr></table></figure></p><p><strong>端口防环路:</strong> 适用与华为交换机,防止下级环路自动<code>shutdown</code>下级有环路的端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">[Huawei]loopback-detect enable             // 全局模式启用环路检测功能</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1  // 如果下级有环路shutdown本端口</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] loopback-detect action shutdown</span><br></pre></td></tr></table></figure></p><p><strong>查询隔离参数:</strong> 配置完成后可使用<code>display current-configuration</code>命令查询配置参数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei]display current-configuration </span><br><span class="line">....</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> port-isolate enable group 1</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"> port-isolate enable group 1</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="配置端口安全"><a href="#配置端口安全" class="headerlink" title="配置端口安全"></a>配置端口安全</h2><p>在实际的生产环境中,对于有较高安全要求的设备,可以使用<code>端口安全技术(Port Security)</code>来提高网络的安全性,端口安全技术可在接入层验证接入设备,防止未经允许的设备接入到网络中,还可以限制端口接入的设备数量,防止过多设备接入网络,影响网络速率.</p><p>在网络中MAC地址是设备中不变的物理地址,控制MAC地址接入就控制了交换机的端口接入,所以端口安全也是对MAC的的安全.在交换机中<code>CAM(Content Addressable Memory,内容可寻址内存表)表</code>,又叫MAC地址表,其中记录了与交换机相连的设备的MAC地址、端口号、所属vlan等对应关系.</p><blockquote><p>华为交换机MAC地址表分为三张</p><blockquote><p>1、静态MAC地址表,手工绑定,优先级高于动态MAC地址表<br>2、动态MAC地址表,交换机收到数据帧后会将源mac学习到MAC地址表中<br>3、黑洞MAC地址表,手工绑定或自动学习,用于丢弃指定MAC地址</p></blockquote></blockquote><p>接下来看一个具体的实例,来实现端口安全的配置,包括端口绑定端口违规的处理等,实验拓扑图参数如下:</p><p><img src="/picture/20190408165319.jpg" alt="blockchain"></p><p><strong>配置静态MAC地址:</strong> 静态指定允许接入的设备的MAC地址,首先要知道MAC地址是多少.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] port-group group-member Gig0/0/1 to Gig0/0/3           // 选择1-3号端口</span><br><span class="line">[Huawei-port-group] port-security enable                        // 开启端口安全功能</span><br><span class="line">[Huawei-port-group] port-security max-mac-num 1                 // 限制安全MAC地址最大数量为1个</span><br><span class="line">[Huawei-port-group] port-security protect-action shutdown       // 违规后默认关闭端口</span><br><span class="line">[Huawei-port-group] mac-address learning disable action discard // 禁止MAC地址学习功能</span><br><span class="line">[Huawei-port-group] quit</span><br><span class="line"></span><br><span class="line">#----配置MAC地址静态绑定-------------------------</span><br><span class="line">#将mac地址绑定到接口 Gig0/0/1 到 Gig0/0/2 在vlan1中有效</span><br><span class="line">[Huawei] mac-address static 5489-9887-165B GigabitEthernet 0/0/1 vlan 1</span><br><span class="line">[Huawei] mac-address static 5489-98B4-3791 GigabitEthernet 0/0/2 vlan 1</span><br><span class="line">[Huawei] mac-address static 5489-98E3-0DCA GigabitEthernet 0/0/3 vlan 1</span><br><span class="line"></span><br><span class="line">#----查询MAC地址绑定与分配------------------------</span><br><span class="line">[Huawei] display mac-address                               // 查询绑定信息列表</span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-98e3-0dca 1           -      -      GE0/0/3         static    -           </span><br><span class="line">5489-9887-165b 1           -      -      GE0/0/1         static    -           </span><br><span class="line">5489-98b4-3791 1           -      -      GE0/0/2         static    -           </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 3</span><br></pre></td></tr></table></figure></p><p><strong>配置动态MAC地址:</strong> 动态分配接入设备的MAC地址,此配置无需绑定MAC地址,会接入最先访问的主机MAC地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-----------------------------------------------</span><br><span class="line">#此功能是将动态学习到的MAC地址设置为安全属性,其他没有被学习到的非安全属性的MAC的帧将被端口丢弃</span><br><span class="line"></span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] port-group group-member Gig0/0/1 to Gig0/0/3           // 选择1-3号端口</span><br><span class="line">[Huawei-port-group] port-security enable                        // 开启端口安全功能</span><br><span class="line">[Huawei-port-group] port-security max-mac-num 1                 // 限制安全MAC地址最大为1</span><br><span class="line">[Huawei-port-group] port-security protect-action protect        // 配置处理动作为丢弃</span><br><span class="line">[Huawei-port-group] port-security aging-time 300                // 配置老化时间300s</span><br><span class="line">[Huawei-port-group] quit</span><br><span class="line"></span><br><span class="line">#----查询MAC地址绑定与分配------------------------</span><br><span class="line">[Huawei] display mac-address</span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-98e3-0dca 1           -      -      GE0/0/3         security  -           </span><br><span class="line">5489-9887-165b 1           -      -      GE0/0/1         security  -           </span><br><span class="line">5489-98b4-3791 1           -      -      GE0/0/2         security  -           </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 3</span><br></pre></td></tr></table></figure></p><p>在端口安全动态MAC地址中,配置如上的话,在<code>Gig0/0/1-3端口</code>学习到的第一个MAC地址设置为安全MAC地址,此外其他MAC地址在接入端口的话都不给予转发,在300s后刷新安全MAC地址表,并且重新学习安全MAC地址,<code>(哪个MAC地址)先到</code>就先被学到端口并设置为安全MAC地址,但是在交换机重启后安全MAC地址会被清空重新学习.</p><p><strong>配置贴粘MAC地址:</strong> 此功能与动态MAC功能一致,唯一不同的是粘贴MAC地址不会老化,切交换重启后依然存在.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] port-group group-member Gig0/0/1 to Gig0/0/3           // 选择1-3号端口</span><br><span class="line">[Huawei-port-group] port-security enable                        // 开启端口安全功能</span><br><span class="line">[Huawei-port-group] port-security mac-address sticky            // 打开安全粘贴MAC功能</span><br><span class="line">[Huawei-port-group] port-security max-mac-num 1                 // 限制安全MAC地址最大为1</span><br><span class="line">[Huawei-port-group] quit</span><br><span class="line"></span><br><span class="line">#----配置MAC地址静态绑定-------------------------</span><br><span class="line">#手工绑定粘贴MAC地址和所属vlan1的操作</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1                         // 选择绑定接口</span><br><span class="line">[Huawei] port-security mac-address sticky 5489-9887-165B vlan 1  // 绑定指定的MAC地址</span><br><span class="line">[Huawei] port-security protect-action shutdown                   // 违规端口自动关闭</span><br><span class="line">[Huawei] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/2</span><br><span class="line">[Huawei] port-security mac-address sticky 5489-98B4-3791 vlan 1</span><br><span class="line">[Huawei] port-security protect-action shutdown</span><br><span class="line">[Huawei] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/3</span><br><span class="line">[Huawei] port-security mac-address sticky 5489-98E3-0DCA vlan 1</span><br><span class="line">[Huawei] port-security protect-action shutdown</span><br><span class="line">[Huawei] quit</span><br><span class="line"></span><br><span class="line">#----查询端口绑定情况----------------------------</span><br><span class="line">[Huawei] display mac-address </span><br><span class="line">MAC address table of slot 0:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">MAC Address    VLAN/       PEVLAN CEVLAN Port            Type      LSP/LSR-ID  </span><br><span class="line">               VSI/SI                                              MAC-Tunnel  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">5489-98e3-0dca 1           -      -      GE0/0/3         sticky    -           </span><br><span class="line">5489-9887-165b 1           -      -      GE0/0/1         sticky    -           </span><br><span class="line">5489-98b4-3791 1           -      -      GE0/0/2         sticky    -           </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Total matching items on slot 0 displayed = 3</span><br></pre></td></tr></table></figure></p><p>此功能配置完成后,相当于对设备进行了严格的限制,当有其他的机器链接到不该链接的接口上时,也无法连接网路.<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="huawei" scheme="https://localhost/tags/huawei/"/>
    
  </entry>
  
  <entry>
    <title>华为交换机配置笔记</title>
    <link href="https://localhost/2019/04/03/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://localhost/2019/04/03/网络设备配置/华为交换机配置笔记/</id>
    <published>2019-04-03T00:28:37.000Z</published>
    <updated>2019-04-16T06:12:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.</p><a id="more"></a><p>交换机是一种交换式集线器,其基于MAC地址识别,能完成封装转发数据包功能的网络设备.交换机可以学习MAC地址,并把其存放在内部地址表中,通过在数据帧的始发者和目标接收者之间建立临时的交换路径,使数据帧直接由源地址到达目的地址.</p><p>交换机内部拥有一条很高带宽的背板总线和内部交换矩阵所有的端口都挂接在这条背板总线上控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的MAC地址的网卡NIC挂接在哪个端口上,通过内部交换矩阵迅速将数据包传送到目的端口目的MAC若不存在才广播到所有的端口,接收端口回应后交换机会学习新的地址,并把它添加入内部MAC地址表中.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于交换机的分类:</p><blockquote><p>1.根据网络覆盖范围划分交换机:广域网交换机和局域网交换机<br>2.根据交换机端口结构划分交换机:固定端口交换机和模块化交换机<br>3.根据工作协议层划分交换机:二层交换机、三层交换机、四层交换机<br>4.根据支持网管功能划分交换机:网管型交换机和非网管理型交换机<br>5.根据传输介质划分交换机:以太网交换机、快速以太网交换机、ATM交换机、FDDI交换机、令牌环交换机<br>6.根据应用网络层次划分交换机:企业级交换机、校园网交换机、部门级交换机、工作组交换机、桌机交换机</p></blockquote></blockquote><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于二层交换机:</p><blockquote><p>二层交换机是对应于OSI/RM的第二协议层来定义的,因为它只能工作在OSI/RM开放体系模型的第二层,即数据链路层.二层交换机依赖于链路层中的信息(如MAC地址)完成不同端口数据间的线速交换,一般应用于小型企业或中型以上企业网络的桌面层次.</p></blockquote></blockquote><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于三层交换机:</p><blockquote><p>三层交换机是对应于OSI/RM开放体系模型的第三层,即网络层来定义的,也就是说这类交换机可以工作在网络层,它比第二层交换机更加高档,功能更加强.当网络规模较大时,可以根据特殊应用需求划分为小面独立的VLAN网段,以减小广播所造成的影响,通常这类交换机是采用模块化结构,以适应灵活配置的需要.<br><br></p></blockquote></blockquote><h2 id="交换机的初始化"><a href="#交换机的初始化" class="headerlink" title="交换机的初始化"></a>交换机的初始化</h2><p><strong>Console密码认证:</strong> 配置与清除Console接口的登陆密码,<code>cipher/simple</code>分别为配置密文与明文密码.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ----配置密码-------------------------------------------------------</span></span><br><span class="line">&lt;Huawei&gt; system-view                                           // 进入配置视图</span><br><span class="line">[Huawei] sysname switch1                                       // 配置主机名称</span><br><span class="line">[Huawei] user-interface console 0                              // 进入Console</span><br><span class="line">[Huawei-ui-console0] authentication-mode password              // 指定密码配置</span><br><span class="line">[Huawei-ui-console0] <span class="built_in">set</span> authentication password cipher 1233   // 配置密文密码</span><br><span class="line">[Huawei-ui-console0] <span class="built_in">set</span> authentication password simple 1233   // 配置明文密码</span><br><span class="line">[Huawei-ui-console0] display this                              // 显示查询结果</span><br><span class="line">[Huawei-ui-console0] <span class="built_in">return</span></span><br><span class="line">&lt;Huawei&gt; save</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----清除密码-------------------------------------------------------</span></span><br><span class="line">&lt;Huawei&gt; system-view                                           // 进入配置视图</span><br><span class="line">[Huawei] user-interface console 0                              // 进入Console0</span><br><span class="line">[Huawei] undo authentication-mode                              // 清理用户配置密码</span><br><span class="line">[Huawei] undo <span class="built_in">set</span> authentication password                      // 清理用户配置密码</span><br><span class="line">[Huawei] display this                                          // 显示查询结果</span><br><span class="line">[Huawei] <span class="built_in">return</span></span><br><span class="line">&lt;Huawei&gt; save</span><br></pre></td></tr></table></figure></p><p><strong>AAA账号密码认证:</strong> 启用用户名密码认证,用户名<code>lyshark</code>,密码是<code>1233</code>,下次登陆需要输入用户名与密码.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] user-interface console 0</span><br><span class="line">[Huawei-ui-console0] authentication-mode aaa</span><br><span class="line">[Huawei-ui-console0] quit</span><br><span class="line">[Huawei] aaa</span><br><span class="line">[Huawei-aaa] <span class="built_in">local</span>-user lyshark password cipher 1233</span><br><span class="line">[Huawei-aaa] <span class="built_in">local</span>-user lyshark service-type terminal</span><br><span class="line">[Huawei-aaa] display this</span><br><span class="line">[Huawei-aaa] <span class="built_in">return</span></span><br><span class="line">&lt;Huawei&gt; save</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器远程登陆:</strong> 给路由器配置指定的IP地址,并能够通过Telnet远程连接到路由器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置IP地址-------------------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Ethernet 0/0/0                      // 选择以太网接口</span><br><span class="line">[Huawei-Ethernet0/0/0]</span><br><span class="line">[Huawei-Ethernet0/0/0] ip address 192.168.10.10 24     // 配置IP地址</span><br><span class="line">[Huawei-Ethernet0/0/0] quit</span><br><span class="line"></span><br><span class="line"># ----配置密码认证-------------------------------------------------------</span><br><span class="line">[Huawei] aaa</span><br><span class="line">[Huawei-aaa] local-user lyshark password cipher 123123</span><br><span class="line">[Huawei-aaa] local-user lyshark privilege level 3</span><br><span class="line">[Huawei-aaa] qui</span><br><span class="line"></span><br><span class="line">[Huawei] user-interface maximum-vty 5            // 指定最大登陆用户</span><br><span class="line">[Huawei] user-interface vty 0 4                  // 指定编号0-4</span><br><span class="line">[Huawei-ui-vty0-4] authentication-mode aaa       // 启用AAA认证</span><br><span class="line">[Huawei-ui-vty0-4] protocol inbound telnet       // 配置telnet协议</span><br><span class="line">[Huawei-ui-vty0-4] quit</span><br><span class="line"></span><br><span class="line"># ----查询和保存-------------------------------------------------------</span><br><span class="line">&lt;Huawei&gt; display telnet server status　　　      // 查看telnet是否生效</span><br><span class="line">&lt;Huawei&gt; display ip interface brief             // 查看路由器端口情况</span><br><span class="line">&lt;Huawei&gt; display ip routing-table               // 查询路由信息</span><br><span class="line">&lt;Huawei&gt; display interface                      // 看有多少接口</span><br><span class="line">&lt;Huawei&gt; save                                   // 保存配置选项</span><br></pre></td></tr></table></figure></p><p><strong>配置交换机远程登陆:</strong> 给交换机配置远程登陆地址,并能够通过Telnet连接到交换机.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line"></span><br><span class="line"># ----配置密码认证-------------------------------------------------------</span><br><span class="line">[Huawei] aaa</span><br><span class="line">[Huawei-aaa] local-user lyshark password cipher 123123</span><br><span class="line">[Huawei-aaa] local-user lyshark service-type telnet</span><br><span class="line">[Huawei-aaa] local-user lyshark privilege level 15</span><br><span class="line">[Huawei-aaa] display telnet server status</span><br><span class="line">[Huawei-aaa] quit</span><br><span class="line"></span><br><span class="line"># ----开启远程终端-------------------------------------------------------</span><br><span class="line">[Huawei] user-interface vty 0 4                // 进入vty0-4虚拟终端</span><br><span class="line">[Huawei-ui-vty0-4] authentication-mode aaa     // 配置AAA认证机制</span><br><span class="line">[Huawei-ui-vty0-4] user privilege level 15     // 配置认证级别</span><br><span class="line">[Huawei-ui-vty0-4] protocol inbound telnet     // 配置Telnet协议</span><br><span class="line">[Huawei-ui-vty0-4] quit                        // 退出系统视图</span><br><span class="line"></span><br><span class="line"># ----配置终端IP地址-----------------------------------------------------</span><br><span class="line">[Huawei] interface Vlanif 1</span><br><span class="line">[Huawei-Vlanif1] ip address 192.168.10.10 255.255.255.0</span><br><span class="line">[Huawei-Vlanif1] quit</span><br><span class="line">&lt;Huawei&gt; save</span><br></pre></td></tr></table></figure></p><p>配置交换机远程登陆需要注意,交换机接口不允许配置IP地址,我们只能在虚拟VLAN接口中配置IP地址才可以使用远程登陆功能.<br><br></p><h2 id="交换机常用参数"><a href="#交换机常用参数" class="headerlink" title="交换机常用参数"></a>交换机常用参数</h2><p><strong>基本配置命令:</strong> 交换机与路由器的基本查询指令.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] display current-configuration              // 显示当前生效的配置</span><br><span class="line">[Huawei] display saved-configuration                // 显示flash中配置文件</span><br><span class="line">[Huawei] reset saved-configuration                  // 檫除旧的配置文件</span><br><span class="line">[Huawei] reboot                                     // 交换机重启</span><br><span class="line">[Huawei] display version                            // 显示系统版本信息</span><br><span class="line">[Huawei] sysname                                    // 交换机命名</span><br></pre></td></tr></table></figure></p><p><strong>用户视图:</strong> 刚开始登入交换机时的视图,一般看到的是尖括号<code>&lt;&gt;</code>表示用户视图.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; save                               // 配置完成保存配置</span><br><span class="line">&lt;Huawei&gt; system-view                        // 进入系统视图的命令</span><br><span class="line">&lt;Huawei&gt; clock timezone                     // 设置时区</span><br><span class="line">&lt;Huawei&gt; clock datetime 22:12:00 2019-04-01 // 设置交换机的时间</span><br></pre></td></tr></table></figure></p><p><strong>系统视图:</strong> 在用户视图下输入<code>system-view</code>后进入系统视图,一般为方括号<code>[]</code>表示系统视图.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] display current-configuration      // 显示当前配置</span><br><span class="line">[Huawei] user-interface maximum-vty 15      // 配置vty最大连接数</span><br><span class="line">[Huawei] user-interface vty 0 14            // 进入vty用户界面视图</span><br><span class="line">[Huawei] user privilege level 2             // 设置vty登入的用户等级为2(配置用户级别)</span><br><span class="line">[Huawei] authentication-mode aaa            // 设置vty登入时的验证模式为用户名和密码验证</span><br></pre></td></tr></table></figure></p><p><strong>端口配置:</strong> 常用的端口配置命令整理.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface Gig</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1        // 选择一个端口</span><br><span class="line">[Huawei] duplex &#123;half|full|auto&#125;                // 配置端口工作状态</span><br><span class="line">[Huawei] speed &#123;10|100|auto&#125;                    // 配置端口工作速率</span><br><span class="line">[Huawei] flow-control                           // 配置端口流控</span><br><span class="line">[Huawei] mdi &#123;across|auto|normal&#125;               // 配置端口平接扭接</span><br><span class="line">[Huawei] port link-type &#123;trunk|access|hybrid&#125;   // 设置端口工作模式</span><br><span class="line">[Huawei] undo shutdown                          // 激活端口</span><br><span class="line">[Huawei] quit                                   // 退出系统视图</span><br></pre></td></tr></table></figure></p><p><strong>批量配置端口:</strong> 通过命令批量的选择一些交换机或路由器的接口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] vlan batch 10 20                                  // 创建vlan10和vlan20</span><br><span class="line">[Huawei] port-group group-member Gig0/0/1 to Gig0/0/10     // 选择1-10号端口</span><br><span class="line">[Huawei] port link-type access                             // 配置成access模式</span><br><span class="line">[Huawei] port default vlan 10                              // 应用到vlan10</span><br></pre></td></tr></table></figure></p><p><strong>清除端口状态:</strong> 清除某个端口的配置,用于初始化端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Huawei] interface Gigabitethernet 0/0/1</span><br><span class="line">[Huawei] clear configuration this</span><br><span class="line">[Huawei] undo shutdown</span><br><span class="line">[Huawei] interface gigabitethernet 0/0/3</span><br><span class="line">[Huawei] undo port default vlan                  //access 模式的端口</span><br><span class="line">[Huawei] undo port link-type </span><br><span class="line">[Huawei] undo port hybrid pvid vlan vlanid       //hybrid 模式的端口</span><br><span class="line">[Huawei] undo port hybrid untagged vlan vlanid</span><br><span class="line">[Huawei] undo port hybrid tagged vlan vlanid </span><br><span class="line">[Huawei] undo port trunk pvid vlan               //trunk 模式的端口</span><br><span class="line">[Huawei] undo port trunk allow-pass vlan vlanid </span><br><span class="line">[Huawei] undo port link-type</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="交换机实现VLAN"><a href="#交换机实现VLAN" class="headerlink" title="交换机实现VLAN"></a>交换机实现VLAN</h2><p>VLAN(Virtual Local Area Network),中文名为虚拟局域网,是一种使用交换机将局域网内的设备在逻辑上划分成一个个网段的技术,即在物理网络上进一步划分逻辑网络,VLAN可以突破地理位置的限制,完全基于实际管理需要来划分网络,例如在单个交换机内划分为不同的区域,不同区域之间无法互相通信,来实现相互隔离.</p><p>VLAN具有与普通局域网相同的属性,第二层的单播,多播和广播帧只能在相同的VLAN内转发,扩散,而不会直接进入其他VLAN中,因此同一个VLAN内的主机即使位于不同的交换机上,也可以互相访问,而不是同一VLAN的主机,即使连接在同一交换机上,也无法通过数据链路层互相访问.如果一个VLAN内的主机想访问另一个VLAN内的主机,必须通过一个三层设备,如路由器或三层交换机实现通信.<br><br></p><h3 id="◆单交换机实现VLAN◆"><a href="#◆单交换机实现VLAN◆" class="headerlink" title="◆单交换机实现VLAN◆"></a>◆单交换机实现VLAN◆</h3><p>如前所述,基于端口的VLAN属于静态VLAN,它是划分网络最简单,最有效和最常用的方法,下面将在单台交换机上配置静态VLAN,来实现两个网段的数据隔离,以下实验是一种网络拓扑中最简单的拓扑结构图,适合于小型办公网络,其实验拓扑图如下.</p><p><img src="/picture/20190403094842.jpg" alt="blockchain"></p><p><strong>创建VLAN区域:</strong> 创建两个VLAN区域,分别为<code>vlan10和vlan20</code>用来代表两个部门,命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view              // 进入系统视图模式</span><br><span class="line"></span><br><span class="line">[Huawei] vlan 10                 // 创建VLAN10</span><br><span class="line">[Huawei-vlan10] quit</span><br><span class="line">[Huawei] vlan 20                 // 创建VLAN20</span><br><span class="line">[Huawei-vlan20] quit</span><br><span class="line"></span><br><span class="line">[Huawei] display vlan            // 显示当前VLAN情况</span><br><span class="line">VID  Status  Property      MAC-LRN Statistics Description      </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">1    enable  default       enable  disable    VLAN 0001                         </span><br><span class="line">10   enable  default       enable  disable    VLAN 0010                         </span><br><span class="line">20   enable  default       enable  disable    VLAN 0020       </span><br><span class="line"></span><br><span class="line">[Huawei] quit</span><br><span class="line">&lt;Huawei&gt; save                     // 保存更改</span><br></pre></td></tr></table></figure></p><p><strong>批量添加VLAN:</strong> 接着将<code>PC1-至-&gt;PC3</code>批量添加到<code>VLAN10</code>这个区域内.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] port-group group-member GigabitEthernet 0/0/1 to GigabitEthernet 0/0/3</span><br><span class="line"></span><br><span class="line">[Huawei-port-group] port link-type access</span><br><span class="line">[Huawei-port-group] port default vlan 10</span><br><span class="line">[Huawei-port-group] display vlan</span><br><span class="line"></span><br><span class="line">VID  Type    Ports                                                          </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">10   common  UT:GE0/0/1(U)      GE0/0/2(U)      GE0/0/3(U)</span><br><span class="line"></span><br><span class="line">20   common</span><br><span class="line">VID  Status  Property      MAC-LRN Statistics Description</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1    enable  default       enable  disable    VLAN 0001                         </span><br><span class="line">10   enable  default       enable  disable    VLAN 0010                         </span><br><span class="line">20   enable  default       enable  disable    VLAN 0020          </span><br><span class="line"></span><br><span class="line">undo port link-type </span><br><span class="line">undo port default vlan</span><br></pre></td></tr></table></figure></p><p><strong>单独添加VLAN:</strong> 接着将<code>PC4-至-&gt;PC5</code>单独添加到<code>VLAN20</code>这个区域内.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/4</span><br><span class="line">[Huawei-GigabitEthernet0/0/4] port link-type access</span><br><span class="line">[Huawei-GigabitEthernet0/0/4] port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/4] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/5</span><br><span class="line">[Huawei-GigabitEthernet0/0/5] port link-type access</span><br><span class="line">[Huawei-GigabitEthernet0/0/5] port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/5] quit</span><br><span class="line"></span><br><span class="line">[Huawei-port-group] display vlan</span><br><span class="line">10   common  UT:GE0/0/1(U)      GE0/0/2(U)      GE0/0/3(U)</span><br><span class="line">20   common  UT:GE0/0/4(U)      GE0/0/5(U)</span><br><span class="line"></span><br><span class="line">VID  Status  Property      MAC-LRN Statistics Description      </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">1    <span class="built_in">enable</span>  default       <span class="built_in">enable</span>  <span class="built_in">disable</span>    VLAN 0001                         </span><br><span class="line">10   <span class="built_in">enable</span>  default       <span class="built_in">enable</span>  <span class="built_in">disable</span>    VLAN 0010                         </span><br><span class="line">20   <span class="built_in">enable</span>  default       <span class="built_in">enable</span>  <span class="built_in">disable</span>    VLAN 0020</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给五台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]     [子网]</span><br><span class="line">PC0           192.168.1.1      24</span><br><span class="line">PC1           192.168.1.2      24</span><br><span class="line">PC2           192.168.1.3      24</span><br><span class="line">PC3           192.168.1.4      24</span><br><span class="line">PC4           192.168.1.5      24</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line">C:\&gt;ping 192.168.1.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.1.2</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.1.4</span><br><span class="line">error</span><br></pre></td></tr></table></figure></p><h3 id="◆跨交换机实现VLAN◆"><a href="#◆跨交换机实现VLAN◆" class="headerlink" title="◆跨交换机实现VLAN◆"></a>◆跨交换机实现VLAN◆</h3><p>在实际的工作环境中,只在一台交换机上实现VLAN是远远不够的,通常需要跨越多台交换机实现VLAN划分网段,华为交换机通过使用Trunk干道端口的方式实现多台交换机数据共享,并实现跨交换机上的同一个VLAN之间的数据通信,其拓扑结构图如下.</p><p><img src="/picture/20190403120149.jpg" alt="blockchain"></p><p><strong>开启两台交换机:</strong> 分别开启两台交换机的端口,这里激活<code>git 0/0/1 - 0/0/3</code>端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei]sysname LSW1</span><br><span class="line">[LSW1] clear configuration int gi 0/0/1    // 清空接口配置</span><br><span class="line">[LSW1] port-group group-member Gig0/0/1 to Gig0/0/3      // 选择Gig1-Gig3号接口</span><br><span class="line">[LSW1-port-group] undo shutdown                          // 开启接口选项</span><br><span class="line"></span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei]sysname LSW2</span><br><span class="line">[LSW2] clear configuration int gi 0/0/1    // 清空接口配置</span><br><span class="line">[LSW2]port-group group-member Gig0/0/1 to Gig0/0/3      // 选择Gig1-Gig3号接口</span><br><span class="line">[LSW2-port-group]undo shutdown                          // 开启接口选项</span><br></pre></td></tr></table></figure></p><p><strong>配置Trunk接口(两台):</strong> 接下来在交换机上配置<code>Gig0/0/1接口</code>为<code>Trunk干道</code>通信接口,这里两台都需要配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置交换机LSW1-------------------------------------------------------</span><br><span class="line">&lt;LSW1&gt; system-view</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/1                       // 选择一个接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/1]port link-type trunk              // 将该接口配置为trunk口</span><br><span class="line">[LSW1-GigabitEthernet0/0/1]port trunk allow-pass vlan all    // 定义trunk允许vlan通过</span><br><span class="line">[LSW1-GigabitEthernet0/0/1]display this</span><br><span class="line"></span><br><span class="line"># ----配置交换机LSW2-------------------------------------------------------</span><br><span class="line">&lt;LSW2&gt; system-view</span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/1                       // 选择一个接口</span><br><span class="line">[LSW2-GigabitEthernet0/0/1]port link-type trunk              // 将该接口配置为trunk口</span><br><span class="line">[LSW2-GigabitEthernet0/0/1]port trunk allow-pass vlan all    // 定义trunk允许vlan通过</span><br><span class="line">[LSW2-GigabitEthernet0/0/1]display this</span><br></pre></td></tr></table></figure></p><p><strong>配置VLAN(两台):</strong> 分别配置两台交换机<code>VLAN10和VLAN20接口</code>,并将<code>PC1-PC2加入VLAN10</code>,<code>PC3-PC4加入VLAN20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置交换机LSW1-------------------------------------------------------</span><br><span class="line">&lt;LSW1&gt;system-view                                            // 进入系统视图模式</span><br><span class="line">[LSW1] vlan batch 10 20                                      // 创建vlan10,vlan20</span><br><span class="line">[LSW1] interface Gig0/0/2                                    // 进入第2个业务网口</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] port link-type access            // 开启接口模式为access</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] port default vlan 10             // 将以上接口加入到vlan10</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] quit</span><br><span class="line">[LSW1] interface Gig0/0/3                                    //进入第3个业务网口</span><br><span class="line">[LSW1-GigabitEthernet0/0/3] port link-type access            // 开启接口模式为access</span><br><span class="line">[LSW1-GigabitEthernet0/0/3] port default vlan 20             // 将以上接口加入到vlan20</span><br><span class="line"></span><br><span class="line"># ----配置交换机LSW2-------------------------------------------------------</span><br><span class="line">&lt;LSW2&gt;system-view                                            // 进入系统视图模式</span><br><span class="line">[LSW2] vlan batch 10 20                                      // 创建vlan10,vlan20</span><br><span class="line">[LSW2] interface Gig0/0/2                                    // 进入第2个业务网口</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] port link-type access            // 开启接口模式为access</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] port default vlan 10             // 将以上接口加入到vlan10</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] quit</span><br><span class="line">[LSW2] interface Gig0/0/3                                    //进入第3个业务网口</span><br><span class="line">[LSW2-GigabitEthernet0/0/3] port link-type access            // 开启接口模式为access</span><br><span class="line">[LSW2-GigabitEthernet0/0/3] port default vlan 20             // 将以上接口加入到vlan20</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给四台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]     [子网]</span><br><span class="line">PC1           192.168.10.1      24</span><br><span class="line">PC2           192.168.10.2      24</span><br><span class="line">PC3           192.168.20.1      24</span><br><span class="line">PC4           192.168.20.2      24</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">error</span><br></pre></td></tr></table></figure></p><h3 id="◆本征VLAN实现通信◆"><a href="#◆本征VLAN实现通信◆" class="headerlink" title="◆本征VLAN实现通信◆"></a>◆本征VLAN实现通信◆</h3><p>下面的实验用于理解<code>本征VLAN</code>的一些特性,并无实际作用,这里我们需要知道在<code>思科设备中</code>,默认规定的VLAN被称作<code>本征VLAN</code>,而在<code>华为设备中</code>叫做<code>默认VLAN(PIID)</code>,本征VLAN的作用是用来<code>给报文打标签</code>的,如果没有标签则说明默认就是<code>VLAN1</code>,默认的VLAN在发送数据包时是不需要打标签的,华为的设备如果不进行任何操作,则默认本征VLAN就是1号.</p><p>这里有一道面试题,其目的是只给你两个交换机,且有两台跨网段的主机,这两台主机分别分布在<code>VLAN10</code>和<code>VLAN20</code>两个虚拟局域网中,在不加路由设备的情况下,通过其他的手段实现两台跨VLAN主机的通信,其实就用到了本征VLAN,拓扑结构图如下所示:</p><p><img src="/picture/20190404105536.jpg" alt="blockchain"></p><p><strong>配置交换机(两台):</strong> 分别配置两台交换机,将<code>Gig0/0/1</code>配置成<code>trunk接口</code>,将<code>Gig0/0/2</code>配置成<code>access接口</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置交换机LSW1-------------------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname LSW1                                      // 将交换机命名为LSW1</span><br><span class="line">[LSW1] vlan 10                                             // 创建Vlan10接口</span><br><span class="line">[LSW1-vlan10] quit</span><br><span class="line"></span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/1                     // 选择Gig0/0/1接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port link-type trunk           // 配置成trunk</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port trunk allow-pass vlan all // 对所有VLAN生效</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/2                      // 选择Gig0/0/2接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] port link-type access           // 配置成access</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] port default vlan 10            // 将此接口加入vlan10</span><br><span class="line">[LSW1-GigabitEthernet0/0/2] quit</span><br><span class="line"></span><br><span class="line">[LSW1] display port vlan active                             // 查询vlan接口配置情况</span><br><span class="line"># ----配置交换机LSW2-------------------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname LSW2</span><br><span class="line">[LSW2] vlan 20</span><br><span class="line">[LSW2-vlan20] quit</span><br><span class="line"></span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/1</span><br><span class="line">[LSW2-GigabitEthernet0/0/1] port link-type trunk</span><br><span class="line">[LSW2-GigabitEthernet0/0/1] port trunk allow-pass vlan all</span><br><span class="line">[LSW2-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/2</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] port link-type access </span><br><span class="line">[LSW2-GigabitEthernet0/0/2] port default vlan 20</span><br><span class="line">[LSW2-GigabitEthernet0/0/2] quit</span><br><span class="line"></span><br><span class="line">[LSW2] display port vlan active</span><br></pre></td></tr></table></figure></p><p><strong>配置本征VLAN(两台):</strong> 最后分别在<code>LSW1和LSW2</code>两台交换机分别配置本征VLAN.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ----配置交换机LSW1-------------------------------------------------------</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/1                 // 选择Gig0/0/1接口</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port trunk pvid vlan 10    // 配置本征vlan为vlan10</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] quit</span><br><span class="line"></span><br><span class="line"># ----配置交换机LSW2-------------------------------------------------------</span><br><span class="line">[LSW2] interface GigabitEthernet 0/0/1</span><br><span class="line">[LSW2-GigabitEthernet0/0/1] port trunk pvid vlan 20    // 配置本征vlan为vlan20</span><br><span class="line">[LSW2-GigabitEthernet0/0/1] quit</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给四台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]     [子网]    [VLAN]</span><br><span class="line">PC1           192.168.10.1      24    VLAN 10</span><br><span class="line">PC2           192.168.10.2      24    VLAN 20</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.2</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆三层交换实现VLAN◆"><a href="#◆三层交换实现VLAN◆" class="headerlink" title="◆三层交换实现VLAN◆"></a>◆三层交换实现VLAN◆</h3><p>如果要在不同的VLAN之间进行数据通信,则必须利用一个具有三层(网络层)功能的设备来实现,目前常用的设备有三层交换机和路由器,在组建大型网络时出于安全考虑,必须把局域网按照功能划分为一个个小的局域网,来保证安全性,这就使得VLAN技术得以运用,但有时候我们还需要实现跨网段通信,则三层交换机可以实现我们的需求.</p><p>虽然路由器可以完成不同网段之间跨网段通信,但是由于路由器端口数量有限,且路由速度慢,因此三层交换机就诞生了,三层交换机是指具有路由功能的交换机,也就是实现了二层的转发和三层的交换,其价格便宜性价比高,目前是组网的绝佳选择,以下是一个三层交换机组网小案例,不仅实现了VLAN的隔离,还可以实现跨网段通信.</p><p><img src="/picture/20190404160800.jpg" alt="blockchain"></p><p><strong>配置二层交换(两台):</strong> 首先配置2个二层交换机,将<code>Ethernet 0/0/1</code>配成<code>Trunk</code>接口,然后将<code>Ethernet 0/0/2</code>配成<code>vlan10</code>,<code>Ethernet 0/0/3</code>配成<code>vlan20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line"></span><br><span class="line">#----配置trunk------------------------------------------------------------</span><br><span class="line">[Huawei] interface Ethernet 0/0/1                         // 选择Eth0/0/1接口</span><br><span class="line">[Huawei-Ethernet0/0/1] port link-type trunk               // 配置成Trunk模式</span><br><span class="line">[Huawei-Ethernet0/0/1] port trunk allow-pass vlan all     // 针对所有VLAN</span><br><span class="line">[Huawei-Ethernet0/0/1] quit</span><br><span class="line"></span><br><span class="line">#----配置VLAN-------------------------------------------------------------</span><br><span class="line">[Huawei] vlan 10                                           // 创建VLAN10</span><br><span class="line">[Huawei-vlan10] quit</span><br><span class="line">[Huawei] vlan 20                                           // 创建VLAN20</span><br><span class="line">[Huawei-vlan20] quit</span><br><span class="line"></span><br><span class="line">#----加入VLAN组-----------------------------------------------------------</span><br><span class="line">[Huawei] interface Ethernet 0/0/2                          // 选择2号端口</span><br><span class="line">[Huawei-Ethernet0/0/2] port link-type access               // 配置成access模式</span><br><span class="line">[Huawei-Ethernet0/0/2] port default vlan 10                // 将其加入到vlan10</span><br><span class="line">[Huawei-Ethernet0/0/2] quit</span><br><span class="line"></span><br><span class="line">[Huawei] interface Ethernet 0/0/3</span><br><span class="line">[Huawei-Ethernet0/0/3] port link-type access</span><br><span class="line">[Huawei-Ethernet0/0/3] port default vlan 20</span><br><span class="line">[Huawei-Ethernet0/0/3] quit</span><br><span class="line"></span><br><span class="line">[Huawei]display vlan                                        // 显示VLAN端口配置情况</span><br><span class="line">The total number of vlans is : 3</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">10   common  UT:Eth0/0/2(U)</span><br><span class="line">20   common  UT:Eth0/0/3(U)</span><br><span class="line"></span><br><span class="line">VID  Status  Property      MAC-LRN Statistics Description</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">1    enable  default       enable  disable    VLAN 0001</span><br><span class="line">10   enable  default       enable  disable    VLAN 0010</span><br><span class="line">20   enable  default       enable  disable    VLAN 0020</span><br></pre></td></tr></table></figure></p><p><strong>配置三层交换机:</strong> 添加<code>vlan10,20</code>端口,并将<code>Gig0/0/1到Gig0/0/2</code>设置为<code>trunk模式</code>,用于供二层交换机交换数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置VLAN-------------------------------------------------------------</span><br><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname LSW1</span><br><span class="line">[LSW1] vlan batch 10 20                                     // 分别创建 vlan 10,20</span><br><span class="line"></span><br><span class="line">#----配置端口-------------------------------------------------------------</span><br><span class="line">[LSW1] interface GigabitEthernet 0/0/1</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port link-type trunk</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port trunk allow-pass vlan all</span><br><span class="line"></span><br><span class="line">[LSW1]interface GigabitEthernet 0/0/2</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port link-type trunk</span><br><span class="line">[LSW1-GigabitEthernet0/0/1] port trunk allow-pass vlan all</span><br><span class="line"></span><br><span class="line">[LSW1] display vlan</span><br></pre></td></tr></table></figure></p><p><strong>配置三层交换网关:</strong> 开启SVI路由功能,分别为<code>vlan 10 和 vlan 20</code> 配置好网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[LSW1] interface vlanif 10            // 创建交换机虚拟接口</span><br><span class="line">[LSW1] ip add 192.168.10.1 24         // 配置ip地址</span><br><span class="line"></span><br><span class="line">[LSW1] interface vlanif 20            // 创建交换机虚拟接口</span><br><span class="line">[LSW1] ip add 192.168.20.1 24         // 配置ip地址</span><br><span class="line"></span><br><span class="line">[LSW1] display ip interface brief     // 显示接口</span><br><span class="line">[LSW1] display ip routing-table       // 显示路由表</span><br></pre></td></tr></table></figure></p><p><strong>客户机配置网关:</strong> 给每个客户机配置好IP地址和网关参数,并测试连通性,成功后则同VLAN四个IP都能互相PING通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关------------------------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC1           192.168.10.2     192.168.10.1</span><br><span class="line">PC2           192.168.20.2     192.168.20.1</span><br><span class="line">PC3           192.168.10.3     192.168.10.1</span><br><span class="line">PC4           192.168.20.3     192.168.20.1</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性------------------------------------------</span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.2</span><br><span class="line">Reply from 192.168.10.2: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.3</span><br><span class="line">Reply from 192.168.10.3: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆单臂路由实现VLAN◆"><a href="#◆单臂路由实现VLAN◆" class="headerlink" title="◆单臂路由实现VLAN◆"></a>◆单臂路由实现VLAN◆</h3><p>单臂路由是指在路由器的一个物理接口上通过配置子接口的方式,实现原来相互隔离的不同VLAN之间的通信,子接口是在物理接口上衍生出来的逻辑接口,一个物理接口可以衍生出许多的逻辑接口.</p><p>一般路由器的物理接口数量有限,如果每个VLAN都使用一个物理接口进行连接,在网络中VLAN数量较多的情况下需要使用多台路由器才能实现VLAN之间的通信,而通过使用子接口可以在一个物理接口上容纳更多的VLAN,从而很好的解决了此问题.</p><p><img src="/picture/20190404140610.jpg" alt="blockchain"></p><p><strong>配置交换机:</strong> 在交换机上创建虚拟局域网<code>vlan10和vlan20</code>,并将<code>Gig0/0/2至Gig0/0/3</code>端口加入到<code>vlan10</code>,然后将<code>Gig0/0/4至Gig0/0/5</code>端口加入到<code>vlan20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] vlan batch 10 20                              // 创建VLAN10和VLAN20</span><br><span class="line"></span><br><span class="line">[Huawei] port-group group-member Gig0/0/2 to Gig0/0/3  // 选择Gig2-3端口</span><br><span class="line">[Huawei-port-group] undo shutdown                      // 开启端口</span><br><span class="line">[Huawei-port-group] port link-type access              // 配置成access模式</span><br><span class="line">[Huawei-port-group] port default vlan 10               // 将端口加入到vlan 10</span><br><span class="line"></span><br><span class="line">[Huawei] port-group group-member Gig0/0/4 to Gig0/0/5</span><br><span class="line">[Huawei-port-group] undo shutdown</span><br><span class="line">[Huawei-port-group] port link-type access</span><br><span class="line">[Huawei-port-group] port default vlan 20</span><br></pre></td></tr></table></figure></p><p><strong>设置Trunk模式:</strong> 将<code>交换机</code>与路由器相连的端口设置为<code>Trunk模式</code>,此处设置交换机的<code>Gig0/0/1口</code>将其设置为Trunk干道模式.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] interface GigabitEthernet 0/0/1                           // 选择Gig0/0/1接口</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] port link-type trunk                 // 配置成trunk模式</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] port trunk allow-pass vlan all       // 应用于所有接口</span><br><span class="line">[Huawei-GigabitEthernet0/0/1] display this                         // 显示配置结果</span><br><span class="line">#</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> port link-type trunk</span><br><span class="line"> port trunk allow-pass vlan 2 to 4094</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器子接口:</strong> 在路由器的<code>Ethernet0/0/0</code>接口上创建逻辑接口,并使用<code>IEEE802.1Q协议</code>封装,此处我们创建两个子接口即可.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] sysname R1</span><br><span class="line"></span><br><span class="line">[R1] interface Ethernet 0/0/0.1                    // 创建一个子接口</span><br><span class="line">[R1-Ethernet0/0/0.1] ip add 192.168.10.1 24        // 指定子接口ip地址</span><br><span class="line">[R1-Ethernet0/0/0.1] dot1q termination vid 10      // 和vlan10相关联</span><br><span class="line">[R1-Ethernet0/0/0.1] arp broadcast enable          // 开启arp广播包</span><br><span class="line"></span><br><span class="line">[R1] interface Ethernet 0/0/0.2                    // 创建一个子接口</span><br><span class="line">[R1-Ethernet0/0/0.1] ip add 192.168.20.1 24        // 指定子接口ip地址</span><br><span class="line">[R1-Ethernet0/0/0.1] dot1q termination vid 20      // 和vlan10相关联</span><br><span class="line">[R1-Ethernet0/0/0.1] arp broadcast enable          // 开启arp广播包</span><br><span class="line">[R1-Ethernet0/0/0.1] quit</span><br><span class="line"></span><br><span class="line">[R1] display ip routing-table                      // 查询路由记录</span><br></pre></td></tr></table></figure></p><p><strong>客户机配置网关:</strong> 给每个客户机配置好IP地址和网关参数,并测试连通性.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#----设置客户主机IP地址+网关------------------------------------------</span></span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC1           192.168.10.2     192.168.10.1</span><br><span class="line">PC2           192.168.10.3     192.168.10.1</span><br><span class="line">PC3           192.168.20.2     192.168.20.1</span><br><span class="line">PC4           192.168.20.3     192.168.20.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#----设置好后测试网络连通性------------------------------------------</span></span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.2</span><br><span class="line">Reply from 192.168.10.2: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.3</span><br><span class="line">Reply from 192.168.10.3: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.2</span><br><span class="line">error</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="huawei" scheme="https://localhost/tags/huawei/"/>
    
  </entry>
  
  <entry>
    <title>思科设备ACL与NAT技术</title>
    <link href="https://localhost/2019/03/21/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E6%80%9D%E7%A7%91%E8%AE%BE%E5%A4%87ACL%E4%B8%8ENAT%E6%8A%80%E6%9C%AF/"/>
    <id>https://localhost/2019/03/21/网络设备配置/思科设备ACL与NAT技术/</id>
    <published>2019-03-21T08:50:21.000Z</published>
    <updated>2019-04-16T06:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>ACL 访问控制列表(Access Control Lists),是应用在路由器(或三层交换机)接口上的指令列表,用来告诉路由器哪些数据可以接收,哪些数据是需要被拒绝的,ACL的定义是基于协议的,它适用于所有的路由协议,并根据预先定义好的规则对数据包进行过滤,从而更好的控制数据的流入与流出.</p><p>NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.</p><a id="more"></a><p><br></p><h2 id="思科ACL访问控制"><a href="#思科ACL访问控制" class="headerlink" title="思科ACL访问控制"></a>思科ACL访问控制</h2><p>路由器接口的访问控制取决于应用在其上的ACL,数据在进出网络前,路由器会根据ACL对其进行匹配,匹配成功将对数据进行过滤或者是转发,匹配失败则丢弃数据包,目前主要有三种ACL控制,<code>标准ACL</code>,<code>扩展ACL</code>,<code>命名ACL</code>,我们只介绍前两种.</p><p>在路由器上应用ACL时,可以为每种协议,每个端口,每个方向,和每个接口,配置一个ACL,一般称为3p原则.</p><p><img src="/picture/20190321184152.jpg" alt="NetWork"></p><h3 id="◆标准ACL配置◆"><a href="#◆标准ACL配置◆" class="headerlink" title="◆标准ACL配置◆"></a>◆标准ACL配置◆</h3><p>标准ALCL只能通过源地址进行访问过滤与控制,因此只能阻止/允许来自指定IP地址的访问请求.</p><p><strong>配置交换机:</strong> 首先配置交换机,这里开启<code>3个端口Fa0/1-3</code>,并配置<code>端口速率100</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0&gt;# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/1-3</span><br><span class="line">Switch0(config-if-range)# speed 100</span><br><span class="line">Switch0(config-if-range)# no shutdown</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Fa0/0和Fa0/1端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# interface GigabitEthernet 0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.1.254 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# interface GigabitEthernet 0/1</span><br><span class="line">Router0(config-if)# ip address 192.168.2.254 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置标准ACL:</strong> 在路由器上配置一条标准的ACL规则,<code>禁止PC0访问Server0</code>服务器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# access-list 1 deny 192.168.1.1 0.0.0.0    // 拒绝192.168.1.1访问Server0</span><br><span class="line">Router0(config)# access-list 1 permit any                  // 设置默认允许所有,兜底操作</span><br><span class="line">Router0(config)#</span><br><span class="line">Router0(config)# interface GigabitEthernet 0/0             // 选择接口Gig0/0</span><br><span class="line">Router0(config-if)# ip access-group 1 in                   // 将以上配置条目应用到当前接口上</span><br><span class="line">#Router0(config-if)# ip access-group 1 out                 // 控制出口流量(可省略)</span><br></pre></td></tr></table></figure></p><p><strong>测试过滤效果:</strong> 配置完规则以后,我们测试一下效果,使用<code>PC0无法访问server服务器</code>而是用<code>PC1则可以访问</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC0&gt; ping 192.168.2.1</span><br><span class="line"></span><br><span class="line">Pinging 192.168.2.1 with 32 bytes of data:</span><br><span class="line">Reply from 192.168.1.254: Destination host unreachable.</span><br><span class="line"></span><br><span class="line">PC1&gt; ping 192.168.2.1</span><br><span class="line"></span><br><span class="line">Pinging 192.168.2.1 with 32 bytes of data:</span><br><span class="line">Reply from 192.168.2.1: bytes=32 time=0ms TTL=127</span><br></pre></td></tr></table></figure></p><p>这里需要注意一点,如果你有两个路由器相连,那么ACL规则应该设置在距离限制的目标较近的路由器上,否则可能会出现有效数据在到达目标之前就被过滤掉了.</p><h3 id="◆拓展ACL配置◆"><a href="#◆拓展ACL配置◆" class="headerlink" title="◆拓展ACL配置◆"></a>◆拓展ACL配置◆</h3><p>标准ACL只能使用源地址作为匹配条件,无法对访问进行精确的控制,为了解决这一问题,可以采用扩展ACL来对数据加以限制.</p><p><strong>配置交换机:</strong> 首先配置交换机,这里开启<code>4个端口Fa0/1-4</code>,并配置端口<code>速率为100</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0&gt;# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/1-4</span><br><span class="line">Switch0(config-if-range)# speed 100</span><br><span class="line">Switch0(config-if-range)# no shutdown</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Fa0/0和Fa0/1端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# interface GigabitEthernet 0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.1.254 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# interface GigabitEthernet 0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.2.254 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置拓展ACL:</strong> 配置拓展ACL规则,<code>禁止PC0访问192.168.2.1</code>,<code>禁止PC1访问192.168.2.1主机的80端口</code>,允许其他所有.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# access-list 100 deny ip host 192.168.1.1 host 192.168.2.1               // 拒绝IP地址</span><br><span class="line">Router0(config)# access-list 100 deny TCP host 192.168.1.2 eq 80 host 192.168.2.1 eq 80  // 拒绝TCP=80</span><br><span class="line">Router0(config)# access-list 100 permit ip any any                                       // 默认允许</span><br><span class="line"></span><br><span class="line">Router0(config)# interface GigabitEthernet 0/0               // 选择接口GigabitEthernet 0/0</span><br><span class="line">Router0(config-if)# ip access-group 100 in                   // 将以上配置条目应用到当前接口上</span><br><span class="line">Router0(config-if)# ip access-group 100 out                  // 将以上配置条目应用到当前接口上</span><br><span class="line">Router0# show access-list                                    // 查询配置结果</span><br></pre></td></tr></table></figure></p><p><strong>测试过滤效果:</strong> 配置完规则后测试下,经测试<code>PC0无法访问Server0</code>,而<code>PC1无法访问目标主机的80端口</code>其他主机放行.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC0&gt; ping 192.168.2.1</span><br><span class="line">Pinging 192.168.2.1 with 32 bytes of data:</span><br><span class="line">Reply from 192.168.1.254: Destination host unreachable.</span><br><span class="line"></span><br><span class="line">PC1&gt; ping 192.168.2.1</span><br><span class="line">Pinging 192.168.2.1 with 32 bytes of data:</span><br><span class="line">Reply from 192.168.2.1: bytes=32 time=0ms TTL=127</span><br></pre></td></tr></table></figure></p><p>与标准ACL相比,扩展ACL能够更加精确的匹配和过滤数据包,因此扩展ACL的放置位置应该离源地址越近越好,这样才能够有效的提高链路的使用效率.<br><br></p><h2 id="思科NAT地址转换"><a href="#思科NAT地址转换" class="headerlink" title="思科NAT地址转换"></a>思科NAT地址转换</h2><p>NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.</p><p>NAT技术中有四种地址即,内部本地地址,内部全局地址,外部本地地址,外部全局地址.</p><h3 id="◆配置静态NAT◆"><a href="#◆配置静态NAT◆" class="headerlink" title="◆配置静态NAT◆"></a>◆配置静态NAT◆</h3><p>静态NAT是指将内部本地地址与内部全局地址进行对应转换,某个本地地址只能转换为某个全局地址,通过配置静态NAT可以实现内部网络对外部网络的访问,也可以实现外部网络对内部网络中某个设备的访问.</p><p><img src="/picture/20190322104720.jpg" alt="NetWork"></p><p><strong>配置交换机:</strong> 首先配置交换机,这里开启<code>4个端口Fa0/1-4</code>,并配置端口<code>速率为100</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0&gt;# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/1-4</span><br><span class="line">Switch0(config-if-range)# speed 100</span><br><span class="line">Switch0(config-if-range)# no shutdown</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Fa0/0和Se0/0/0端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router10上操作-------------------------</span><br><span class="line">Router0(config)# interface fa0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# interface se0/0/0</span><br><span class="line">Router0(config-if)# ip address 10.10.10.1 255.0.0.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1(config)# interface se0/0/0</span><br><span class="line">Router1(config-if)# ip address 10.10.10.2 255.0.0.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置静态NAT:</strong> 在路由器<code>Router0</code>上配置静态NAT,将私有地址转为全局地址<code>(内网地址--&gt;外网地址)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# ip nat inside source static 192.168.1.2 10.10.10.20  // 配置NAT条目1</span><br><span class="line">Router0(config)# ip nat inside source static 192.168.1.3 10.10.10.30  // 配置NAT条目2</span><br><span class="line">Router0(config)# ip nat inside source static 192.168.1.4 10.10.10.40  // 配置NAT条目3</span><br><span class="line"></span><br><span class="line">Router0(config)# interface fa0/0                                      // 选择内部端口</span><br><span class="line">Router0(config-if)# ip nat inside                                     // 应用到定义的内部接口</span><br><span class="line">Router0(config-if)#</span><br><span class="line">Router0(config-if)# interface serial0/0/0                             // 选择外部接口</span><br><span class="line">Router0(config-if)# ip nat outside                                    // 应用到定义的外部接口</span><br><span class="line">Router0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>查询NAT配置:</strong> 配置完成后,我们可以使用<code>show ip nat translation命令</code>,来查询端口情况.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# show ip nat translation</span><br><span class="line"></span><br><span class="line">Pro  Inside global     Inside local       Outside local      Outside global</span><br><span class="line">---  10.10.10.20       192.168.1.2        ---                ---</span><br><span class="line">---  10.10.10.30       192.168.1.3        ---                ---</span><br><span class="line">---  10.10.10.40       192.168.1.4        ---                ---</span><br></pre></td></tr></table></figure></p><p><strong>测试通信情况:</strong> 此时测试下通信情况,在<code>PC0-PC2主机可Ping通Router1</code>,同样<code>Router1可Ping通PC0-PC2</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC0&gt; ping 10.10.10.2</span><br><span class="line">Pinging 10.10.10.2 with 32 bytes of data:</span><br><span class="line">Reply from 10.10.10.2: bytes=32 time=1ms TTL=254</span><br><span class="line"></span><br><span class="line">Router1# ping 10.10.10.20</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.10.10.20, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/5/9 ms</span><br></pre></td></tr></table></figure></p><h3 id="◆配置动态NAT◆"><a href="#◆配置动态NAT◆" class="headerlink" title="◆配置动态NAT◆"></a>◆配置动态NAT◆</h3><p>动态NAT是指内部本地地址与内部全局地址进行转换时,内部地址可以随机转换为指定的外部全局地址,此过程是动态分配的不需要认为干预,从而减少了配置的工作量.</p><p>但需要注意的是,配置动态NAT只能实现内部网络对互联网的访问,无法实现互联网中的主机对内部网络中的主机的访问,也就是说,它是一种单向的NAT技术.</p><p><strong>清除NAT列表:</strong> 动态NAT的配置我们同样适用上面的拓扑图,只是在NAT的配置上有些小改动.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# clear ip nat translation *             // 清除动态NAT转换列表</span><br><span class="line">Router0# show ip access-list                    // 显示ACL配置信息</span><br><span class="line">Router0# show ip nat statistics                 // 查看NAT转换统计信息</span><br><span class="line">Router0# clear ip nat statistics                // 清除NAT转换统计信息</span><br></pre></td></tr></table></figure></p><p><strong>配置交换机:</strong> 首先配置交换机,这里开启<code>4个端口Fa0/1-4</code>,并配置端口<code>速率为100</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0&gt;# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/1-4</span><br><span class="line">Switch0(config-if-range)# speed 100</span><br><span class="line">Switch0(config-if-range)# no shutdown</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Fa0/0和Se0/0/0端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0(config)# interface fa0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# interface se0/0/0</span><br><span class="line">Router0(config-if)# ip address 10.10.10.1 255.0.0.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1(config)# interface se0/0/0</span><br><span class="line">Router1(config-if)# ip address 10.10.10.2 255.0.0.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置动态NAT:</strong> 这里分配外网IP范围是<code>10.10.10.20-40</code>,内部地址范围是<code>192.168.1.0/24</code>,并绑定好接口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# ip nat pool NAT 10.10.10.20 10.10.10.40 netmask 255.0.0.0 //定义内部全局IP地址池</span><br><span class="line">Router0(config)# access-list 1 permit 192.168.1.0 0.0.0.255       // 定义可转换的内部本地IP地址</span><br><span class="line">Router0(config)# ip nat inside source list 1 pool NAT   //配置动态NAT映射,将NAT地址池与ACL关联</span><br><span class="line"></span><br><span class="line">Router0(config)# interface fa0/0                      // 配置内部端口</span><br><span class="line">Router0(config-if)# ip nat inside</span><br><span class="line"></span><br><span class="line">Router0(config-if)# interface serial0/0/0             // 配置外部端口</span><br><span class="line">Router0(config-if)# ip nat outside</span><br><span class="line">Router0(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>查询NAT配置:</strong> 配置完成后,我们可以使用<code>show ip nat translation命令</code>,来查询端口情况.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# show ip nat translation</span><br><span class="line"></span><br><span class="line">Pro  Inside global     Inside local       Outside local      Outside global</span><br><span class="line">icmp 10.10.10.21:5     192.168.1.3:5      10.10.10.2:5       10.10.10.2:5</span><br><span class="line">icmp 10.10.10.21:6     192.168.1.3:6      10.10.10.2:6       10.10.10.2:6</span><br><span class="line">icmp 10.10.10.22:9     192.168.1.3:9      10.10.10.2:9       10.10.10.2:9</span><br><span class="line">icmp 10.10.10.23:10    192.168.1.2:10     10.10.10.2:10      10.10.10.2:10</span><br></pre></td></tr></table></figure></p><h3 id="◆多路复用PAT◆"><a href="#◆多路复用PAT◆" class="headerlink" title="◆多路复用PAT◆"></a>◆多路复用PAT◆</h3><p>端口多路复用即端口地址转换<code>(PAT,Port Address Translation)</code>,是指将内部本地IP地址动态的转换为单一的内部全局IP地址和端口号,内部全局IP地址只是用一个,而不是一组地址池,也就是一个IP地址绑定多个端口,从而更大的节约了IP地址的资源短缺.</p><p><img src="/picture/20190322135822.jpg" alt="NetWork"></p><p><strong>配置交换机:</strong> 首先配置交换机,这里开启<code>4个端口Fa0/1-4</code>,并配置端口<code>速率为100</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0&gt;# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/1-4</span><br><span class="line">Switch0(config-if-range)# speed 100</span><br><span class="line">Switch0(config-if-range)# no shutdown</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着配置路由器,开启路由器的<code>Fa0/0和Se0/0/0端口</code>,并配置上网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0(config)# interface fa0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# interface se0/0/0</span><br><span class="line">Router0(config-if)# ip address 10.10.10.1 255.0.0.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1(config)# interface se0/0/0</span><br><span class="line">Router1(config-if)# ip address 10.10.10.2 255.0.0.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置多路复用PAT:</strong> 在路由器<code>Router0</code>上配置PAT,多路复用.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# ip nat pool PAT 10.10.10.10 10.10.10.10 netmask 255.0.0.0  // 定义外网IP地址</span><br><span class="line">Router0(config)# access-list 1 permit 192.168.1.0 0.0.0.255                 // 定义ACL</span><br><span class="line">Router0(config)# ip nat inside source list 1 pool PAT overload              // 将地址池与ACL绑定</span><br><span class="line"></span><br><span class="line">Router0(config)# interface fa0/0                 // 定义连接内部网络的接口</span><br><span class="line">Router0(config-if)# ip nat inside</span><br><span class="line">Router0(config-if)# interface serial0/0/0        // 定义链接外部网络的接口</span><br><span class="line">Router0(config-if)# ip nat outside</span><br></pre></td></tr></table></figure></p><p><strong>查询配置地址表:</strong> 最后可以检测一下是否能够连接到内部与外部的主机.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router#show ip nat translations</span><br><span class="line"></span><br><span class="line">Pro  Inside global     Inside local       Outside local      Outside global</span><br><span class="line">icmp 10.10.10.10:1024  192.168.1.4:1      10.10.10.2:1       10.10.10.2:1024</span><br><span class="line">icmp 10.10.10.10:1025  192.168.1.2:8      10.10.10.2:8       10.10.10.2:1025</span><br><span class="line">icmp 10.10.10.10:1027  192.168.1.3:1      10.10.10.2:1       10.10.10.2:1027</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ACL 访问控制列表(Access Control Lists),是应用在路由器(或三层交换机)接口上的指令列表,用来告诉路由器哪些数据可以接收,哪些数据是需要被拒绝的,ACL的定义是基于协议的,它适用于所有的路由协议,并根据预先定义好的规则对数据包进行过滤,从而更好的控制数据的流入与流出.&lt;/p&gt;
&lt;p&gt;NAT 网络地址转换(Network Address Translation),是一个互联网工程任务组的标准,它可以实现内部私有IP地址和公网IP地址的转换,能够起到节约公网IP地址的作用,以下将介绍NAT的三种方式,静态转换、动态转换和端口复用技术.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Cisco" scheme="https://localhost/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>思科路由器配置笔记</title>
    <link href="https://localhost/2019/03/15/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://localhost/2019/03/15/网络设备配置/思科路由器配置笔记/</id>
    <published>2019-03-15T03:45:06.000Z</published>
    <updated>2019-04-16T06:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>路由器(Router),是连接因特网中各局域网、广域网的设备,它会根据信道的情况自动选择和设定路由,以最佳路径,按前后顺序发送信号,路由器工作在网络层,用来跨网段通信,路由器具有判断网络地址和选择IP路径的功能,它能在多网络互联环境中,建立灵活的连接,可用完全不同的数据分组和介质访问方法连接各种子网,路由器只接受源站或其他路由器的信息,属网络层的一种互联设备,因此路由器是互联网中必不可少的网络设备之一.</p><a id="more"></a><p>路由器,其最重要的功能就是路由,路由是指路由器接收到数据时选择最佳路径将数据穿过网络传输到目标地址的行为,每个路由器负责自己的本地数据的路由或转发,通过多个路由器依次接力将数据最终传递到目标主机,路由的工作流程包括<code>路由选择</code>和<code>路由转发</code>两个方面.<br><br></p><h2 id="路由基本配置"><a href="#路由基本配置" class="headerlink" title="路由基本配置"></a>路由基本配置</h2><p>路由器与交换机不同,交换机不需要配置也可以正常工作,但是<code>路由器必须经过配置后才可以正常使用</code>,路由器的登陆方式基本和交换机保持一致,下面将用一个实例实现路由器的基本配置,包括配置路由器的主机名称,密码,控制台端口,WAN接口和LAN接口等,来实现一个基本的路由结构.</p><p>首先我们准备两台<code>路由器(1841型号)</code>,需要注意的是设备之间的连接所选用的线路类型,一般情况下<code>路由器和PC之间使用交叉线</code>,<code>两台路由器相连接使用串行线</code>,配置成以下拓扑结构即可:</p><p><img src="/picture/20190315155343.jpg" alt="NetWork"></p><p>但在实际连接两个路由器时,发现没有<code>Serial接口</code>,这是因为该型号的路由器默认没有提供串口,我们可以在思科模拟器上选择<code>WIC-2T模块</code>,并将其拖入空的插槽处,重启交换机即可完成配置.</p><p><img src="/picture/20190315160112.jpg" alt="NetWork"></p><p>接着来看一下网络拓扑结构中,每个设备的具体配置参数,包括类型,IP地址,默认网关等信息.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[设备名称]   [设备接口]         [IP地址]           [默认网关]</span><br><span class="line">   PC1         ---          192.168.1.2/24      192.168.1.1</span><br><span class="line">   PC2         ---          192.168.2.2/24      192.168.2.1</span><br><span class="line"></span><br><span class="line"> Router0      Fa0/0         192.168.1.1/24         ---</span><br><span class="line">              Serial0/0/0   10.10.10.10/24         ---</span><br><span class="line"></span><br><span class="line"> Router1      Fa0/0         192.168.2.1/24         ---</span><br><span class="line">              Serial0/0/0   10.10.10.20/24         ---</span><br></pre></td></tr></table></figure></p><p><strong>开启路由远程登陆:</strong> 这里我们将启用<code>Router1路由器</code>的远程登陆功能,并设置一个登陆密码为<code>lyshark</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router# enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">Router(config)# hostname Router0             // 配置主机名为Router0</span><br><span class="line">Router0(config)# enable secret lyshark       // 配置特权模式密码为lyshark</span><br><span class="line"></span><br><span class="line">Router0(config)# line console 0              // 启用控制台</span><br><span class="line">Router0(config-line)# password lyshark       // 设置控制台登录密码</span><br><span class="line">Router0(config-line)# login                  // 允许用户登录</span><br><span class="line">Router0(config-line)# exit</span><br><span class="line"></span><br><span class="line">Router0(config)# line vty 0 2                // 配置序号为0-2的3个虚拟登陆终端</span><br><span class="line">Router0(config-line)# password lyshark       // 配置终端登录密码</span><br><span class="line">Router0(config-line)# login                  // 启用登陆终端</span><br></pre></td></tr></table></figure></p><p><strong>配置WAN接口:</strong> 路由器通过WAN接口接入到互联网上,而常见的WAN接口都是串行接口用<code>Serial表示</code>,首先可以使用<code>show controller 命令</code>判断<code>Serial 0/0/0</code>是否为DCE端,然后决定是否要配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0&gt; show controller Serial0/0/0</span><br><span class="line"></span><br><span class="line">Interface Serial0/0/0</span><br><span class="line">Hardware is PowerQUICC MPC860</span><br><span class="line">DCE V.35, clock rate 2000000       // 此处判断是DEC端</span><br></pre></td></tr></table></figure></p><p>根据上述标注显示内容<code>Srial0/0/0</code>为DCE端口,下面需要对两台路由分别配置时钟频率.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line">Router0(config)# interface Serial0/0/0                    // 选择串行接口Srial0/0/0</span><br><span class="line">Router0(config-if)# ip address 10.10.10.10 255.255.255.0  // 配置外网IP地址</span><br><span class="line">Router0(config-if)# clock rate 64000                      // 配置始终频率为6400</span><br><span class="line">Router0(config-if)# no shutdown                           // 开启端口</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1&gt; enable</span><br><span class="line">Router1# configure terminal</span><br><span class="line">Router1(config)# interface Serial0/0/0</span><br><span class="line">Router1(config-if)# ip address 10.10.10.20 255.255.255.0</span><br><span class="line">Router1(config-if)# clock rate 64000</span><br><span class="line">Router1(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>配置LAN接口:</strong> LAN接口用来指定内网通讯的地址,接下来分别对两台路由器做配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line">Router0(config)# interface fa0/0                        // 选择以太网接口fa0/0</span><br><span class="line">Router0(config)# ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Router0(config)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1&gt; enable</span><br><span class="line">Router1# configure terminal</span><br><span class="line">Router1(config)# interface fa0/0</span><br><span class="line">Router1(config)# ip address 192.168.2.1 255.255.255.0</span><br><span class="line">Router1(config)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>查配置信息:</strong> 最后可以使用<code>show ip route命令</code>,查看路由器的路由信息,确定网络是否正确连接.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# show ip route</span><br><span class="line">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class="line">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class="line">       * - candidate default, U - per-user static route, o - ODR</span><br><span class="line">       P - periodic downloaded static route</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">     10.0.0.0/24 is subnetted, 1 subnets</span><br><span class="line">C    10.10.10.0 is directly connected, Serial0/0/0            // 外网地址</span><br><span class="line">C    192.168.1.0/24 is directly connected, FastEthernet0/0    // 内网地址</span><br></pre></td></tr></table></figure></p><p><strong>查接口信息:</strong> 也可以使用<code>show ip interface brief命令</code>,查看路由器的接口信息.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# show ip interface brief</span><br><span class="line"></span><br><span class="line">Interface              IP-Address      OK? Method Status                Protocol </span><br><span class="line">FastEthernet0/0        192.168.1.1     YES manual up                    up</span><br><span class="line">Serial0/0/0            10.10.10.10     YES manual up                    up</span><br><span class="line">Serial0/0/1            unassigned      YES unset  administratively down down</span><br><span class="line">Vlan1                  unassigned      YES unset  administratively down down</span><br></pre></td></tr></table></figure></p><p><strong>最后测试通信:</strong> 在路由器<code>Route0</code>上可以ping通<code>Route1</code>,每个主机也可以ping通自己网段的路由器.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router0# ping 10.10.10.20</span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.10.10.20, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/2/6 ms</span><br></pre></td></tr></table></figure></p><p>上述小实验到这里就算配置成功了,但是这里留下了一个疑问,那就是<code>PC0</code>Ping<code>PC1</code>无法通信,这就涉及到路由器没有相应的路由条目的问题,这些问题将在后面小实验中做解释.<br><br></p><h2 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h2><p>静态路由需要管理员根据实际需求一条条自己手动配置,路由器不会自动生成所需的静态路由,静态路由中包括目标节点或目标网络的IP地址,还可以包括下一跳IP地址,以及在本路由器上使用该静态路由时的数据包出接口等,但是手动配置静态路由需要管理员非常了解网络的拓扑结构才能够完成配置,在网络规模较大时还需要耗费大量的经历和时间去维护,所以并不是所有的网络都适合配置静态路由.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 一般情况下以下几种情况可以考虑使用静态路由</p><blockquote><p>1.网络的拓扑结构相对较简单,比如就一台路由器和交换机的情况,可使用静态路由.<br>2.网络保密性要求较高,网络管理员需要控制链路或者控制路由表,则可使用静态路由.<br>3.网络仅通过单个ISP接入Internet,则该ISP就是网络唯一的出口,所以不需要配置静态路由.<br>4.路由资源有限,无法运行路由选择协议,在这种情况下,需要手动配置路由条目来更新路由表数据.</p></blockquote></blockquote><p>接下来以一个实例具体介绍静态路由的配置流程,在思科模拟器中选择2台<code>1841路由器</code>,按照以下网络拓扑结构构建网路,然后为每台路由器配置静态路由,实现不同网络间的数据互通.</p><p><img src="/picture/20190316171921.jpg" alt="NetWork"></p><p><strong>配置客户主机:</strong> 首先我们根据上图的配置要求配置好IP地址网关等数据,下面的参数是具体的地址规划.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[设备名称]   [设备接口]         [IP地址]           [默认网关]</span><br><span class="line">   PC0         ---          192.168.1.2/24      192.168.1.1</span><br><span class="line">   PC1         ---          192.168.1.3/24      192.168.1.1</span><br><span class="line"></span><br><span class="line">   PC2         ---          192.168.2.2/24      192.168.2.1</span><br><span class="line">   PC3         ---          192.168.2.3/24      192.168.2.1</span><br><span class="line"></span><br><span class="line"> Router0      Fa0/0         192.168.1.1/24         ---</span><br><span class="line">              Serial0/0/0   10.10.10.10/24         ---</span><br><span class="line"></span><br><span class="line"> Router1      Fa0/0         192.168.2.1/24         ---</span><br><span class="line">              Serial0/0/0   10.10.10.20/24         ---</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 接着我们分别给路由器配置好地址参数,在这里<code>fa0/0端口</code>是内网IP地址,<code>serial0/0/0端口</code>则是外网IP地址,配置是应注意次序,如果配反了则看不到效果.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router0(config)# interface fa0/0                          // 配置内网地址</span><br><span class="line">Router0(config-if)# ip address 192.168.1.1 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">Router0(config)# interface serial0/0/0                    // 配置外网地址</span><br><span class="line">Router0(config-if)# clock rate 64000</span><br><span class="line">Router0(config-if)# ip address 10.10.10.10 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">Router1(config)# interface fa0/0                          // 配置内网地址</span><br><span class="line">Router1(config-if)# ip address 192.168.2.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">Router1(config)# interface serial0/0/0                    // 配置外网地址</span><br><span class="line">Router1(config-if)# clock rate 64000</span><br><span class="line">Router1(config-if)# ip address 10.10.10.20 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>检测路由配置:</strong> 当配置好上面的步骤以后,PC0与PC1主机是可通信的,Route0与Route1也可通信,但PC0无法与PC3通信,原因就是因为路由器没有配置静态路由的关系,这一步我们只需要确保同一个网段内能通信即可.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在PC0上操作-------------------------</span><br><span class="line">PC0&gt; ping 192.168.1.1</span><br><span class="line">PC0&gt; ping 192.168.1.2</span><br><span class="line">PC0&gt; ping 192.168.1.3</span><br><span class="line">Pinging 192.168.1.3 with 32 bytes of data:</span><br><span class="line">Reply from 192.168.1.3: bytes=32 time=0ms TTL=128</span><br><span class="line"></span><br><span class="line">#----在Route0上操作----------------------</span><br><span class="line">Router0#ping 10.10.10.20</span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.10.10.20, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/7/12 ms</span><br></pre></td></tr></table></figure></p><p><strong>配置静态路由:</strong> 接下来我们需要在两台路由器上分别配置路由条目,使用<code>ip route命令</code>配置,如果想要删除路由可使用<code>no ip route命令</code>即可删除指定路由条目.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Router0上操作-------------------------</span><br><span class="line">Router0&gt; enable</span><br><span class="line">Router0# configure terminal</span><br><span class="line"></span><br><span class="line">                           [目的网络]    [目的掩码]         [下一跳地址]</span><br><span class="line">Router0(config)# ip route 192.168.2.0  255.255.255.0      10.10.10.20</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1&gt; enable</span><br><span class="line">Router1# configure terminal</span><br><span class="line">Router1(config)# ip route 192.168.1.0 255.255.255.0 10.10.10.10        // 指定返回时的路由</span><br><span class="line"></span><br><span class="line">#----检查配置参数情况-------------------------</span><br><span class="line">Router0# show ip interface brief          // 显示端口ip</span><br><span class="line">Router0# show ip route                    // 检查路由参数</span><br><span class="line">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class="line">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class="line">       * - candidate default, U - per-user static route, o - ODR</span><br><span class="line">       P - periodic downloaded static route</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line">     10.0.0.0/24 is subnetted, 1 subnets</span><br><span class="line">C    10.10.10.0 is directly connected, Serial0/0/0</span><br><span class="line">C    192.168.1.0/24 is directly connected,FastEthernet0/0</span><br><span class="line">S    192.168.2.0/24 [1/0] via 10.10.10.20</span><br></pre></td></tr></table></figure></p><p><strong>最后的测试:</strong> 当配置好路由条目以后,我们在PC0主机上Ping检测PC3的连通性,会发现原来无法连通的两个网段,现在可以正常通信了,也就说明我们的路由配置生效了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PC0&gt; ping 192.168.2.2</span><br><span class="line"></span><br><span class="line">Pinging 192.168.2.2 with 32 bytes of data:</span><br><span class="line"></span><br><span class="line">Reply from 192.168.2.2: bytes=32 time=12ms TTL=126</span><br><span class="line"></span><br><span class="line">Ping statistics for 192.168.2.2:</span><br><span class="line">    Packets: Sent = 1, Received = 1, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip times in milli-seconds:</span><br><span class="line">    Minimum = 12ms, Maximum = 12ms, Average = 12ms</span><br></pre></td></tr></table></figure></p><p>以上的路由配置方法,适用于小型网络环境,在大型网络环境中这种静态路由的配置方式很不适合维护,一旦设备过多,则可能自己都搞不清头绪,所以在生产环境中,我们会使用动态路由的方式来实现路由器的配置,接下来继续学习动态路由的配置方式吧.<br><br></p><h2 id="RIP-动态路由"><a href="#RIP-动态路由" class="headerlink" title="RIP 动态路由"></a>RIP 动态路由</h2><p>动态路由是基于某种协议实现的,常见的路由协议有内<code>内部网关协议(IGP)</code>和<code>边界网关协议(BGP)</code>,其中内部网关协议又分为<code>路由信息协议(RIP)</code>和<code>开放式最短路径优先协议(OSPF)协议</code>.</p><p>其中<code>RIP(路由信息协议)</code>是最先被广泛应用的内部网关路由协议,RIP使用跳数来衡量到达目标地址的距离,跳数是指数据从源地址到达目标地址之间经过的路由器个数.从路由器到直接连接的网络的跳数定义为1,每经过一个路由器则数值会增加1,RIP允许的<code>最大跳数是15跳</code>,超过15跳的网络将无法到达,因此RIP适合用于小型的网络环境中.</p><p>RIP协议默认会<code>每隔30秒</code>就会与其他相连的网络广播自己的路由表,收到广播的路由器会将收到的信息与自己路由表进行比较,判断是否将其中的路由条目加入到自己的路由表中,目前RIP共有3中版本,<code>RIPv1,RIPv2,RIPng</code>,其中RIPng应用于IPv6网络环境中,RIPv1是有类路由协议,RIPv2则是无类路由协议.</p><p><img src="/picture/20190317122102.jpg" alt="NetWork"></p><p><strong>配置参数简介:</strong> 首先我们根据上图的配置要求配置好路由器各种基本参数,下面的参数是具体的地址规划.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[设备名称]     [设备接口]        [IP地址]          [默认网关]</span><br><span class="line"></span><br><span class="line"> Router1     Serial0/0/0    192.168.10.1/24         ---</span><br><span class="line"></span><br><span class="line"> Router2     Serial0/0/0    192.168.10.2/24         ---</span><br><span class="line">             Serial0/0/1    192.168.20.1/24         ---</span><br><span class="line"></span><br><span class="line"> Router3     Serial0/0/0    192.168.20.2/24         ---</span><br><span class="line">             Serial0/0/1    192.168.30.1/24         ---</span><br><span class="line"></span><br><span class="line"> Router4     Serial0/0/0    192.168.30.2/24         ---</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 根据上表的结构配置好路由器的各种参数,主要配置路由器的接口IP地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1(config)# interface Serial0/0/0</span><br><span class="line">Router1(config-if)# ip address 192.168.10.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router2上操作-------------------------</span><br><span class="line">Router2(config)# interface Serial0/0/0</span><br><span class="line">Router2(config-if)# ip address 192.168.10.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router2(config)# interface Serial0/0/1</span><br><span class="line">Router2(config-if)# ip address 192.168.20.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router3上操作-------------------------</span><br><span class="line">Router3(config)# interface Serial0/0/0</span><br><span class="line">Router3(config-if)# ip address 192.168.20.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router3(config)# interface Serial0/0/1</span><br><span class="line">Router3(config-if)# ip address 192.168.30.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router4上操作-------------------------</span><br><span class="line">Router4(config)#interface Serial0/0/0</span><br><span class="line">Router4(config-if)#ip address 192.168.30.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>配置并启用RIP路由:</strong> 在每台路由器上启用并配置好RIP动态路由.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line">#----在Router1上启用RIP路由协议并配置-------------------</span><br><span class="line">Router1(config)# router rip                   // 启用RIP路由</span><br><span class="line">Router1(config-router)# version 2             // 指定使用RIP版本为RIPv2</span><br><span class="line">Router1(config-router)# network 192.168.10.0  // 声明与Router1直连的网络号</span><br><span class="line">Router1(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router2上启用RIP路由协议并配置-------------------</span><br><span class="line">Router2(config)# router rip</span><br><span class="line">Router2(config-router)# version 2</span><br><span class="line">Router2(config-router)# network 192.168.10.0  // 声明与Router2直连的网络号</span><br><span class="line">Router2(config-router)# network 192.168.20.0  // 声明与Router3直连的网络号</span><br><span class="line">Router2(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router3上启用RIP路由协议并配置-------------------</span><br><span class="line">Router3(config)# router rip</span><br><span class="line">Router3(config-router)# version 2</span><br><span class="line">Router3(config-router)# network 192.168.20.0  // 声明与Router3直连的网络号</span><br><span class="line">Router3(config-router)# network 192.168.30.0  // 声明与Router4直连的网络号</span><br><span class="line">Router3(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router4上启用RIP路由协议并配置-------------------</span><br><span class="line">Router4(config)# router rip</span><br><span class="line">Router4(config-router)# version 2</span><br><span class="line">Router4(config-router)# network 192.168.30.0  // 声明与Router4直连的网络号</span><br><span class="line">Router4(config-router)# exit</span><br></pre></td></tr></table></figure></p><p><strong>检查配置信息:</strong> 配置完成后,在<code>Router1</code>上执行<code>show ip route 命令</code>查看RIP配置结果,如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router1#show ip route</span><br><span class="line">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class="line">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class="line">       * - candidate default, U - per-user static route, o - ODR</span><br><span class="line">       P - periodic downloaded static route</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">C    192.168.10.0/24 is directly connected, Serial0/0/0</span><br><span class="line">R    192.168.20.0/24 [120/1] via 192.168.10.2, 00:00:01, Serial0/0/0   // R表示当前是RIP路由</span><br><span class="line">R    192.168.30.0/24 [120/2] via 192.168.10.2, 00:00:01, Serial0/0/0   // 路由条目是RIP自动生成的</span><br></pre></td></tr></table></figure></p><p><strong>测试连通性:</strong> 此时我们在<code>Router1</code>路由器上Ping路由器<code>Router4</code>是可以通信的,说明配置成功了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router1#ping 192.168.30.2</span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.30.2, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 3/15/27 ms</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="OSPF-动态路由"><a href="#OSPF-动态路由" class="headerlink" title="OSPF 动态路由"></a>OSPF 动态路由</h2><p>在上面的配置试验中我们通过使用<code>RIP协议</code>完成了一个路由器之间的数据通信,但是RIP协议最大仅仅支持15个路由节点,虽然在中小型网络中这些节点足够使用了,但是在一些大型企业中往往需更多的跳数,就是因为这种需求我们的<code>OSPF协议</code>就由此诞生啦.</p><p><code>OSPF(开放式最短路径优先)</code>,该协议是基于链路状态的协议规范,因此也可以称为<code>链路状态协议</code>,和RIP协议相同,OSPF协议<code>同样使用跳数</code>计量路径开销,但是与RIP不同的是,OSPF协议不受物理跳数的限制,其路径开销与网络中的链路开销等相关.</p><p>OSPF协议采用了<code>FPS算法</code>来计算最短路径数,SPF算法将每一个路由作为<code>根(ROOT)</code>,来计算其数据包到达每一个目标路由器之间的距离,每个路由器根据一个<code>统一的数据库LSDB</code>计算出<code>路由域</code>的拓扑结构图,该结构很像是一颗树,所以就叫做最短路径树.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> OSPF协议的优点</p><blockquote><p>1.OSPF采用了SPF算法,从而可以很好的避免路由器环路的产生.<br>2.OSPF协议虽然也使用跳数作为计量单位,但不受物理跳数的限制.<br>3.当网络链路状态发生变化时,OSPF能够迅速捕捉并应用,收敛快,路由信息流量小.<br>4.OSPF路由协议支持路由认证体系,且还可以定义不同的认证方式,提高了网络安全性.<br>5.OSPF协议提供了较好的负载均衡性,其数据更新比较智能,相应的减小了网络流量的带宽.</p></blockquote></blockquote><p>在配置OSPF路由之前还有一个小知识点需要补充,在下面的配置试验中你会看到例如<code>0.0.0.255</code>这样的网络号,这种网络号被称作<code>通配符掩码</code>,通常情况下通配符掩码可由,<code>255.255.255.255(广播地址)</code>减去当前的<code>255.255.255.0(子网掩码)</code>,来获得,此处小实验的通配符掩码为<code>0.0.0.255 area 0</code>.</p><p>接下来开始步入正题,我们还是<code>使用RIP路由的拓扑结构</code>以<code>及IP地址</code>的配置都相同,但是这里在配置动态路由的时候,我们使用OSPF的方式来配置,过程如下:</p><p><strong>配置路由器:</strong> 首先更具上表的结构配置好路由器的各种参数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router1上操作-------------------------</span><br><span class="line">Router1(config)# interface Serial0/0/0</span><br><span class="line">Router1(config-if)# ip address 192.168.10.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router2上操作-------------------------</span><br><span class="line">Router2(config)# interface Serial0/0/0</span><br><span class="line">Router2(config-if)# ip address 192.168.10.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router2(config)# interface Serial0/0/1</span><br><span class="line">Router2(config-if)# ip address 192.168.20.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router3上操作-------------------------</span><br><span class="line">Router3(config)# interface Serial0/0/0</span><br><span class="line">Router3(config-if)# ip address 192.168.20.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router3(config)# interface Serial0/0/1</span><br><span class="line">Router3(config-if)# ip address 192.168.30.1 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line"></span><br><span class="line">#----在Router4上操作-------------------------</span><br><span class="line">Router4(config)# interface Serial0/0/0</span><br><span class="line">Router4(config-if)# ip address 192.168.30.2 255.255.255.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>配置并启用OSPF路由:</strong> 在每台路由器上启用并配置好OSPF动态路由.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line"></span><br><span class="line">#----在Router1上启用OSPF路由协议并配置-------------------</span><br><span class="line">Router1(config)# router ospf 1                                 // 启用OSPF路由,并设置进程号为1</span><br><span class="line">Router1(config-router)# router-id 1.1.1.1                      // 为Router1配置RID编号</span><br><span class="line">Router1(config-router)# network 192.168.10.0 0.0.0.255 area 0  // 配置路由记录</span><br><span class="line">Router1(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router2上启用OSPF路由协议并配置-------------------</span><br><span class="line">Router2(config)# router ospf 1                                 // 启用OSPF路由,并设置进程号为1</span><br><span class="line">Router2(config-router)# router-id 2.2.2.2                      // 为Router2配置RID编号</span><br><span class="line">Router2(config-router)# network 192.168.10.0 0.0.0.255 area 0  // 配置路由记录</span><br><span class="line">Router2(config-router)# network 192.168.20.0 0.0.0.255 area 0</span><br><span class="line">Router2(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router3上启用OSPF路由协议并配置-------------------</span><br><span class="line">Router3(config)# router ospf 1                                 // 启用OSPF路由,并设置进程号为1</span><br><span class="line">Router3(config-router)# router-id 3.3.3.3                      // 为Router3配置RID编号</span><br><span class="line">Router3(config-router)# network 192.168.20.0 0.0.0.255 area 0</span><br><span class="line">Router3(config-router)# network 192.168.30.0 0.0.0.255 area 0</span><br><span class="line">Router3(config-router)# exit</span><br><span class="line"></span><br><span class="line">#----在Router4上启用OSPF路由协议并配置-------------------</span><br><span class="line">Router3(config)# router ospf 1                                 // 启用OSPF路由,并设置进程号为1</span><br><span class="line">Router3(config-router)# router-id 4.4.4.4                      // 为Router4配置RID编号</span><br><span class="line">Router3(config-router)# network 192.168.30.0 0.0.0.255 area 0</span><br><span class="line">Router3(config-router)# exit</span><br></pre></td></tr></table></figure></p><p><strong>检查配置信息:</strong> 配置完成后,在<code>Router1</code>上执行<code>show ip route 命令</code>查看OSPF配置结果,如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router#show ip route</span><br><span class="line">Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP</span><br><span class="line">       i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area</span><br><span class="line">       * - candidate default, U - per-user static route, o - ODR</span><br><span class="line">       P - periodic downloaded static route</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">C    192.168.10.0/24 is directly connected, Serial0/0/0                    // C表示是本机默认路由</span><br><span class="line">O    192.168.20.0/24 [110/128] via 192.168.10.2, 00:02:25, Serial0/0/0     // O表示当前是OSPF路由</span><br><span class="line">O    192.168.30.0/24 [110/192] via 192.168.10.2, 00:01:55, Serial0/0/0     // 路由条目是OSPF自动生成的</span><br></pre></td></tr></table></figure></p><p><strong>测试连通性:</strong> 此时我们在<code>Router1</code>路由器上Ping路由器<code>Router4</code>是可以通信的,说明配置成功了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router1#ping 192.168.30.2</span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.30.2, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 3/15/27 ms</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="实战-配置RIP企业环境"><a href="#实战-配置RIP企业环境" class="headerlink" title="实战:配置RIP企业环境"></a>实战:配置RIP企业环境</h2><p>接下来,我们通过使用三层交换机配合路由器,来实现一个跨网段通信的案例,其配置流程是,首先配置三层交换机并划分好VLAN的层次,接着在配置Router0这里不需要配置VLAN,原因是三层交换机与Router0共享VLAN,最后在配置外网口的Router1路由器,其拓扑结构如下图所示:</p><p><img src="/picture/20190319145023.jpg" alt="NetWork"></p><p><strong>配置三层交换:</strong> 首先先来配置三层交换机,创建3个VLAN,并划分成三个VLAN虚拟局域网.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置三层交换的VLAN10并把端口fa0/1加入到VLAN-------------------</span><br><span class="line">Switch(config)# vlan 10                              // 创建VLAN10</span><br><span class="line">Switch(config-vlan)# interface fa0/1                 // 将Fa1俩端口加入到VLAN10</span><br><span class="line">Switch(config-if-range)# switchport mode access</span><br><span class="line">Switch(config-if-range)# switchport access vlan 10   // 把端口加入到VLAN10</span><br><span class="line">Switch(config-if-range)# no shutdown                 // 启用端口</span><br><span class="line">Switch(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----配置三层交换的VLAN20并把端口fa0/2加入到VLAN-------------------</span><br><span class="line">Switch(config)# vlan 20</span><br><span class="line">Switch(config-vlan)# interface fa0/2</span><br><span class="line">Switch(config-if-range)# switchport mode access</span><br><span class="line">Switch(config-if-range)# switchport access vlan 20</span><br><span class="line">Switch(config-if-range)# no shutdown</span><br><span class="line">Switch(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----配置三层交换的VLAN30并把端口fa0/3加入到VLAN-------------------</span><br><span class="line">Switch(config)# vlan 30</span><br><span class="line">Switch(config-vlan)# interface fa0/3</span><br><span class="line">Switch(config-if)# switchport mode access</span><br><span class="line">Switch(config-if)# switchport access vlan 30</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置三层交换IP地址:</strong> 给上面分配好的三个VLAN虚拟局域网一个IP地址,这里指定为各自的网关地址就好.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----给三层交换的VLAN10内的主机添加网关-------------------</span><br><span class="line">Switch(config)# interface vlan 10                            // 选择vlan10接口</span><br><span class="line">Switch(config-if)# ip address 192.168.1.1 255.255.255.0      // 配置网关地址</span><br><span class="line">Switch(config-if)# no shutdown                               // 开启端口</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----给三层交换的VLAN20内的主机添加网关-------------------</span><br><span class="line">Switch(config)# interface vlan 20                            // 选择vlan20接口</span><br><span class="line">Switch(config-if)# ip address 192.168.2.1 255.255.255.0      // 配置网关地址</span><br><span class="line">Switch(config-if)# no shutdown                               // 开启端口</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----给三层交换的VLAN30内的主机添加网关-------------------</span><br><span class="line">Switch(config)# interface vlan 30                            // 选择vlan30接口</span><br><span class="line">Switch(config-if)# ip address 192.168.3.1 255.255.255.0      // 配置网关地址</span><br><span class="line">Switch(config-if)# no shutdown                               // 开启端口</span><br><span class="line">Switch(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器Router0:</strong> 配置好网关后,接着配置路由器Router0,配置接口IP地址,注意在DCE接口需要配置时钟.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置路由fa0/0端口的IP地址-------------------</span><br><span class="line">Router0(config)# interface fa0/0</span><br><span class="line">Router0(config-if)# ip address 192.168.3.2 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置路由fa0/1端口的IP地址-------------------</span><br><span class="line">Router0(config)# interface fa0/1</span><br><span class="line">Router0(config-if)# ip address 192.168.4.1 255.255.255.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置路由se0/0/0连接外网端口IP----------------</span><br><span class="line">Router0(config)# interface se0/0/0</span><br><span class="line">Router0(config-if)# ip address 1.1.1.1 255.0.0.0</span><br><span class="line">Router0(config-if)# no shutdown</span><br><span class="line">Router0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器Router1:</strong> 最后配置外网与内网的衔接路由器Router1,配置好外网口IP地址以及内网口地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置路由器1的内网口地址-------------------</span><br><span class="line">Router1(config)# interface se0/0/0</span><br><span class="line">Router1(config-if)# ip address 1.1.1.2 255.0.0.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br><span class="line">Router1(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置路由器1的外网口地址-------------------</span><br><span class="line">Router1(config)# interface fa0/0</span><br><span class="line">Router1(config-if)# ip address 10.10.10.10 255.0.0.0</span><br><span class="line">Router1(config-if)# no shutdown</span><br></pre></td></tr></table></figure></p><p><strong>开启三层交换机路由:</strong> 开启三层交换机路由功能,并配置RIP动态路由,指明每个路由器的网段地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch(config)# ip routing</span><br><span class="line">Switch(config)# router rip</span><br><span class="line"></span><br><span class="line">Switch(config-router)# network 192.168.1.0</span><br><span class="line">Switch(config-router)# network 192.168.2.0</span><br><span class="line">Switch(config-router)# network 192.168.3.0</span><br><span class="line">Switch(config-router)# network 192.168.4.0</span><br></pre></td></tr></table></figure></p><p><strong>配置二层路由器RIP:</strong> 最后还需要分别配置两个路由器并开启其路由功能.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置路由器Router0-------------------</span><br><span class="line">Router0(config)# router rip</span><br><span class="line">Router0(config-router)# network 192.168.3.0</span><br><span class="line">Router0(config-router)# network 192.168.4.0</span><br><span class="line"></span><br><span class="line">#----配置路由器Router1-------------------</span><br><span class="line">Router1(config)# route rip</span><br><span class="line">Router1(config-router)# network 192.168.3.0</span><br><span class="line">Router1(config-router)# network 192.168.4.0</span><br><span class="line">Router1(config-router)# network 192.168.4.0</span><br><span class="line">Router1(config-router)# network 1.1.1.1</span><br></pre></td></tr></table></figure></p><p>以上配置流程就是全部的实验配置过程,在配置完成功能后,我们首先通过使用ping命令来测试内部主机是否能够Ping通,最后的实验结果是,内网主机均可以实现通信,外网主机无法和内网主机通信.<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由器(Router),是连接因特网中各局域网、广域网的设备,它会根据信道的情况自动选择和设定路由,以最佳路径,按前后顺序发送信号,路由器工作在网络层,用来跨网段通信,路由器具有判断网络地址和选择IP路径的功能,它能在多网络互联环境中,建立灵活的连接,可用完全不同的数据分组和介质访问方法连接各种子网,路由器只接受源站或其他路由器的信息,属网络层的一种互联设备,因此路由器是互联网中必不可少的网络设备之一.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Cisco" scheme="https://localhost/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>思科生成树与端口聚合</title>
    <link href="https://localhost/2019/03/14/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E6%80%9D%E7%A7%91%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%81%9A%E5%90%88/"/>
    <id>https://localhost/2019/03/14/网络设备配置/思科生成树与端口聚合/</id>
    <published>2019-03-14T02:49:38.000Z</published>
    <updated>2019-04-16T06:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.</p><a id="more"></a><p><br></p><h2 id="STP-技术简介"><a href="#STP-技术简介" class="headerlink" title="STP 技术简介"></a>STP 技术简介</h2><h3 id="◆冗余技术概述◆"><a href="#◆冗余技术概述◆" class="headerlink" title="◆冗余技术概述◆"></a>◆冗余技术概述◆</h3><p>冗余技术又称为储备技术,是利用并联模型来提高网络可靠性的一种手段,它通过向网络中增加备用的链路,当一条通信信道出现故障时,自动切换到备用的通信信道,从而提高网络的稳定性和可靠性.</p><p>冗余技术虽然可以提高网络的稳定性和可靠性,但是也会产生许多的问题,如果两个交换机相连的话会造成交换机环路,出现的问题就是随机出现网络不通的现象,严重的话还会导致网络广播风暴,重复拷贝帧,MAC地址表不稳地等情况,但如果是智能交换机的话则不会出现此种情况,以下将分别介绍这几种环路的基本原理.</p><p><strong>广播风暴:</strong> 在物理网络中出现环路现象,且没有采取解决措施的情况下,一旦域内有某个主机发送了广播帧,则当域内的交换机接收到数据后,就会不停的发送和转发广播帧,从而形成网络广播风暴,网络广播风暴会长时间占用网络带宽,和交换机CPU资源,影响网络性能,甚至引起整个网络瘫痪.</p><p><strong>重复拷贝帧:</strong> 重复拷贝帧也称多帧复制,是指单播帧可能被多次复制传送到目标主机上去,此时数据帧的多个副本会保存在目标主机上,从而造成主机资源的浪费,甚至会造成目的主机无法选择其他来源的数据帧而导致数据丢失,简单的来讲就是数据分别从两个口进入了目的主机,导致目的主机MAC地址表中存在多个数据帧,有时还会导致数据的多次覆盖,从而无法接收到准确的数据.</p><p><strong>MAC地址表不稳定:</strong> 一般情况下交换机接收到数据时,会将接收数据帧的端口与发送主机MAC地址的对应关系添加到本机的MAC地址表中,那么如果交换机在不同的端口接收到同一个数据帧的多份副本,将造成MAC地址表在短时间内被多次修改,和循环重复的覆盖,从而影响MAC地址表的稳定性.</p><p>以上几种情况是冗余技术的技术瓶颈所在,在实际的应用中网络的结构往往会很复杂,有更多的冗余链路,从而会产生更多的交换机环路,因此所带来的网络广播风暴,多帧复制会更加的严重,就因为这种需求,STP就由此诞生了.</p><h3 id="◆STP生成树协议◆"><a href="#◆STP生成树协议◆" class="headerlink" title="◆STP生成树协议◆"></a>◆STP生成树协议◆</h3><p>为了解决网络冗余链路所产生的问题,IEEE定义了802.1D协议,即生成树协议STP,利用生成树协议可以避免帧在环路中的增生和无限循环,生成树的主要思想是,当两个交换机之间存在多条链路时,通过一定的算法只激活其中最主要的一条链路,而将其他冗余链路阻塞掉变为备用链路,当主链路出现问题时,生成树协议将自动启用备用链路,整个过程不需要认为干预.</p><p>STP协议中定义了,根桥(RootBridge),根端口(Root Port),指定端口(Designated Port),路径开销(Path Cost)等概念,目的在于通过构建一棵自然树的方法阻塞冗余链路,同时实现链路备份和链路最优化.</p><p>STP协议的通信,是通过桥协议数据单元(BPDU)进行通信的,它是运行STP的交换机之间交流消息帧,所有的支持STP协议的交换机都能接收并处理BPDU报文.</p><blockquote><p><strong>STP工作过程:</strong> 选举根桥-&gt;选举根端口-&gt;选举指定端口-&gt;STP阻塞非根</p><blockquote><p>1.选举根桥:交换机假定自己是根,然后发送BPDU报文给其他交换机,最终选出ID号最小的交换机作为根桥.<br>2.选举根端口:每台非根交换机都会选举出一个根端口,并且仅有一个根端口,并按照优先级选择一个根端口.<br>3.选举指定端口:选择一条网桥到根桥的路径成本最小的路径,或者发送方的网桥ID最大的作为指定端口.<br>4.选择阻塞端口:至此,就会根据STP算法,从多个链路中选择性的阻塞掉一些端口的数据通信.</p></blockquote></blockquote><blockquote><p><strong>STP端口状态:</strong></p><blockquote><p>1.阻塞(Blocking):端口只接受BPDU,不能接收或发送数据,也不能把学习到的MAC地址天机到MAC地址表中.<br>2.转发(Forwarding):端口能够接收并转发数据,也能够学习MAC地址,并添加到MAC地址表中.<br>3.侦听(Listening):该状态是从阻塞到转发状态过程中的临时状态,该状态只能发送和接受BPDU数据.<br>4.学习(Learning):该状态是从阻塞到转发状态过程中的临时状态,该状态不能够发送或接收数据.<br>5.关闭(Disable):该状态端口只提供网络管理服务,不能接受发送任何数据,也就是停止服务的状态.</p></blockquote></blockquote><h3 id="◆RSTP-快速生成树◆"><a href="#◆RSTP-快速生成树◆" class="headerlink" title="◆RSTP 快速生成树◆"></a>◆RSTP 快速生成树◆</h3><p>STP协议虽然解决了链路闭合引起的死循环问题,但是在端口从阻塞状态到转发状态间经过了一个只学习MAC地址但不参与转发的过程,产生了转发延时(默认15秒),从而使得生成树的收敛过程需要较长的时间,一般是转发延时的两倍.</p><p>为了解决STP收敛时间过长的缺点,IEEE又推出了802.1w标准,定义了<code>RSTP(快速生成树)</code>协议.RSTP协议在网络配置参数发生变化时,能够显著的减少网络的收敛时间,由于RSTP是从STP发展而来的,其与STP协议保持高度的兼容性,RSTP协议规定,在某些情况下,处于阻塞状态的端口不必经历<code>阻塞-&gt;侦听-&gt;学习-&gt;转发</code>这一个过程,就可以直接进入转发状态.</p><blockquote><p><strong>RSTP协议只有以下三种:</strong></p><blockquote><p>1.丢弃(Discarding):RSTP将STP中的阻塞,禁用,和侦听统称为丢弃模式.<br>2.学习(Learning):拓扑有所变动情况下,端口处于学习状态并学习MAC地址,将其添加到MAC地址表.<br>3.转发(Forwarding):在网络拓扑稳定后,端口处于转发状态,并开始转发数据包.</p></blockquote></blockquote><p>以上就是生成树协议的常用内容,对比后会发现,RSTP的收敛时间明显低于STP,解决了数据同步过慢的问题所在.<br><br></p><h2 id="生成树的配置"><a href="#生成树的配置" class="headerlink" title="生成树的配置"></a>生成树的配置</h2><p>接下来通过一个具体的实例,来完成生成树的配置命令和配置流程的实践,以下实验我们将把<code>Switch1(三层交换)</code>配置成根桥,将<code>Switch2(二层交换)</code>配置为备份根桥,实验拓扑结构如下图:</p><p><img src="/picture/20190314165105.jpg" alt="NetWork"></p><p><strong>判断根桥:</strong> 首先我们需要判断当前的根桥是哪一个设备,我们分别在四台交换机上执行<code>show spanning-tree 命令</code>,来查询默认那一台是根桥设备,以下实验显示结果为<code>Switch4</code>是根桥设备.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch1# show spanning-tree           // 查询switch1是否为根桥</span><br><span class="line">Switch2# show spanning-tree           // 查询switch2是否为根桥</span><br><span class="line">Switch3# show spanning-tree           // 查询switch3是否为根桥</span><br><span class="line">Switch4# show spanning-tree           // 查询switch4是否为根桥</span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol ieee</span><br><span class="line">  Root ID    Priority    32769            // 根桥ID的优先级</span><br><span class="line">             Address     0003.E41C.0B2C   // 根桥的MAC地址</span><br><span class="line">             This bridge is the root      // 出现这条语句,则说明这台是交换机根桥</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32769            // 网桥ID优先级</span><br><span class="line">             Address     0003.E41C.0B2C   // 网桥的MAC地址</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  20</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Fa0/2            Desg FWD 19        128.2    P2p</span><br><span class="line">Fa0/1            Desg FWD 19        128.1    P2p</span><br></pre></td></tr></table></figure></p><p><strong>指定根桥:</strong> 我们想让<code>Switch1(三层交换)</code>作为根桥设备,此时可在三层交换机上,直接通过以下命令,更换根桥设备.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch1&gt; enable</span><br><span class="line">Switch1# configure terminal</span><br><span class="line">Switch1(config)# spanning-tree vlan 1 root primary     // 将本设备配置成根桥</span><br><span class="line">Switch1(config)# exit</span><br><span class="line">Switch1# show spanning-tree                            // 查询是否配置成功</span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol ieee</span><br><span class="line">  Root ID    Priority    24577</span><br><span class="line">             Address     0004.9A4C.052D</span><br><span class="line">             This bridge is the root                   // 看到这里,说明配置成功了</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    24577  (priority 24576 sys-id-ext 1)</span><br><span class="line">             Address     0004.9A4C.052D</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  20</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Fa0/1            Desg FWD 19        128.1    P2p</span><br><span class="line">Fa0/2            Desg FWD 19        128.2    P2p</span><br></pre></td></tr></table></figure></p><p><strong>指定备份根桥:</strong> 接下来将<code>Switch2(二层交换)</code>指定为备份根桥,当<code>Switch1</code>出现故障后,<code>Switch2</code>将被选举为根桥设备,从而保证网络的正常运转,修改方式通过以下命令即可实现.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch2&gt; enable</span><br><span class="line">Switch2# configure terminal</span><br><span class="line">Switch2(config)#spanning-tree vlan 1 root secondary     // 将本设备配置成根桥</span><br><span class="line">Switch2(config)#exit</span><br><span class="line">Switch2#show spanning-tree</span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol ieee</span><br><span class="line">  Root ID    Priority    24577</span><br><span class="line">             Address     0004.9A4C.052D</span><br><span class="line">             Cost        19</span><br><span class="line">             Port        1(FastEthernet0/1)</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    28673  (priority 28672 sys-id-ext 1)</span><br><span class="line">             Address     00E0.8FAC.DC89</span><br><span class="line">             Hello Time  2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time  20</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Fa0/2            Desg FWD 19        128.2    P2p</span><br><span class="line">Fa0/1            Root FWD 19        128.1    P2p</span><br></pre></td></tr></table></figure></p><p>此时配置到这里,我们可以手动关闭<code>Switch1(三层交换)</code>,然后去查看<code>Switch2(二层交换)</code>,通过<code>show spanning-tree命令</code>,你会发现当三层交换机关机的时候,二层交换机默认变成了根桥,顶替了<code>Switch1</code>的工作,当<code>Switch1</code>启动后,默认会将<code>Switch1</code>再次恢复成根桥.<br><br></p><h2 id="配置端口聚合"><a href="#配置端口聚合" class="headerlink" title="配置端口聚合"></a>配置端口聚合</h2><p>在我们的实际生产环境中,常常将交换机之间用多条链路连接起来,以获得更高的传输能力和网络性能,但根据之前的生成树协议,当交换机之间有冗余链路时,实际工作的链路只有一条,也就是说生成树协议阻碍了网络传输能力的提高.</p><p>为了解决生成树协议的传输能力的不足,出现了一种名为<code>端口聚合</code>的技术,它将多条物理链路组合成一条逻辑线路,实现链路带宽的增加,且还具有冗余作用,当其中部分链路出现故障时,其他链路还可以继续传输数据.</p><blockquote><p>但是并不是所有的端口都可以任意聚合,端口聚合需要满足以下条件.</p><blockquote><p>1.聚合的端口配置需要相同,包括端口速率和传输介质等.<br>2.聚合的端口必须属于同一个VLAN,也就是不许再一个虚拟局域网中.<br>3.聚合的端口类型必须相同,二层端口只能二层聚合,三层端口只能三层聚合.</p></blockquote></blockquote><p>端口聚合形成的逻辑端口称为<code>聚合端口</code>,端口聚合后原来端口的属性就会被聚合端口的属性所覆盖,也不能在源端口上做任何配置,实现端口聚合后,即使网络链路出现故障,只要不是所有链路都故障,网络还是可以继续运行的,只不过网络传输速度会降低而已.</p><p>下面将用一个具体的实例讲解端口聚合的配置方法和配置过程,包括创建聚合端口,配置聚合端口的工作方式和配置负载平衡,首先分别创建<code>两个三层交换机</code>,并通过网线<code>fa0/1-4</code>相连,拓扑图如下:</p><p><img src="/picture/20190314184113.jpg" alt="NetWork"></p><p><strong>创建聚合端口:</strong> 在两台交换机上分别创建聚合端口,且两台交换机端口要一致.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Switch1上操作-------------------------</span><br><span class="line">Switch1(config)#interface port-channel 1          // 创建端口号为1的聚合端口(Switch1)</span><br><span class="line">Switch1(config-if)#exit</span><br><span class="line">#----在Switch2上操作-------------------------</span><br><span class="line">Switch2(config)#interface port-channel 1</span><br><span class="line">Switch2(config-if)#exit</span><br></pre></td></tr></table></figure></p><p><strong>添加聚合端口:</strong> 将图中的<code>fa0/1-4端口</code>加入到聚合端口中,且两台交换机都需要配置.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Switch1上操作-------------------------</span><br><span class="line">Switch1(config)# interface range fa0/1-4            // 选择配置聚合的端口范围</span><br><span class="line">Switch1(config-if-range)# channel-group 1 mode on   // 将所选端口加入到1号聚合,并启动</span><br><span class="line">#----在Switch2上操作-------------------------</span><br><span class="line">Switch2(config)# interface range fa0/1-4</span><br><span class="line">Switch2(config-if-range)# channel-group 1 mode on</span><br></pre></td></tr></table></figure></p><p><strong>配置负载平衡:</strong> 接下来分别在,交换机<code>Switch1</code>和交换机<code>Switch2</code>上配置根据源MAC地址的负载平衡.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Switch1上操作-------------------------</span><br><span class="line">Switch1(config)# port-channel load-balance src-mac   // 配置负载平衡模式为src-mac</span><br><span class="line">#----在Switch2上操作-------------------------</span><br><span class="line">Switch2(config)# port-channel load-balance src-mac</span><br></pre></td></tr></table></figure></p><p><strong>配置聚合端口:</strong> 继续配置聚合端口属性,在交换机<code>Switch2</code>上配置聚合的属性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----在Switch2上操作-------------------------</span><br><span class="line">Switch2(config)# interface port-channel 1      // 选择聚合端口</span><br><span class="line">Switch2(config-if)# switchport mode trunk      // 配置聚合端口工作模式为Trunk</span><br></pre></td></tr></table></figure></p><p><strong>查询是否生效:</strong> 最后通过使用<code>show etherchannel summary命令</code>,查询聚合情况,两台交换机都可查询到.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch1# show etherchannel summary</span><br><span class="line"></span><br><span class="line">Flags:  D - down        P - in port-channel</span><br><span class="line">        I - stand-alone s - suspended</span><br><span class="line">        H - Hot-standby (LACP only)</span><br><span class="line">        R - Layer3      S - Layer2</span><br><span class="line">        U - in use      f - failed to allocate aggregator</span><br><span class="line">        u - unsuitable for bundling</span><br><span class="line">        w - waiting to be aggregated</span><br><span class="line">        d - default port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Number of channel-groups in use: 1</span><br><span class="line">Number of aggregators:           1</span><br><span class="line"></span><br><span class="line">Group  Port-channel  Protocol    Ports // 四个端口都加入了聚合链路中</span><br><span class="line">------+-------------+-----------+----------------------------------------------</span><br><span class="line">1      Po1(SU)           -      Fa0/1(P) Fa0/2(P) Fa0/3(P) Fa0/4(P)    // 这里显示</span><br></pre></td></tr></table></figure></p><p>根据上面的返回信息可以看到,<code>fa0/1,fa0/2,fa0/3,fa0/4</code>都加入到了聚合端口1,使用相同的命令也可以查询到二号交换机的配置情况.<br><br></p><h2 id="配置端口安全"><a href="#配置端口安全" class="headerlink" title="配置端口安全"></a>配置端口安全</h2><p>在实际的生产环境中,对于有较高安全要求的设备,可以使用<code>端口安全技术(Port Security)</code>来提高网络的安全性,端口安全技术可在接入层验证接入设备,防止未经允许的设备接入到网络中,还可以限制端口接入的设备数量,防止过多设备接入网络,影响网络速率.</p><blockquote><p>配置端口安全有两种,动态绑定和静态绑定</p><blockquote><p>● 动态绑定:该方法是配置端口安全最简单的方法,在一个已经启用的端口上配置动态绑定后,可以让交换机自动绑定最先接入的规定数量的设备,该方法也是最常用的一种绑定方式.<br>● 静态绑定:动态绑定时,一旦交换机重启,首先接入交换机的设备可用会发生变化,为保证安全性,可以根据MAC地址或IP地址指定可接入网络的设备.</p></blockquote></blockquote><p>接下来看一个具体的实例,来实现端口安全的配置,包括端口绑定端口违规的处理等,实验拓扑图参数如下:</p><p><img src="/picture/20190314203610.jpg" alt="NetWork"></p><p><strong>启用端口安全:</strong> 配置交换机<code>Switch0</code>启用<code>fa0/1</code>端口,配置端口时应先关闭端口,否则会报错误.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0(config)# interface fa0/1               // 选择1号端口</span><br><span class="line">Switch0(config-if)# shutdown                   // 先关闭端口,防止冲突</span><br><span class="line">Switch0(config-if)# switchport mode access     // 配置端口工作模式为Trunk</span><br><span class="line">Switch0(config-if)# switchport port-security   // 启用端口安全</span><br><span class="line">Switch0(config-if)# no shutdown                // 开启端口</span><br></pre></td></tr></table></figure></p><p><strong>配置静态地址:</strong> 静态指定允许接入的设备的MAC地址,首先要知道MAC地址是多少.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\&gt;arp -a                           // 首先查询到两台机器MAC地址是多少</span><br><span class="line">PC0   0001.4272.5EE7</span><br><span class="line">PC1   00D0.589B.0C35</span><br><span class="line"></span><br><span class="line">#----绑定MAC地址列表-----------------------------</span><br><span class="line">Switch0(config)# interface fa0/1                                           // 选择配置端口 </span><br><span class="line">Switch0(config-if)# switchport port-security maximum 2                     // 配置最大允许2台设备接入</span><br><span class="line">Switch0(config-if)# switchport port-security mac-address 0001.4272.5EE7    // 绑定MAC地址</span><br><span class="line">Switch0(config-if)# switchport port-security mac-address 00D0.589B.0C35</span><br><span class="line">Switch0(config-if)# switchport port-security violation shutdown            // 配置违规后关闭指定端口</span><br><span class="line">Switch0(config-if)# no shutdown                                            // 启动这些端口</span><br><span class="line">Switch0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----查询绑定MAC地址列表-------------------------</span><br><span class="line">Switch0# show port-security address                                        // 查询绑定的MAC地址列表</span><br><span class="line">      Secure Mac Address Table</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Vlan  Mac Address Type      Ports   Remaining Age</span><br><span class="line">                (mins)</span><br><span class="line">----  ----------- ----      -----   -------------</span><br><span class="line">1 00D0.589B.0C35  SecureConfigured  FastEthernet0/1   -         // 绑定的MAC地址</span><br><span class="line">1 0001.4272.5EE7  SecureConfigured  FastEthernet0/1   -</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Total Addresses in System (excluding one mac per port)     : 1</span><br><span class="line">Max Addresses limit in System (excluding one mac per port) : 1024</span><br></pre></td></tr></table></figure></p><p><strong>配置动态地址:</strong> 动态分配接入设备的MAC地址,此配置无需绑定MAC地址,会接入最先访问的主机MAC地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0(config)# interface fa0/1                                    // 选择指定端口</span><br><span class="line">Switch0(config-if)# switchport port-security maximum 2              // 配置最大接入MAC地址为2</span><br><span class="line">Switch0(config-if)# switchport port-security mac-address sticky     // 自动获取接入设备</span><br><span class="line">Switch0(config-if)# switchport port-security violation shutdown     // 对违规设备拒绝服务</span><br><span class="line">Switch0(config-if)# no shutdown                                     // 启动这些端口</span><br><span class="line">Switch0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>最后查询结果:</strong> 查看配置结果以及分配情况,使用<code>show port-security interface fa0/1命令</code>,查看<code>fa0/1</code>端口的配置结果.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0# show port-security interface fa0/1                         // 查看端口fa0/1的接入情况</span><br><span class="line"></span><br><span class="line">Port Security              : Enabled                                // 端口安全是否启用</span><br><span class="line">Port Status                : Secure-up                              // 端口状态</span><br><span class="line">Violation Mode             : Shutdown                               // 违规端口的处理方式</span><br><span class="line">Aging Time                 : 0 mins</span><br><span class="line">Aging Type                 : Absolute</span><br><span class="line">SecureStatic Address Aging : Disabled</span><br><span class="line">Maximum MAC Addresses      : 2                                      // 允许接入的最大设备</span><br><span class="line">Total MAC Addresses        : 2                                      // 当前接入的设备数量</span><br><span class="line">Configured MAC Addresses   : 2                                      // 静态配置的MAC地址数量</span><br><span class="line">Sticky MAC Addresses       : 0                                      // 动态配置的MAC地址数量</span><br><span class="line">Last Source Address:Vlan   : 0000.0000.0000:0                       // 标注出违规设备的MAC地址</span><br><span class="line">Security Violation Count   : 0                                      // 安全违规计数器</span><br></pre></td></tr></table></figure></p><p>完成上方的配置后,手动在<code>Switch0交换机</code>上新添加一个<code>PC2主机</code>,则一切正常,而如果在Hub集线器上添加一个<code>PC3主机</code>,那么链路将触发违规动作,如果此时使用<code>show port-security interface fa0/1 命令</code>查询会发现,<code>Security Violation Count:1</code>安全违规计数变成了1.</p><p>如果更换了主机设备,这里通过更改<code>PC1主机</code>的MAC地址来模拟设备的更换,然后再测试会发现<code>Last Source Address:Vlan</code>这一个选项,会具体的标注出违规设备的MAC地址.<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Cisco" scheme="https://localhost/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>思科交换机配置笔记</title>
    <link href="https://localhost/2019/03/05/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E6%80%9D%E7%A7%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>https://localhost/2019/03/05/网络设备配置/思科交换机配置笔记/</id>
    <published>2019-03-05T02:35:20.000Z</published>
    <updated>2019-04-16T06:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.</p><a id="more"></a><p>交换机是一种交换式集线器,其基于MAC地址识别,能完成封装转发数据包功能的网络设备.交换机可以学习MAC地址,并把其存放在内部地址表中,通过在数据帧的始发者和目标接收者之间建立临时的交换路径,使数据帧直接由源地址到达目的地址.</p><p>交换机内部拥有一条很高带宽的背板总线和内部交换矩阵所有的端口都挂接在这条背板总线上控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的MAC地址的网卡NIC挂接在哪个端口上,通过内部交换矩阵迅速将数据包传送到目的端口目的MAC若不存在才广播到所有的端口,接收端口回应后交换机会学习新的地址,并把它添加入内部MAC地址表中.</p><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于交换机的分类:</p><blockquote><p>1.根据网络覆盖范围划分交换机:广域网交换机和局域网交换机<br>2.根据交换机端口结构划分交换机:固定端口交换机和模块化交换机<br>3.根据工作协议层划分交换机:二层交换机、三层交换机、四层交换机<br>4.根据支持网管功能划分交换机:网管型交换机和非网管理型交换机<br>5.根据传输介质划分交换机:以太网交换机、快速以太网交换机、ATM交换机、FDDI交换机、令牌环交换机<br>6.根据应用网络层次划分交换机:企业级交换机、校园网交换机、部门级交换机、工作组交换机、桌机交换机</p></blockquote></blockquote><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于二层交换机:</p><blockquote><p>二层交换机是对应于OSI/RM的第二协议层来定义的,因为它只能工作在OSI/RM开放体系模型的第二层,即数据链路层.二层交换机依赖于链路层中的信息(如MAC地址)完成不同端口数据间的线速交换,一般应用于小型企业或中型以上企业网络的桌面层次.</p></blockquote></blockquote><blockquote><p><i class="fa fa-plus" aria-hidden="true"></i> 关于三层交换机:</p><blockquote><p>三层交换机是对应于OSI/RM开放体系模型的第三层,即网络层来定义的,也就是说这类交换机可以工作在网络层,它比第二层交换机更加高档,功能更加强.当网络规模较大时,可以根据特殊应用需求划分为小面独立的VLAN网段,以减小广播所造成的影响,通常这类交换机是采用模块化结构,以适应灵活配置的需要.</p></blockquote></blockquote><p><br></p><h2 id="交换机的初始化"><a href="#交换机的初始化" class="headerlink" title="交换机的初始化"></a>交换机的初始化</h2><p>下面的命令方式将对交换机的基本配置,包括配置交换机主机名,特权模式密码,管理接口,IP地址等.</p><p>1.首先登陆思科交换机,并进入特权模式,并配置好主机名称,此处交换机名称配置为<code>lyshark</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable                        // 进入特权模式</span><br><span class="line">Switch# configure terminal            // 使用全局配置模式</span><br><span class="line">Switch(config)# hostname lyshark      // 配置交换机名称</span><br><span class="line">lyshark(config)#</span><br></pre></td></tr></table></figure></p><p>2.开启0号模块下的1-3号接口,配置交换机端口速率并启用指定端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# interface range fa0/1-3     // 选择配置端口</span><br><span class="line">lyshark(config-if-range)# speed 100          // 配置所选端口的速率</span><br><span class="line">lyshark(config-if-range)# no shutdown        // 开启所选端口</span><br><span class="line">lyshark(config-if-range)# exit               // 退出所选端口</span><br></pre></td></tr></table></figure></p><p>3.配置交换机虚拟管理接口的名称,IP地址和子网掩码,并开启管理接口,方便远程维护.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# interface vlan 1                          // 创建虚拟接口vlan1并进入</span><br><span class="line">lyshark(config-if)# ip address 192.168.1.10 255.255.255.0  // 配置IP和子网掩码</span><br><span class="line">lyshark(config-if)# no shutdown                            // 开启端口</span><br><span class="line">lyshark(config-if)# exit</span><br></pre></td></tr></table></figure></p><p>4.配置好虚拟终端以及密码,并允许远程Telnet登陆.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# line vty 0 2              // 配置序号为0-2的3个虚拟终端</span><br><span class="line">lyshark(config-line)# password admin       // 配置虚拟终端登陆密码为admin</span><br><span class="line">lyshark(config-line)# login                // 开启登陆,允许远程登陆</span><br><span class="line">lyshark(config-line)# exit</span><br></pre></td></tr></table></figure></p><p>若要关闭虚拟终端登陆功能,则需要执行以下命令,取消虚拟终端的登陆.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# line vty 0 2              // 选择序号为0-2的3个虚拟终端</span><br><span class="line">lyshark(config-line)# no password          // 取消登陆密码</span><br><span class="line">lyshark(config-line)# no login             // 设置为不允许远程登陆 </span><br><span class="line">lyshark(config-line)# exit</span><br></pre></td></tr></table></figure></p><p>5.在全局模式下配置特权密码,如果明文与密文密码同时配置,则默认使用密文密码为准.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# enable password 123123    // 配置明文密码</span><br><span class="line">lyshark(config)# enable secret 123321      // 配置密文密码</span><br><span class="line">lyshark(config)# exit</span><br></pre></td></tr></table></figure></p><p>6.全部配置完成以后,可以使用<code>running-config(查看内存配置数据)</code>,也可<code>startup-config(查看RAM存储器配置)</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# show running-config              // 查看临时配置数据</span><br><span class="line">lyshark# show startup-config              // 查看RAM永久配置数据</span><br><span class="line"></span><br><span class="line">Building configuration...</span><br><span class="line">Current configuration : 1201 bytes</span><br><span class="line">!</span><br><span class="line">version 12.2                                     // 交换机版本</span><br><span class="line">hostname lyshark                                 // 主机名称</span><br><span class="line">!</span><br><span class="line">enable secret 5 $1$mERr$vPfXBroDs2s.F.9FQ1Le20   // 密文密码</span><br><span class="line">enable password 123123                           // 明文密码</span><br><span class="line">!</span><br><span class="line">interface Vlan1                                  // Vlan1 接口信息</span><br><span class="line"> ip address 192.168.1.10 255.255.255.0           // Vlan1 的管理接口地址</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line">!</span><br><span class="line">line vty 0 2                                    // 远程管理终端</span><br><span class="line"> password admin                                 // 终端密码</span><br><span class="line"> login</span><br><span class="line"> end</span><br></pre></td></tr></table></figure></p><p>7.以上配置内容,当交换机断电后数据也将会清空,我们可以使用以下命令对配置数据永久存储起来.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# write                                 // 写入配置文件</span><br><span class="line">lyshark# erase startup-config                  // 清空配置文件</span><br><span class="line">lyshark# reload                                // 重新加载配置文件</span><br></pre></td></tr></table></figure></p><p>8.通过telnet客户端,连接192.168.1.10输入密码即可登陆交换机.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trying 192.168.1.10 ...Open</span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password: </span><br><span class="line">lyshark&gt;</span><br><span class="line">lyshark&gt;enable</span><br><span class="line">Password: </span><br><span class="line">lyshark#</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="交换机常用参数"><a href="#交换机常用参数" class="headerlink" title="交换机常用参数"></a>交换机常用参数</h2><p><strong>常用查询命令:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# show hosts                  // 查询主机表</span><br><span class="line">lyshark# show ip interface           // 查看端口IP配置信息</span><br><span class="line">lyshark# show history                // 查看历史记录</span><br><span class="line">lyshark# show terminal               // 查看终端记录大小</span><br><span class="line">lyshark# show version                // 查询交换机版本</span><br><span class="line">lyshark# show running-config         // 显示所有的配置</span><br><span class="line">lyshark# show interface              // 查询所有接口</span><br></pre></td></tr></table></figure></p><p><strong>端口选择命令:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# configure terminal                  // 进入终端配置模式</span><br><span class="line">lyshark(config)#</span><br><span class="line">lyshark(config)# interface fa0/1             // 选择0号模块的1号端口</span><br><span class="line">lyshark(config-if)#</span><br><span class="line">lyshark(config-if)# exit</span><br><span class="line">lyshark(config)# interface range fa0/1-5     // 选择0号模块的1-5号端口</span><br><span class="line">lyshark(config-if-range)#</span><br></pre></td></tr></table></figure></p><p><strong>配置端口描述:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark(config)# interface range fa0/1-5</span><br><span class="line">lyshark(config-if-range)# description MyInterface</span><br></pre></td></tr></table></figure></p><p><strong>开启配置端口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# configure terminal                        // 进入命令配置页面</span><br><span class="line">lyshark(config)# interface range fa0/1-5           // 选择配置的端口</span><br><span class="line">lyshark(config-if-range)# switchport mode access   // 设置为通用模式</span><br><span class="line">lyshark(config-if-range)# speed 100                // 设置端口速率</span><br><span class="line">lyshark(config-if-range)# duplex auto              // 设置工作模式</span><br><span class="line">lyshark(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置端口模式:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# configure terminal</span><br><span class="line">lyshark(config)# interface fa0/1</span><br><span class="line">lyshark(config-if)# switchport mode access          // 设置为通用模式</span><br><span class="line">lyshark(config-if)# switchport mode multi           // 该模式很少用</span><br><span class="line">lyshark(config-if)# switchport mode trunk           // 设置为交换机模式</span><br></pre></td></tr></table></figure></p><p><strong>启用/禁用端口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lyshark# configure terminal                    // 进入命令配置模式</span><br><span class="line">lyshark(config)# interface range fa0/1-24      // 选择1-24口</span><br><span class="line">lyshark(config-if-range)# shutdown             // 关闭所有端口</span><br><span class="line">lyshark(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">lyshark(config)# interface range Gig0/1-2      // 选择高速通信端口</span><br><span class="line">lyshark(config-if-range)# shutdown             // 关闭所有端口</span><br><span class="line">lyshark(config-if-range)# no shutdown          // 开启所有端口</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="交换机实现VLAN"><a href="#交换机实现VLAN" class="headerlink" title="交换机实现VLAN"></a>交换机实现VLAN</h2><p>VLAN(Virtual Local Area Network),中文名为虚拟局域网,是一种使用交换机将局域网内的设备在逻辑上划分成一个个网段的技术,即在物理网络上进一步划分逻辑网络,VLAN可以突破地理位置的限制,完全基于实际管理需要来划分网络,例如在单个交换机内划分为不同的区域,不同区域之间无法互相通信,来实现相互隔离.</p><p>VLAN具有与普通局域网相同的属性,第二层的单播,多播和广播帧只能在相同的VLAN内转发,扩散,而不会直接进入其他VLAN中,因此同一个VLAN内的主机即使位于不同的交换机上,也可以互相访问,而不是同一VLAN的主机,即使连接在同一交换机上,也无法通过数据链路层互相访问.如果一个VLAN内的主机想访问另一个VLAN内的主机,必须通过一个三层设备,如路由器或三层交换机实现通信.</p><h3 id="◆单交换机实现VLAN◆"><a href="#◆单交换机实现VLAN◆" class="headerlink" title="◆单交换机实现VLAN◆"></a>◆单交换机实现VLAN◆</h3><p>如前所述,基于端口的VLAN属于静态VLAN,它是划分网络最简单,最有效和最常用的方法,下面将在单台交换机上配置静态VLAN,来实现两个网段的数据隔离,以下实验是一种网络拓扑中最简单的拓扑结构图,适合于小型办公网络,其实验拓扑图如下.</p><p><img src="/picture/20190306155829.jpg" alt="NetWork"></p><p><strong>初始化配置:</strong> 初始化交换机,开启5个交换口,其他交换口关闭保证安全性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">Switch(config)# hostname switch0                 // 配置主机名称</span><br><span class="line">Switch0(config)# interface range fa0/1-5         // 选择1-5号端口</span><br><span class="line">Switch0(config-if-range)# speed 100              // 设置端口速率</span><br><span class="line">Switch0(config-if-range)# no shutdown            // 开启端口</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>创建VLAN区域:</strong> 创建两个VLAN区域,分别命名为<code>vlan10为CaiWu</code>部和<code>vlan20为XiaoShou</code>部两个部门,命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# vlan 10                   // 将VLAN 10配置为CaiWu部门</span><br><span class="line">Switch0(config-vlan)# name CaiWu</span><br><span class="line">Switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">Switch0(config)# vlan 20                   // 将VLAN 20配置为XiaoShou部门</span><br><span class="line">Switch0(config-vlan)# name XiaoShou</span><br><span class="line">Switch0(config-vlan)# exit</span><br></pre></td></tr></table></figure></p><p><strong>添加VLAN端口:</strong> 指定端口加入到新创建的VLAN中,将<code>fa0/1-3号</code>端口放到CaiWu,<code>fa0/4-5号</code>端口放到XiaoShou里.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0(config)# interface range fa0/1-3                // 选择1-3号端口</span><br><span class="line">Switch0(config-if-range)# switchport mode access        // 开启端口</span><br><span class="line">Switch0(config-if-range)# switchport access vlan 10     // 指定将1-3号端口加入到vlan10</span><br><span class="line">Switch0(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface range fa0/4-5</span><br><span class="line">Switch0(config-if-range)# switchport mode access</span><br><span class="line">Switch0(config-if-range)# switchport access vlan 20    // 指定将4-5号端口加入到vlan20</span><br><span class="line">Switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给五台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.10.2     192.168.10.254</span><br><span class="line">PC2           192.168.10.3     192.168.10.254</span><br><span class="line">PC3           192.168.20.1     192.168.20.254</span><br><span class="line">PC4           192.168.20.2     192.168.20.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.2</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.10.3</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆跨交换机实现VLAN◆"><a href="#◆跨交换机实现VLAN◆" class="headerlink" title="◆跨交换机实现VLAN◆"></a>◆跨交换机实现VLAN◆</h3><p>在实际的工作环境中,只在一台交换机上实现VLAN是远远不够的,通常需要跨越多台交换机实现VLAN划分网段,思科交换机通过使用Trunk干道端口的方式实现多台交换机数据共享,并实现跨交换机上的同一个VLAN之间的数据通信,其拓扑结构图如下.</p><p><img src="/picture/20190306174524.jpg" alt="NetWork"></p><p><strong>配置两台交换机:</strong> 分别初始化两台交换机,重命名两个交换机名字,并分别在两台交换机上开启3个端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置switch0---------------------------------------------</span><br><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch0               // 指定交换机1为switch0</span><br><span class="line">switch0(config)# interface range fa0/1-3       // 开启0模块上面的1-3号端口</span><br><span class="line">switch0(config-if-range)# speed auto           // 配置为自动模式</span><br><span class="line">switch0(config-if-range)# no shutdown          // 开启端口</span><br><span class="line">switch0(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----配置switch1---------------------------------------------</span><br><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch1</span><br><span class="line">switch1(config)# interface range fa0/1-3</span><br><span class="line">switch1(config-if-range)# speed auto</span><br><span class="line">switch1(config-if-range)# no shutdown</span><br><span class="line">switch1(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置交换机Trunk:</strong> 配置Trunk干道通信,也就是将两台交换机互相连接,此处配置<code>fa0/1接口</code>为干道网络接口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置switch0---------------------------------------------</span><br><span class="line">switch0&gt; enable</span><br><span class="line">switch0# configure terminal</span><br><span class="line">switch0(config)#</span><br><span class="line">switch0(config)# interface fa0/1               // 选择Fa0/1端口</span><br><span class="line">switch0(config-if)# switchport mode trunk      // 将1号端口设置为trunk模式</span><br><span class="line">switch0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置switch1---------------------------------------------</span><br><span class="line">switch1&gt; enable</span><br><span class="line">switch1# configure terminal</span><br><span class="line">switch1(config)#</span><br><span class="line">switch1(config)# interface fa0/1</span><br><span class="line">switch1(config-if)# switchport mode trunk</span><br><span class="line">switch1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置Switch0:</strong> 配置switch0交换机,创建Vlan10和Vlan20,并分别将两个主机<code>PC0加入Vlan10</code>将<code>PC1加入到Vlan20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch0&gt; enable</span><br><span class="line">switch0# configure terminal</span><br><span class="line"></span><br><span class="line">#----创建接口信息---------------------------------------------</span><br><span class="line">switch0(config)#</span><br><span class="line">switch0(config)# vlan 10                         // 创建vlan11</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line">switch0(config)# vlan 20                         // 创建vlan20</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----配置接口信息---------------------------------------------</span><br><span class="line">switch0(config)# interface fa0/2                // 将fa0/2号接口加入到vlan10</span><br><span class="line">switch0(config-if)# switchport mode access</span><br><span class="line">switch0(config-if)# switchport access vlan 10</span><br><span class="line">switch0(config-if)# exit</span><br><span class="line"></span><br><span class="line">switch0(config)# interface fa0/3                // 将fa0/3号接口加入到vlan20</span><br><span class="line">switch0(config-if)# switchport mode access</span><br><span class="line">switch0(config-if)# switchport access vlan 20</span><br><span class="line">switch0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置Switch1:</strong> 配置switch1交换机,创建Vlan10和Vlan20,并分别将两个主机<code>PC2加入Vlan10</code>将<code>PC3加入到Vlan20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch1&gt; enable</span><br><span class="line">switch1# configure terminal</span><br><span class="line"></span><br><span class="line">#----创建接口信息---------------------------------------------</span><br><span class="line">switch1(config)# vlan 10</span><br><span class="line">switch1(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">switch1(config)# vlan 20</span><br><span class="line">switch1(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----配置接口信息---------------------------------------------</span><br><span class="line">switch1(config)# interface fa0/2</span><br><span class="line">switch1(config-if)# switchport mode access</span><br><span class="line">switch1(config-if)# switchport access vlan 10</span><br><span class="line">switch1(config-if)# exit</span><br><span class="line"></span><br><span class="line">switch1(config)# interface fa0/3</span><br><span class="line">switch1(config-if)# switchport mode access</span><br><span class="line">switch1(config-if)# switchport access vlan 20</span><br><span class="line">switch1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给五台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.20.1     192.168.20.254</span><br><span class="line">PC2           192.168.10.2     192.168.10.254</span><br><span class="line">PC3           192.168.20.2     192.168.20.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆通过VTP管理VLAN◆"><a href="#◆通过VTP管理VLAN◆" class="headerlink" title="◆通过VTP管理VLAN◆"></a>◆通过VTP管理VLAN◆</h3><p>如果网络中有多台交换机,每台交换机上有多个VLAN,此时采用传统方法在每台交换机上一个个配置VLAN不仅效率低而且增加了管理难度,为此思科开发了VTP技术来实现交换机之间自动实现数据的同步.</p><p>VTP它是VLAN中继协议,被称为VLAN链路聚集协议,它可以实现属于同一VTP域的交换机之间自动同步和传播VLAN信息,这样只需要在Server服务端添加VLAN信息,那么客户端将会自动同步,但需要注意的是同步时只能同步VLAN分组,至于端口的添加还得需要手动在每台交换机上添加,因为每一种交换机的接口数量都不太相同,故很难实现统一.</p><p><img src="/picture/20190307175817.jpg" alt="NetWork"></p><p><strong>配置两台交换机:</strong> 分别初始化两台交换机,重命名两个交换机名字,并分别在两台交换机上开启3个端口.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置switch0---------------------------------------------</span><br><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch0               // 配置交换机名称</span><br><span class="line">switch0(config)# interface range fa0/1-3       // 开启1-3号端口</span><br><span class="line">switch0(config-if-range)# speed auto           // 设置端口速率为自动模式</span><br><span class="line">switch0(config-if-range)# no shutdown          // 开启状态</span><br><span class="line">switch0(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----配置switch1---------------------------------------------</span><br><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch1</span><br><span class="line">switch1(config)# interface range fa0/1-3</span><br><span class="line">switch1(config-if-range)# speed auto</span><br><span class="line">switch1(config-if-range)# no shutdown</span><br><span class="line">switch1(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置交换机Trunk:</strong> 将两台交换机的<code>fa0/1</code>端口,配置成<code>Trunk通信模式</code>,同步数据使用.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置switch0---------------------------------------------</span><br><span class="line">switch0&gt; enable</span><br><span class="line">switch0# configure terminal</span><br><span class="line">switch0(config)# interface fa0/1                  // 选择1号端口</span><br><span class="line">switch0(config-if)# switchport mode trunk         // 将端口设置成trunk模式</span><br><span class="line">switch0(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置switch1---------------------------------------------</span><br><span class="line">switch1&gt; enable</span><br><span class="line">switch1# configure terminal</span><br><span class="line">switch1(config)# interface fa0/1</span><br><span class="line">switch1(config-if)# switchport mode trunk</span><br><span class="line">switch1(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置Switch0:</strong> 在<code>switch0</code>上创建VTP管理域,设置名称为<code>manage</code>,密码为<code>123123</code>配置命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch0&gt; enable</span><br><span class="line">switch0# configure terminal</span><br><span class="line">switch0(config)# vtp domain manage             // 创建名为manage的管理域</span><br><span class="line">switch0(config)# vtp mode server               // 将本交换机设置为server模式</span><br><span class="line">switch0(config)# vtp password 123123           // 设置VTP同步密码为123123</span><br><span class="line">switch0(config)# exit</span><br><span class="line"></span><br><span class="line">#----查看VTP状态---------------------------------------------</span><br><span class="line">switch0# show vtp status                       // 查看VTP同步状态</span><br><span class="line">VTP Version                     : 2            // VTP的版本</span><br><span class="line">Configuration Revision          : 0            // 此处为非0说明同步成功</span><br><span class="line">Maximum VLANs supported locally : 255</span><br><span class="line">Number of existing VLANs        : 5</span><br><span class="line">VTP Operating Mode              : Server      // 指定是server模式</span><br><span class="line">VTP Domain Name                 : manage      // 同步名称为manage</span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP V2 Mode                     : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">MD5 digest                      : 0x65 0x6A 0x3C 0x35 0x8B 0xF5 0x0D 0xC0 </span><br><span class="line">Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00</span><br><span class="line">Local updater ID is 0.0.0.0 (no valid interface found)</span><br></pre></td></tr></table></figure></p><p><strong>配置Switch1:</strong> 在<code>switch1</code>上创建VTP同步域,设置模式为<code>client</code>,密码为123123,配置命令如下.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch1&gt; enable</span><br><span class="line">switch1# configure terminal</span><br><span class="line">switch1(config)# vtp domain manage             // 设置同步域名称</span><br><span class="line">switch1(config)# vtp mode client               // 设置成客户端模式</span><br><span class="line">switch1(config)# vtp password 123123           // 指定同步密码</span><br><span class="line">switch1(config)#exit</span><br><span class="line"></span><br><span class="line">#----查看VTP状态---------------------------------------------</span><br><span class="line">switch1# show vtp status                       // 查询状态</span><br><span class="line">VTP Version                     : 2</span><br><span class="line">Configuration Revision          : 0            // 此处为非0说明同步成功</span><br><span class="line">Maximum VLANs supported locally : 255</span><br><span class="line">Number of existing VLANs        : 5</span><br><span class="line">VTP Operating Mode              : Client</span><br><span class="line">VTP Domain Name                 : manage</span><br><span class="line">VTP Pruning Mode                : Disabled</span><br><span class="line">VTP V2 Mode                     : Disabled</span><br><span class="line">VTP Traps Generation            : Disabled</span><br><span class="line">MD5 digest                      : 0x65 0x6A 0x3C 0x35 0x8B 0xF5 0x0D 0xC0 </span><br><span class="line">Configuration last modified by 0.0.0.0 at 0-0-00 00:00:00</span><br></pre></td></tr></table></figure></p><p><strong>创建VLAN配置:</strong> 在·<code>Server端</code>创建一些VLAN列表,并在<code>Client客户端</code>执行同步命令,即可实现同步数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----配置switch0---------------------------------------------</span><br><span class="line">switch0&gt; enable</span><br><span class="line">switch0# configure terminal</span><br><span class="line"></span><br><span class="line">switch0(config)# vlan 10</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">switch0(config)# vlan 20</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----配置switch1---------------------------------------------</span><br><span class="line">switch1&gt; enable</span><br><span class="line">switch1# copy run start           // 开始同步数据</span><br></pre></td></tr></table></figure></p><p><strong>测试环节:</strong> 最后分别给五台设备配置好IP地址,并通过ping命令测试联通性.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.20.1     192.168.20.254</span><br><span class="line">PC2           192.168.10.2     192.168.10.254</span><br><span class="line">PC3           192.168.20.2     192.168.20.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆三层交换实现VLAN◆"><a href="#◆三层交换实现VLAN◆" class="headerlink" title="◆三层交换实现VLAN◆"></a>◆三层交换实现VLAN◆</h3><p>如果要在不同的VLAN之间进行数据通信,则必须利用一个具有三层(网络层)功能的设备来实现,目前常用的设备有三层交换机和路由器,在组建大型网络时出于安全考虑,必须把局域网按照功能划分为一个个小的局域网,来保证安全性,这就使得VLAN技术得以运用,但有时候我们还需要实现跨网段通信,则三层交换机可以实现我们的需求.</p><p>虽然路由器可以完成不同网段之间跨网段通信,但是由于路由器端口数量有限,且路由速度慢,因此三层交换机就诞生了,三层交换机是指具有路由功能的交换机,也就是实现了二层的转发和三层的交换,其价格便宜性价比高,目前是组网的绝佳选择,以下是一个三层交换机组网小案例,不仅实现了VLAN的隔离,还可以实现跨网段通信.</p><p><img src="/picture/20190308135714.jpg" alt="NetWork"></p><p><strong>配置二层交换(两台):</strong> 首先配置2个二层交换机,将<code>fa0/1配成trunk</code>,<code>fa0/2配成vlan10</code>,<code>fa0/3配成vlan20</code>.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----初始化---------------------------------------------</span><br><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch0              // 配置交换机名称(两次配置不能相同)</span><br><span class="line">switch(config)# interface range fa0/1-3       // 开启1-3号端口</span><br><span class="line">switch(config-if-range)# speed auto           // 设置端口速率为自动模式</span><br><span class="line">switch(config-if-range)# no shutdown          // 开启状态</span><br><span class="line">switch(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----配置trunk-------------------------------------------</span><br><span class="line">Switch(config)# interface fa0/1               // 将此通道配置成trunk模式</span><br><span class="line">Switch(config-if)# switchport mode trunk      // 配置成trunk模式</span><br><span class="line">Switch(config-if)# switchport trunk allowed vlan all</span><br><span class="line">Switch(config-if)# no shutdown                // 开启端口</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----配置VLAN--------------------------------------------</span><br><span class="line">switch0(config)# vlan 10                       // 创建vlan10</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line">switch0(config)# vlan 20                       // 创建vlan20</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----加入VLAN组------------------------------------------</span><br><span class="line">switch(config)# interface range fa0/2         // 将fa0/2端口加入vlan10</span><br><span class="line">switch(config-if-range)# switchport mode access</span><br><span class="line">switch(config-if-range)# switchport access vlan 10</span><br><span class="line">switch(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----加入VLAN组------------------------------------------</span><br><span class="line">switch(config)# interface range fa0/3         // 将fa0/3端口加入vlan20</span><br><span class="line">switch(config-if-range)# switchport mode access</span><br><span class="line">switch(config-if-range)# switchport access vlan 20</span><br><span class="line">switch(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置三层交换机:</strong> 配置三层交换机,添加<code>vlan10,vlan20 端口</code>,并将<code>fa0/1-2设置为trunk</code>,供二层交换数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置VLAN--------------------------------------------</span><br><span class="line">Switch(config)# vlan 10</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line">Switch(config)# vlan 20</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----配置端口--------------------------------------------</span><br><span class="line">Switch(config)# interface range f0/1-2                    // 选择1-2号端口</span><br><span class="line">Switch(config-if)# switchport mode trunk                  // 将端口设置为trunk模式</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置三层交换网关:</strong> 在三层交换机上,分别为每个虚拟子接口vlan10,vlan20配置一个网关地址.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置网关--------------------------------------------</span><br><span class="line">Switch# interface vlan 10                         // 选择Vlan10</span><br><span class="line">Switch# ip address 192.168.10.254 255.255.255.0   // 给Vlan10配置网关</span><br><span class="line">Switch# no shutdown                               // 启动端口</span><br><span class="line">Switch# exit</span><br><span class="line"></span><br><span class="line">#----配置网关--------------------------------------------</span><br><span class="line">Switch# interface vlan 20                          // 选择Vlan20</span><br><span class="line">Switch# ip address 192.168.20.254 255.255.255.0    // 给Vlan20配置网关</span><br><span class="line">Switch# no shutdown</span><br><span class="line">Switch# exit</span><br><span class="line"></span><br><span class="line">#----开启路由--------------------------------------------</span><br><span class="line">Switch(config)# ip routing                         // 开启路由</span><br><span class="line">Switch(config)# exit</span><br><span class="line"></span><br><span class="line">#----查看路由--------------------------------------------</span><br><span class="line">Switch# show ip route                              // 显示路由结果</span><br><span class="line">Gateway of last resort is not set</span><br><span class="line">C    192.168.10.0/24 is directly connected, Vlan10</span><br><span class="line">C    192.168.20.0/24 is directly connected, Vlan20</span><br></pre></td></tr></table></figure></p><p><strong>客户机配置网关:</strong> 给每个客户机配置好IP地址和网关参数,并测试连通性,成功后则四个IP都能PING通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.20.1     192.168.20.254</span><br><span class="line">PC2           192.168.10.2     192.168.10.254</span><br><span class="line">PC3           192.168.20.2     192.168.20.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><h3 id="◆单臂路由实现VLAN◆"><a href="#◆单臂路由实现VLAN◆" class="headerlink" title="◆单臂路由实现VLAN◆"></a>◆单臂路由实现VLAN◆</h3><p>单臂路由是指在路由器的一个物理接口上通过配置子接口的方式,实现原来相互隔离的不同VLAN之间的通信,子接口是在物理接口上衍生出来的逻辑接口,一个物理接口可以衍生出许多的逻辑接口.</p><p>一般路由器的物理接口数量有限,如果每个VLAN都使用一个物理接口进行连接,在网络中VLAN数量较多的情况下需要使用多台路由器才能实现VLAN之间的通信,而通过使用子接口可以在一个物理接口上容纳更多的VLAN,从而很好的解决了此问题.</p><p><img src="/picture/20190308201953.jpg" alt="NetWork"></p><p><strong>配置交换机:</strong> 在交换机上创建虚拟局域网<code>vlan10和vlan20</code>,并将<code>fa0/2-3</code>端口加入到<code>vlan10和vlan20</code>中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----开启交换机端口--------------------------------------------</span><br><span class="line">Switch(config)# hostname switch0               // 配置交换机名称</span><br><span class="line">switch0(config)# interface range fa0/1-3       // 开启1-3号端口</span><br><span class="line">switch0(config-if-range)# speed auto           // 设置端口速率为自动模式</span><br><span class="line">switch0(config-if-range)# no shutdown          // 开启状态</span><br><span class="line">switch0(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----创建vlan10和vlan20---------------------------------------</span><br><span class="line">switch0(config)# vlan 10</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line">switch0(config)#</span><br><span class="line">switch0(config)# vlan 20</span><br><span class="line">switch0(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----将fa0/2端口加入到vlan10中---------------------------------</span><br><span class="line">switch0(config)# interface fa0/2</span><br><span class="line">switch0(config-if-range)# switchport mode access</span><br><span class="line">switch0(config-if-range)# switchport access vlan 10</span><br><span class="line">switch0(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----将fa0/3端口加入到vlan20中---------------------------------</span><br><span class="line">switch0(config)# interface fa0/3</span><br><span class="line">switch0(config-if-range)# switchport mode access</span><br><span class="line">switch0(config-if-range)# switchport access vlan 20</span><br><span class="line">switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>设置Trunk模式:</strong> 将交换机与路由器相连的端口设置为Trunk模式,此处设置交换机的<code>fa0/1</code>口为Trunk.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch0&gt; enable</span><br><span class="line">Switch0# configure terminal</span><br><span class="line"></span><br><span class="line">Switch0(config)# interface f0/1                      // 选择1号端口</span><br><span class="line">Switch0(config-if)# switchport mode trunk            // 将端口设置为trunk模式</span><br><span class="line">Switch0(config-if)# no shutdown</span><br><span class="line">Switch0(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置路由器:</strong> 在路由器的<code>Fa0/0</code>以太网接口上创建逻辑接口,并使用<code>IEEE802.1Q协议</code>封装.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line"></span><br><span class="line">#----开启路由器的以太网物理接口fa0/0---------------------------</span><br><span class="line">Router(config)# interface fa0/0</span><br><span class="line">Router(config-if)# no shutdown</span><br><span class="line">Router(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----在以太网接口上创建fa0/0.10子接口--------------------------</span><br><span class="line">Router(config)# interface fa0/0.10                              // 指定子接口名称</span><br><span class="line">Router(config-subif)# encapsulation dot1q 10                    // 使用IEEE协议封装</span><br><span class="line">Router(config-subif)# ip address 192.168.10.254 255.255.255.0   // 设置子接口IP参数</span><br><span class="line">Router(config-subif)# no shutdown</span><br><span class="line">Router(config-subif)# exit</span><br><span class="line"></span><br><span class="line">#----在以太网接口上创建fa0/0.20子接口--------------------------</span><br><span class="line">Router(config)# interface fa0/0.20</span><br><span class="line">Router(config-subif)# encapsulation dot1q 20</span><br><span class="line">Router(config-subif)# ip address 192.168.20.254 255.255.255.0</span><br><span class="line">Router(config-subif)# no shutdown</span><br><span class="line">Router(config-subif)# exit</span><br><span class="line"></span><br><span class="line">#----开启路由功能,并查看路由状态-------------------------------</span><br><span class="line">Router(config)# ip routing</span><br><span class="line">Router(config)# exit</span><br><span class="line"></span><br><span class="line">Router# show ip route</span><br><span class="line">Gateway of last resort is not set</span><br><span class="line">C    192.168.0.0/24 is directly connected, FastEthernet0/0.20</span><br><span class="line">C    192.168.10.0/24 is directly connected, FastEthernet0/0.10</span><br></pre></td></tr></table></figure></p><p><strong>客户机配置网关:</strong> 给每个客户机配置好IP地址和网关参数,并测试连通性,成功后则四个IP都能PING通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.20.1     192.168.20.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line"></span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="实战-构建小型局域网"><a href="#实战-构建小型局域网" class="headerlink" title="实战:构建小型局域网"></a>实战:构建小型局域网</h2><p>接下来将通过模拟器组件一个中小型网络拓扑结构,总共划分为4个区域,分别是<code>办公区域(Vlan10),宿舍区域(Vlan20)</code>这两个区域分别使用一台交换机来连接,剩下的<code>管理区域(Vlan30),客户区域(Vlan40)</code>放在一个交换机里,通过VLAN技术将其隔离开来,最后开启三层交换的路由转发功能,并实现跨区域通信,接下来看一下实验拓扑图.</p><p><img src="/picture/20190309124359.jpg" alt="NetWork"></p><p><strong>配置核心交换机:</strong> 首先配置<code>三层核心交换机 switch</code>,创建VTP管理域以及创建VLAN.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line"></span><br><span class="line">#----配置VTP管理端-------------------------------</span><br><span class="line">Switch(config)# vtp domain lyshark    // 创建VTP域并命名为lyshark</span><br><span class="line">Switch(config)# vtp mode server       // 设置VTP域模式为server</span><br><span class="line">Switch(config)# vtp password 123123   // 设置VTP密码为123123</span><br><span class="line"></span><br><span class="line">#----接着创建VLAN--------------------------------</span><br><span class="line">Switch(config)# vlan 10</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line">Switch(config)# vlan 20</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line">Switch(config)# vlan 30</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line">Switch(config)# vlan 40</span><br><span class="line">Switch(config-vlan)# exit</span><br><span class="line"></span><br><span class="line">#----开启三层交换机trunk端口----------------------</span><br><span class="line">Switch(config)# interface range fa0/1-3</span><br><span class="line">Switch(config-if)#</span><br><span class="line">Switch(config-if)# switchport trunk encapsulation dot1q</span><br><span class="line">Switch(config-if)# switchport mode trunk</span><br></pre></td></tr></table></figure></p><p><strong>配置办公区:</strong> 接着配置<code>二层交换机 switch0</code>,配置成VTP客户端,并将<code>fa0/1端口</code>配置成trunk模式.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch0</span><br><span class="line"></span><br><span class="line">#----配置VTP客户端-------------------------------</span><br><span class="line">switch0(config)# vtp domain lyshark           // 配置VTP客户端,名称</span><br><span class="line">switch0(config)# vtp mode client              // 配置成client客户端模式</span><br><span class="line">switch0(config)# vtp password 123123          // 配置密码</span><br><span class="line"></span><br><span class="line">#----开启二层交换机trunk端口----------------------</span><br><span class="line">switch0(config)# interface fa0/1</span><br><span class="line">switch0(config-if)# switchport mode trunk</span><br><span class="line">switch0(config-if)# exit</span><br><span class="line">switch0(config)# exit</span><br><span class="line"></span><br><span class="line">#----查看数据同步是否生效-------------------------</span><br><span class="line">switch0# show vlan brief</span><br><span class="line"></span><br><span class="line">10   VLAN0010                         active    </span><br><span class="line">20   VLAN0020                         active    </span><br><span class="line">30   VLAN0030                         active    </span><br><span class="line">40   VLAN0040                         active    </span><br><span class="line">1002 fddi-default                     active    </span><br><span class="line">1003 token-ring-default               active    </span><br><span class="line">1004 fddinet-default                  active    </span><br><span class="line">1005 trnet-default                    active    </span><br><span class="line"></span><br><span class="line">#----最后将剩下的端口全部添加到VLAN10-------------</span><br><span class="line">switch0(config)# interface range fa0/2-24</span><br><span class="line">switch0(config-if-range)# switchport mode access</span><br><span class="line">switch0(config-if-range)# switchport access vlan 10</span><br><span class="line">switch0(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置宿舍区:</strong> 接着配置<code>二层交换机 switch1</code>,配置成VTP客户端,并将<code>fa0/1端口</code>配置成trunk模式.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch1</span><br><span class="line"></span><br><span class="line">#----配置VTP客户端-------------------------------</span><br><span class="line">switch1(config)# vtp domain lyshark           // 配置VTP客户端,名称</span><br><span class="line">switch1(config)# vtp mode client              // 配置成client客户端模式</span><br><span class="line">switch1(config)# vtp password 123123          // 配置密码</span><br><span class="line"></span><br><span class="line">#----开启二层交换机trunk端口----------------------</span><br><span class="line">switch1(config)# interface fa0/1</span><br><span class="line">switch1(config-if)# switchport mode trunk</span><br><span class="line">switch1(config-if)# exit</span><br><span class="line">switch1(config)# exit</span><br><span class="line"></span><br><span class="line">#----查看数据同步是否生效-------------------------</span><br><span class="line">switch1# show vlan brief</span><br><span class="line"></span><br><span class="line">10   VLAN0010                         active    </span><br><span class="line">20   VLAN0020                         active    </span><br><span class="line">30   VLAN0030                         active    </span><br><span class="line">40   VLAN0040                         active    </span><br><span class="line">1002 fddi-default                     active    </span><br><span class="line">1003 token-ring-default               active    </span><br><span class="line">1004 fddinet-default                  active    </span><br><span class="line">1005 trnet-default                    active    </span><br><span class="line"></span><br><span class="line">#----最后将剩下的端口全部添加到VLAN20-------------</span><br><span class="line">switch1(config)# interface range fa0/2-24</span><br><span class="line">switch1(config-if-range)# switchport mode access</span><br><span class="line">switch1(config-if-range)# switchport access vlan 20</span><br><span class="line">switch1(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>配置管理/客户区:</strong> 接着配置<code>二层交换机 switch2</code>,配置成VTP客户端,并将<code>fa0/1端口</code>配置成trunk模式.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# hostname switch2</span><br><span class="line"></span><br><span class="line">#----配置VTP客户端-------------------------------</span><br><span class="line">switch2(config)# vtp domain lyshark           // 配置VTP客户端,名称</span><br><span class="line">switch2(config)# vtp mode client              // 配置成client客户端模式</span><br><span class="line">switch2(config)# vtp password 123123          // 配置密码</span><br><span class="line"></span><br><span class="line">#----开启二层交换机trunk端口----------------------</span><br><span class="line">switch2(config)# interface fa0/1</span><br><span class="line">switch2(config-if)# switchport mode trunk</span><br><span class="line">switch2(config-if)# exit</span><br><span class="line">switch2(config)# exit</span><br><span class="line"></span><br><span class="line">#----查看数据同步是否生效-------------------------</span><br><span class="line">switch2# show vlan brief</span><br><span class="line"></span><br><span class="line">10   VLAN0010                         active    </span><br><span class="line">20   VLAN0020                         active    </span><br><span class="line">30   VLAN0030                         active    </span><br><span class="line">40   VLAN0040                         active    </span><br><span class="line">1002 fddi-default                     active    </span><br><span class="line">1003 token-ring-default               active    </span><br><span class="line">1004 fddinet-default                  active    </span><br><span class="line">1005 trnet-default                    active    </span><br><span class="line"></span><br><span class="line">#----将fa0/2-3两台,添加到VLAN30-----------------</span><br><span class="line">switch2(config)# interface range fa0/2-3</span><br><span class="line">switch2(config-if-range)# switchport mode access</span><br><span class="line">switch2(config-if-range)# switchport access vlan 30</span><br><span class="line">switch2(config-if-range)# exit</span><br><span class="line"></span><br><span class="line">#----将fa0/4-5两台,添加到VLAN30-----------------</span><br><span class="line">switch2(config)# interface range fa0/4-5</span><br><span class="line">switch2(config-if-range)# switchport mode access</span><br><span class="line">switch2(config-if-range)# switchport access vlan 40</span><br><span class="line">switch2(config-if-range)# exit</span><br></pre></td></tr></table></figure></p><p><strong>开启三层路由:</strong> 最后配置核心交换机<code>Switch</code>,并开启路由功能,分别为每个网段指定一个网关.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Switch&gt; enable</span><br><span class="line">Switch# configure terminal</span><br><span class="line">Switch(config)# ip routing             // 开启三层路由功能</span><br><span class="line"></span><br><span class="line">#----给Vlan10添加一个网关-----------------</span><br><span class="line">Switch(config)# interface vlan 10</span><br><span class="line">Switch(config-if)# ip address 192.168.10.254 255.255.255.0</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----给Vlan20添加一个网关-----------------</span><br><span class="line">Switch(config)# interface vlan 20</span><br><span class="line">Switch(config-if)# ip address 192.168.20.254 255.255.255.0</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----给Vlan30添加一个网关-----------------</span><br><span class="line">Switch(config)# interface vlan 30</span><br><span class="line">Switch(config-if)# ip address 192.168.30.254 255.255.255.0</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">#----给Vlan40添加一个网关-----------------</span><br><span class="line">Switch(config)# interface vlan 40</span><br><span class="line">Switch(config-if)# ip address 192.168.40.254 255.255.255.0</span><br><span class="line">Switch(config-if)# no shutdown</span><br><span class="line">Switch(config-if)# exit</span><br></pre></td></tr></table></figure></p><p><strong>客户机配置网段:</strong> 给每个客户机配置好IP地址和网关参数,并测试连通性,成功后则IP都能PING通.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#----设置客户主机IP地址+网关-------------------------</span><br><span class="line"></span><br><span class="line">[主机名]         [主机IP]           [网关]</span><br><span class="line">PC0           192.168.10.1     192.168.10.254</span><br><span class="line">PC1           192.168.10.2     192.168.10.254</span><br><span class="line"></span><br><span class="line">PC2           192.168.20.1     192.168.20.254</span><br><span class="line">PC3           192.168.20.2     192.168.20.254</span><br><span class="line"></span><br><span class="line">PC4           192.168.30.1     192.168.30.254</span><br><span class="line">PC5           192.168.30.2     192.168.30.254</span><br><span class="line"></span><br><span class="line">PC6           192.168.40.1     192.168.40.254</span><br><span class="line">PC7           192.168.40.2     192.168.40.254</span><br><span class="line"></span><br><span class="line">#----设置好后测试网络连通性-------------------------</span><br><span class="line">C:\&gt;ping 192.168.10.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br><span class="line">C:\&gt;ping 192.168.20.1</span><br><span class="line">Reply from 192.168.20.1: bytes=32 time=1ms TTL=127</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换机(Switch)是一种用于电信号转发的网络设备,它可以为接入交换机的任意两个网络节点提供独享的电信号通路,最常见的交换机是以太网交换机,其他常见的还有电话语音交换机、光纤交换机等,交换机是集线器的升级替代产品,理论上讲交换机就是按照通信两端传输信息的需求,将需要的信息发送到目标设备上的网络组件.&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Cisco" scheme="https://localhost/tags/Cisco/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系概述</title>
    <link href="https://localhost/2019/03/04/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0/"/>
    <id>https://localhost/2019/03/04/网络设备配置/计算机网络体系概述/</id>
    <published>2019-03-04T02:12:52.000Z</published>
    <updated>2019-04-16T06:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备,通过通信线路连接起来,在网络操作系统,网络管理软件及网络通信协议的管理和协调下,实现资源共享和信息传递的计算机系统,</p><a id="more"></a><p><br></p><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>11111<br><br></p><h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p>OSI(Open System Interconnect)即开放系统互联,一般都叫OSI参考模型,是国际标准化组织在1985年研究的网络互联模型,该体系结构标准定义了网络互联的七层框架(物理层、数据链路层、网络层、传输层、会话层、表示层和应用层),即OSI开放系统互连参考模型.在这一框架下进一步详细规定了每一层的功能,以实现开放系统环境中的互连性、互操作性和应用的可移植性,接下来将整理一些常用功能的知识点.</p><table><thead><tr><th style="text-align:center">物理层次</th><th style="text-align:left">协议作用</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:left">为用户提供服务,给用户一个接口</td></tr><tr><td style="text-align:center">表示层</td><td style="text-align:left">为数据提供表示,加密与压缩</td></tr><tr><td style="text-align:center">会话层</td><td style="text-align:left">确定数据是否需要传输,建立管理与终止会话</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:left">可靠与不可靠的数据传输,以及后期的错误检测</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:left">进行逻辑地址编址,实现不同网络之间的路由选择</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:left">进行硬件(MAC)地址编址有,差错的校验</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:left">电气特性,设备之间进行比特流的传输</td></tr></tbody></table><p>以上的列表是一个通用的网络系统模型,并不是一个协议定义.实际上OSI模型从来没有被真正实现过,但是,出于其模型的广泛指导性,现在的网络协议都已经纳入了OSI参考模型的范围之内,OSI参考模型一共有7层,每层的作用在上面有说明,这也是网络方面的基础知识.</p><h3 id="◆每层间作用◆"><a href="#◆每层间作用◆" class="headerlink" title="◆每层间作用◆"></a>◆每层间作用◆</h3><p><strong>物理层:</strong> 电器特性,设备之间比特流的传输,实现比特流的透明传输.</p><p><b>主要设备:</b> 中继器、集线器</p><p><b>主要功能:</b> 实现相邻计算机节点之间比特流的透明传输,尽可能屏蔽掉具体传输介质与物理设备的差异,使其上面的数据链路层不必考虑网络的具体传输介质是什么,通常会以二进制比特的形式传输数据.</p><p><b>意义:</b> 不管中途传输的是什么数据,所采用的设备只是起一个通道作用,主要作用是把要传输的内容完好的传到对方主机.</p><p><b>拓展知识:</b> 物理层中双绞线的传输距离是100m,而超过100m则信号会衰减,影响数据的传输.为了使传输的数据能够准确的传输,中继器是可以放大传输信号,保持原数据的准确,中继器只有两个以太网接口.</p><p><strong>数据链路层:</strong> 进行硬件(MAC)地址编址与差错校验,负责建立和管理节点间的链路.</p><p><b>主要设备:</b> 网卡、网桥、交换机(二层交换)</p><p><b>主要功能:</b> 通过各种控制协议,将有差错的物理信道变为无差错的、能可靠传输数据帧完成网络之间相邻结点的可靠传输,通过Mac地址负责主机之间的数据的可靠传输.</p><p><b>工作方式:</b> 接受来自物理层的位流形式的数据,并封装成帧,传送到上一层.同样,也将来自上一层的数据帧,拆装为位流形式的数据转发到物理层.并且还负责处理接受端发回的确认帧的信息,以便提供可靠的数据传输.</p><p><b>拓展知识:</b> 物理层传输的是比特流,而数据链路层传输的是帧,通常情况下,该层通常又被分为<code>介质访问控制(MAC)</code>和<code>逻辑链路控制(LLC)</code>两个子层:</p><blockquote><p>MAC子层：主要任务是解决共享型网络中多用户对信道竞争的问题,完成网络介质的访问控制.<br>LLC子层：主要任务是建立和维护网络连接,执行差错校验、流量控制和链路控制.</p></blockquote><p><strong>网络层:</strong> 进行逻辑地址编址(IP地址),实现不同网络之间的路由选择,是OSI中最复杂的1层,也是通信子网最高的1层.</p><p><b>主要设备:</b> 路由器,交换机(三层交换)</p><p><b>工作方式:</b> 通过路由算法,其路由器内部会有路由表,为报文之间的数据传输选择最适当的路径,该层控制数据链路层与物理层之间的信息转发,建立、维持与终止网络的连接,一般情况下,数据链路层是解决统一网络内节点之间的通信,而网络层主要解决不同子网之间的通信.</p><p><b>拓展知识:</b> 该层常用语数据寻址,数据交换以及通过路由算法来选择一个最佳通信路径,当源节点和路由节点之间存在多条路径时,本层可以根据路由算法,通过网络为数据分组选择最佳路径,并将信息从最合适的路径,由发送端传送的接受端.</p><p><strong>传输层:</strong> 实现两个用户进程端到端之间的可靠与不可靠的数据通信,还具有错误检测功能.</p><p><b>主要设备:</b> 防火墙,入侵检测系统</p><p><b>主要功能:</b> 向用户提供可靠的、端到端的差错和流量控制,保证报文的正确传输.OSI的下三层的主要任务是数据传输,上三层的主要任务是数据处理,而传输层是第四层,因此该层是通信子网和资源子网的接口和桥梁,起到承上启下的作用.</p><p><b>主要作用:</b> 传输层提供会话层和网络层之间的传输服务,这种服务从会话层获得数据,并在必要时,对数据进行分割.然后,传输层将数据传送到网络层,并确保数据能准确无误的传送到网络层,因此,传输层负责提供两节点之间数据的可靠传送,当两节点的联系确定之后,传输层负责监督工作.</p><p><b>主要协议:</b> TCP传输控制协议/UDP用户数据报协议,涉及服务使用的端口号,主机根据端口号识别服务,区分会话.</p><blockquote><p>TCP协议：传输控制协议,提供可靠的,准确的,面向连接的协议.<br>UDP协议：用户数据报协议,提供不可靠的,面向无连接的传输协议.</p></blockquote><p>UDP传输与IP传输相似,但IP协议是ip地址之间的通信,但通信需要多个通信通道,将每个通道分配给每一个进程使用,UDP则是实现端口的通信.</p><p><b>小总结:</b> 传输层作用,1.对报文进行分组,2.提供对传输协议的选择,3.端口封装,4.差错校验.</p><p><strong>会话层:</strong> 是用户应用程序和网络之间的接口,主要用于建立,管理,和终止会话.</p><p><b>主要作用:</b> 向两个实体的表示层提供建立和使用连接的方法,将不同实体之间的表示层的连接称为会话,因此会话层的任务就是组织和协调两个会话进程之间的通信,并对数据交换进行管理.</p><p><strong>表示层:</strong> 主要负责数据格式的转换,即翻译,压缩与解压缩,加密与解密.</p><p><b>主要作用:</b> 表示层是OSI模型的第六层,它对来自应用层的命令和数据进行解释,对各种语法赋予相应的含义,并按照一定的格式传送给会话层,其主要功能是处理用户信息的表示问题,如编码、数据格式转换和加密解密等.</p><p><strong>应用层:</strong> 应用层是网络体系中最高的1层,也是唯一面向用户的1层,也可视为为用户提供常用的应用程序的接口.</p><p><b>主要协议:</b> HTTP,HTTPS,FTP,SMTP,等</p><p><b>主要作用:</b> 直接向用户提供服务,完成用户希望在网络上完成的各种工作,它在其他6层工作的基础上,负责完成网络中应用程序与网络操作系统之间的联系,建立与结束使用者之间的联系,并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议.此外,该层还负责协调各个应用程序间的工作.</p><h3 id="◆OSI-模型总结◆"><a href="#◆OSI-模型总结◆" class="headerlink" title="◆OSI 模型总结◆"></a>◆OSI 模型总结◆</h3><p>1.上三层为用户提供服务,下四层负责实际数据传输.<br>2.越是上层越智能,可以识别所有当前层以下的数据,越贴近用户,越是下层越简单,越贴近硬件.<br>3.下四层传输单位:</p><p>传输层: 数据段 —&gt; 报文<br>网络层: 数据包 —&gt; 分组<br>数据链路层: 数据帧<br>物理层: 比特位</p><p>4.发送与接收数据</p><p>发送时数据从上往下层传输<br>接收时数据从下往上层传输</p><p>5.数据不能跨层传输,每层之间通过逻辑的接口传输.<br>6.物理层负责实际的数据传输,其他层只是逻辑对应.<br>7.OSI模型只是理论模型,不能对应实际的协议或硬件.</p><p>111<br><br></p><h2 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h2><p>111<br><br></p><h2 id="常用通用协议栈"><a href="#常用通用协议栈" class="headerlink" title="常用通用协议栈"></a>常用通用协议栈</h2><h3 id="◆TCP-协议◆"><a href="#◆TCP-协议◆" class="headerlink" title="◆TCP 协议◆"></a>◆TCP 协议◆</h3><h3 id="◆UDP-协议◆"><a href="#◆UDP-协议◆" class="headerlink" title="◆UDP 协议◆"></a>◆UDP 协议◆</h3><h3 id="◆IP-协议◆"><a href="#◆IP-协议◆" class="headerlink" title="◆IP 协议◆"></a>◆IP 协议◆</h3><p>ARP</p><p>ICMP</p><p>0000<br><br></p><h2 id="对等与非对等通信"><a href="#对等与非对等通信" class="headerlink" title="对等与非对等通信"></a>对等与非对等通信</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备,通过通信线路连接起来,在网络操作系统,网络管理软件及网络通信协议的管理和协调下,实现资源共享和信息传递的计算机系统,&lt;/p&gt;
    
    </summary>
    
      <category term="网络设备配置" scheme="https://localhost/categories/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="网络设备配置" scheme="https://localhost/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Web开发框架之Flask入门(6)</title>
    <link href="https://localhost/2019/02/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B9%8BFlask%E5%85%A5%E9%97%A8-6/"/>
    <id>https://localhost/2019/02/28/前端开发/Web开发框架之Flask入门-6/</id>
    <published>2019-02-28T10:19:45.000Z</published>
    <updated>2019-09-07T00:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask 是一个基于Python开发并且依赖jinja2模板和Werkzeug WSGI服务的一个微型框架,对于Werkzeug本质是Socket服务端,其用于接收http请求并对请求进行预处理,然后触发Flask框架,开发人员基于Flask框架提供的功能对请求进行相应的处理,并返回给用户,如果要返回给用户复杂的内容时,需要借助jinja2模板来将模板和数据进行渲染,将渲染后的字符串返回给用户浏览器,本文将收集一些常用的开发小例子方便开发速查.</p><a id="more"></a><p><br></p><h2 id="Web-框架的本质"><a href="#Web-框架的本质" class="headerlink" title="Web 框架的本质"></a>Web 框架的本质</h2><p><strong>实现简单HTTP:</strong> 众所周知,对于所有的Web应用,本质上其实就是一个socket服务端,用户的浏览器其实就是一个socket客户端,其下面就是简单实现的HTTP服务器.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(client)</span>:</span></span><br><span class="line">    buf = client.recv(<span class="number">1024</span>)</span><br><span class="line">    client.send(bytes(<span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>,<span class="string">"UTF-8"</span>))</span><br><span class="line">    client.send(bytes(<span class="string">"&lt;b&gt;Hello lyshark&lt;/b&gt;"</span>,<span class="string">"UTF-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((<span class="string">"localhost"</span>,<span class="number">80</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection, address = sock.accept()</span><br><span class="line">        handle_request(connection)</span><br><span class="line">        connection.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p><strong>python wsgi接口</strong> WSGI是一种规范,它定义了使用python编写的web app与web server之间接口格式,实现web app与web server间的解耦,python标准库提供的独立WSGI服务器称为wsgiref<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RunServer</span><span class="params">(environ,start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">"200 OK"</span>,[(<span class="string">"Content-Type"</span>,<span class="string">"text/html"</span>)])</span><br><span class="line">    print(environ[<span class="string">'PATH_INFO'</span>])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b"&lt;h1&gt;Hello lyshark&lt;/h1&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    httpd = make_server(<span class="string">"localhost"</span>,<span class="number">80</span>,RunServer)</span><br><span class="line">    print(<span class="string">"Serving HTTP on port 80..."</span>)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Flask-表单操作"><a href="#Flask-表单操作" class="headerlink" title="Flask 表单操作"></a>Flask 表单操作</h2><h3 id="◆CheckBox-复选框◆"><a href="#◆CheckBox-复选框◆" class="headerlink" title="◆CheckBox 复选框◆"></a>◆CheckBox 复选框◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"MyDiv"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"s_option"</span> <span class="attr">value</span>=<span class="string">"basketball"</span> &gt;</span> 篮球</span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"s_option"</span> <span class="attr">value</span>=<span class="string">"football"</span> &gt;</span> 足球</span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"s_option"</span> <span class="attr">value</span>=<span class="string">"badminton"</span> &gt;</span> 羽毛球</span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"发送"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/",methods=['POST','GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        data = request.values.getlist(<span class="string">"s_option"</span>)</span><br><span class="line">        print(<span class="string">"您的选择内容是: %s"</span> %data)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="◆Select-选择框◆"><a href="#◆Select-选择框◆" class="headerlink" title="◆Select 选择框◆"></a>◆Select 选择框◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"MySelect"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>--请选择厂家--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">option</span> &gt;</span>惠普<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">option</span> &gt;</span>华为<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">option</span> &gt;</span>戴尔<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"发送"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/",methods=['POST','GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        data = request.values.get(<span class="string">"MySelect"</span>)</span><br><span class="line">        print(<span class="string">"您的选择内容是: %s"</span> %data)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="Ajax-发送数据◆"><a href="#Ajax-发送数据◆" class="headerlink" title="Ajax 发送数据◆"></a>Ajax 发送数据◆</h3><p>HTML页面发送数据,后端接收并返回数据</p><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"MyButton"</span> <span class="attr">value</span>=<span class="string">"发送数据"</span> <span class="attr">onclick</span>=<span class="string">"SendAjax()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function SendAjax()&#123;</span></span><br><span class="line"><span class="undefined">            $.ajax(&#123;</span></span><br><span class="line"><span class="undefined">                url:"/dataFromAjax",</span></span><br><span class="line"><span class="undefined">                contentType: "POST",</span></span><br><span class="line"><span class="undefined">                data:&#123;"MyData": "hello lyshark"&#125;,</span></span><br><span class="line"><span class="undefined">                success:function(data)&#123;</span></span><br><span class="line"><span class="undefined">                    alert("返回数据:" + data);</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                error:function()&#123;</span></span><br><span class="line"><span class="undefined">                    alert("执行失败了...")</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/dataFromAjax")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">()</span>:</span></span><br><span class="line">    data = request.args.get(<span class="string">"MyData"</span>)</span><br><span class="line">    print(<span class="string">"收到客户端数据: %s"</span>%data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"通信成功..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="Ajax-获取数据◆"><a href="#Ajax-获取数据◆" class="headerlink" title="Ajax 获取数据◆"></a>Ajax 获取数据◆</h3><p>后端发送JSON数据,HTML页面接收数据并显示出来.</p><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"MyButton"</span> <span class="attr">value</span>=<span class="string">"接收数据"</span> <span class="attr">onclick</span>=<span class="string">"GetAjax()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/jquery.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function GetAjax()&#123;</span></span><br><span class="line"><span class="undefined">            $.ajax(&#123;</span></span><br><span class="line"><span class="undefined">                url:"/dataFromAjax",</span></span><br><span class="line"><span class="undefined">                contentType: "GET",</span></span><br><span class="line"><span class="undefined">                success:function(data)&#123;</span></span><br><span class="line"><span class="undefined">                    alert("姓名: " + data.name + "年龄: " + data.age);</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                error:function()&#123;</span></span><br><span class="line"><span class="undefined">                    alert("执行失败了...")</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/dataFromAjax",methods=["GET","POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">()</span>:</span></span><br><span class="line">    data = &#123;<span class="string">"name"</span>:<span class="string">"lyshark"</span>,<span class="string">"age"</span>:<span class="string">"23"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># info = dict()    //另一种组装发送数据的方法</span></span><br><span class="line"><span class="comment"># info['name'] = "lyshark"</span></span><br><span class="line"><span class="comment"># info['age'] = 22</span></span><br><span class="line"><span class="comment"># return jsonify(info)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Flask-过滤器"><a href="#Flask-过滤器" class="headerlink" title="Flask 过滤器"></a>Flask 过滤器</h2><p><strong>字符串操作:</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 当变量未定义时，显示默认字符串，可以缩写为d #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; name | default('No name', true) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 单词首字母大写 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 'hello' | capitalize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 单词全小写 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 'XML' | lower &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 去除字符串前后的空白字符 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; '  hello  ' | trim &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 字符串反转，返回"olleh" #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 'hello' | reverse &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 格式化输出，返回"Number is 2" #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; '%s is %d' | format("Number", 2) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 关闭HTML自动转义 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; '<span class="tag">&lt;<span class="name">em</span>&gt;</span>name<span class="tag">&lt;/<span class="name">em</span>&gt;</span>' | safe &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;% autoescape false %&#125;</span><br><span class="line">&#123;# HTML转义，即使autoescape关了也转义，可以缩写为e #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; '<span class="tag">&lt;<span class="name">em</span>&gt;</span>name<span class="tag">&lt;/<span class="name">em</span>&gt;</span>' | escape &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line">#用管道的形式，如果avatar（后端传过来的变量）的值不存在，则用default的值</span><br><span class="line">&#123;&#123; avatar|default('xxx') &#125;&#125;　　　　</span><br><span class="line">#这里的意思为获取avatar的长度，avatar为后端传过来的变量，可以是列表，也可以是字典</span><br><span class="line">&#123;&#123; avatar|length &#125;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>数值操作:</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 四舍五入取整，返回13.0 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 12.8888 | round &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;# 向下截取到小数点后2位，返回12.88 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 12.8888 | round(2, 'floor') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;# 绝对值，返回12 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; -12 | abs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>列表操作:</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 取第一个元素 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [1,2,3,4,5] | first &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 取最后一个元素 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [1,2,3,4,5] | last &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 返回列表长度，可以写为count #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [1,2,3,4,5] | length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 列表求和 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [1,2,3,4,5] | sum &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 列表排序，默认为升序 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [3,2,1,5,4] | sort &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 合并为字符串，返回"1 | 2 | 3 | 4 | 5" #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; [1,2,3,4,5] | join(' | ') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 列表中所有元素都全大写。这里可以用upper,lower，但capitalize无效 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; ['tom','bob','ada'] | upper &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>字典列表操作:</strong><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% set users=[&#123;'name':'Tom','gender':'M','age':20&#125;,</span><br><span class="line">              &#123;'name':'John','gender':'M','age':18&#125;,</span><br><span class="line">              &#123;'name':'Mary','gender':'F','age':24&#125;,</span><br><span class="line">              &#123;'name':'Bob','gender':'M','age':31&#125;,</span><br><span class="line">              &#123;'name':'Lisa','gender':'F','age':19&#125;]</span><br><span class="line">%&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#123;# 按指定字段排序，这里设reverse为true使其按降序排 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for user in users | sort(attribute='age', reverse=true) %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; user.name &#125;&#125;, &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 列表分组，每组是一个子列表，组名就是分组项的值 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for group in users|groupby('gender') %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; group.grouper &#125;&#125;<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for user in group.list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">&#123;# 取字典中的某一项组成列表，再将其连接起来 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; users | map(attribute='name') | join(', ') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>内置过滤器:</strong> tojson配合js使用,注意这里要避免HTML自动转义,所以加上safe过滤器<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var users = &#123;&#123; users | tojson | safe &#125;&#125;;</span></span><br><span class="line"><span class="undefined">console.log(users[0].name);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>自定义过滤器:</strong> 自定义过滤器其实就是一个函数,自己写即可<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">def mylen(arg):#实现一个可以求长度的函数</span><br><span class="line">    return len(arg)</span><br><span class="line"></span><br><span class="line"># 该函数实现给定一个区间返回区间的内容</span><br><span class="line">def interval(test_str, start, end):#过滤器中传递多个参数，第一个参数为被过滤的内容，第二第三个参数需要自己传入</span><br><span class="line">    return test_str[int(start):int(end)]</span><br><span class="line"></span><br><span class="line">env = app.jinja_env</span><br><span class="line">env.filters['mylen'] = mylen　　　　　　#注册自定义过滤器</span><br><span class="line">env.filters['interval'] = interval　　 #注册自定义过滤器</span><br><span class="line"></span><br><span class="line">@app.route("/") </span><br><span class="line">def index(): </span><br><span class="line">　　test_str = "hello" </span><br><span class="line">　　return render_template("index.html", test_str=test_str)</span><br><span class="line">#--------------------------------------------------------------------</span><br><span class="line">jinja2模板</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>len: &#123;&#123;test_str|mylen&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>interval: &#123;&#123;test_str|interval(0,2)&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>　　　　#test_str作为参数传到interval函数里</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Flask-应用实例"><a href="#Flask-应用实例" class="headerlink" title="Flask 应用实例"></a>Flask 应用实例</h2><h3 id="◆URL传递参数◆"><a href="#◆URL传递参数◆" class="headerlink" title="◆URL传递参数◆"></a>◆URL传递参数◆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/post/&lt;id&gt;")                       #参数需要放在"&lt;&gt;"中,并且要与函数中传入的参数同名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(id)</span>:</span>                                  <span class="comment">#加入参数,函数名称要与上面的路由名称相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"请求的参数是 %s"</span> %id</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/user=&lt;name&gt; password=&lt;pasd&gt;")     #可同时传递多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post1</span><span class="params">(name,pasd)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户名: %s 密码: %s"</span> %(name,pasd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>,port=<span class="string">"80"</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="◆URL反向解析◆"><a href="#◆URL反向解析◆" class="headerlink" title="◆URL反向解析◆"></a>◆URL反向解析◆</h3><p>反转url主要用于模版和页面的重定向（从视图函数到url的转换）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(url_for(<span class="string">"post"</span>,id=<span class="string">"lyshark"</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/post/&lt;id&gt;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;h1&gt; hello %s &lt;/h1&gt;"</span> %id</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>,port=<span class="string">"80"</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆URL地址跳转◆"><a href="#◆URL地址跳转◆" class="headerlink" title="◆URL地址跳转◆"></a>◆URL地址跳转◆</h3><p>url跳转（重定向）及url反转功能应用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for,redirect</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;b&gt; 这是首页 &lt;/b&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/quest/&lt;is_login&gt;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quest</span><span class="params">(is_login)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_login == <span class="string">"1"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;b&gt; 登陆成功...&lt;/b&gt;"</span>          <span class="comment">#1为登陆成功,其他为失败,失败则跳转到登陆函数(下面的login)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">"login"</span>))    <span class="comment">#失败,跳转到登陆函数（界面）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/login/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;b&gt; 请登陆... &lt;/b&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>,port=<span class="string">"80"</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆静态文件引入◆"><a href="#◆静态文件引入◆" class="headerlink" title="◆静态文件引入◆"></a>◆静态文件引入◆</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('static',filename='css/index.css') &#125;&#125;"</span>&gt;</span>     // 加载、static目录下的css目录下的index.css文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; url_for('static',filename='js/index.js') &#125;&#125;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>              // 加载js文件</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>  <span class="attr">src</span>=<span class="string">"&#123;&#123; url_for('static',filename='images/aa.jpg') &#125;&#125;"</span>&gt;</span>                       // 加载后台图片</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('login') &#125;&#125;"</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span>　　　　                                    // 点击登陆从index跳转到login页面</span><br></pre></td></tr></table></figure><h3 id="◆简单的参数传递◆"><a href="#◆简单的参数传递◆" class="headerlink" title="◆简单的参数传递◆"></a>◆简单的参数传递◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个flask页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>height：&#123;&#123; height &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    info = &#123;</span><br><span class="line">        <span class="string">"username"</span>:<span class="string">"lyshark"</span>,</span><br><span class="line">        <span class="string">"gender"</span>:<span class="string">"man"</span>,</span><br><span class="line">        <span class="string">"height"</span>:<span class="string">"165"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果有多个参数,可以将所有的参数放到字典中,然后以**kwargs的方式传递进去,info为上面定义的字典</span></span><br><span class="line">    <span class="comment">#这里直接写模版文件名称,如果在模版文件在temlate/html目录下,则这里需要写'html/index.html'</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>,**info)  </span><br><span class="line"></span><br><span class="line">    <span class="comment">#渲染模版,传参数,如果参数较少,可以直接写关键字参数及值,如下:</span></span><br><span class="line">　　<span class="comment">#return render_template('index.html',username='name',gender="man",height="178")</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>,port=<span class="string">"80"</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆复杂的参数传递◆"><a href="#◆复杂的参数传递◆" class="headerlink" title="◆复杂的参数传递◆"></a>◆复杂的参数传递◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个flask页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>height：&#123;&#123; height &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; person.name &#125;&#125;---&#123;&#123; person.age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>　　//此处对应上面py中定义的Person类</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; city.bj &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>　　　　　　　　　　　　　　 //第一种取值方式</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; city['tj'] &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>                       //第二种取值方式</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">        name=<span class="string">'tttt'</span></span><br><span class="line">        age=<span class="number">18</span></span><br><span class="line"> </span><br><span class="line">    p = Person()</span><br><span class="line">    info = &#123;</span><br><span class="line">        <span class="string">'username'</span> :<span class="string">'name'</span>,</span><br><span class="line">        <span class="string">'gender'</span>:<span class="string">"man"</span>,</span><br><span class="line">        <span class="string">'height'</span> : <span class="string">"178"</span>,</span><br><span class="line">        <span class="string">'person'</span>:p,</span><br><span class="line">        <span class="string">'city'</span>:&#123;</span><br><span class="line">            <span class="string">'bj'</span>:<span class="string">"bj"</span>,</span><br><span class="line">            <span class="string">'tj'</span>:<span class="string">'tj'</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,**info)</span><br><span class="line">    <span class="comment">#return render_template('index.html',username='name',gender="man",height="178")</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆自定义错误页◆"><a href="#◆自定义错误页◆" class="headerlink" title="◆自定义错误页◆"></a>◆自定义错误页◆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_noe_found</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'home/404.html'</span>),<span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_noe_found</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'home/500.html'</span>),<span class="number">500</span></span><br></pre></td></tr></table></figure><h3 id="◆IF语句的使用◆"><a href="#◆IF语句的使用◆" class="headerlink" title="◆IF语句的使用◆"></a>◆IF语句的使用◆</h3><p><strong>HTML:</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% if users and users.age &gt;10 %&#125;　　　　　　　　#这里的users为py文件里传递的user字典，users.age为py文件user字典里的age</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>&#123;&#123; users.aa &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>&#123;&#123;  users.bbb&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/&lt;is_login&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(is_login)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_login == <span class="string">"1"</span>:　　　　　　　　<span class="comment">#模拟1为登陆成功</span></span><br><span class="line">        user = &#123;</span><br><span class="line">            <span class="string">"aa"</span>:<span class="string">"test"</span>,</span><br><span class="line">            <span class="string">'bbb'</span>:<span class="string">'注销'</span>,</span><br><span class="line">            <span class="string">'age'</span>:<span class="string">"11"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,users=user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆FOR语句的使用◆"><a href="#◆FOR语句的使用◆" class="headerlink" title="◆FOR语句的使用◆"></a>◆FOR语句的使用◆</h3><p><strong>HTML:</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for k,v in user.items() %&#125;　　　　　　　　#for语句</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; k &#125;&#125;----&#123;&#123; v &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    users = &#123;</span><br><span class="line">        <span class="string">'username'</span>:<span class="string">'tsdf'</span>,</span><br><span class="line">        <span class="string">'age'</span>:<span class="number">11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,user=users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="◆钩子函数的使用◆"><a href="#◆钩子函数的使用◆" class="headerlink" title="◆钩子函数的使用◆"></a>◆钩子函数的使用◆</h3><p>before_request函数,就是一个装饰器,他可以把需要设置为钩子函数的代码放到视图函数执行之前执行.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect,render_template,request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'index'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mybefore_request</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'before_request'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="Flask-实战例子"><a href="#Flask-实战例子" class="headerlink" title="Flask 实战例子"></a>Flask 实战例子</h2><h3 id="◆实现登陆验证◆"><a href="#◆实现登陆验证◆" class="headerlink" title="◆实现登陆验证◆"></a>◆实现登陆验证◆</h3><p><strong>HTML:</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"发送"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名: &#123;&#123; user &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码: &#123;&#123; pasd &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/",methods=['POST','GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        username = request.form.get(<span class="string">"username"</span>)</span><br><span class="line">        password =request.form.get(<span class="string">"password"</span>)</span><br><span class="line">        print(<span class="string">"收到用户名: %s ---&gt;收到密码: %s"</span> %(username,password))</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>,user=username,pasd=password)      <span class="comment">#可以指定返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="◆实现文件上传◆"><a href="#◆实现文件上传◆" class="headerlink" title="◆实现文件上传◆"></a>◆实现文件上传◆</h3><p><strong>HTML:</strong> upload.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传文件"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: green"</span>&gt;</span> 上传状态: &#123;&#123; file_flage &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/upload",methods=['POST','GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"upload.html"</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        files = request.files[<span class="string">"file"</span>]                <span class="comment">#获取到返回文件的名称</span></span><br><span class="line">        print(<span class="string">"上传文件详细名称: %s"</span> %files)</span><br><span class="line">        print(<span class="string">"上传文件简略名称: %s"</span> %files.filename)</span><br><span class="line">        files.save(files.filename)                   <span class="comment">#上传文件到当前目录,这里可以做更多判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"upload.html"</span>,file_flage=<span class="string">"上传文件完成..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="◆实现Cookie◆"><a href="#◆实现Cookie◆" class="headerlink" title="◆实现Cookie◆"></a>◆实现Cookie◆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> make_response</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/set")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    cook = make_response(<span class="string">"设置cookie完成..."</span>)</span><br><span class="line">    cook.set_cookie(<span class="string">"Name"</span>,<span class="string">"lyshark"</span>,max_age=<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">return</span> cook</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/get")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    cook = request.cookies.get(<span class="string">"Name"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"cookie 设置用户=%s"</span> %cook</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/del')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_cookie</span><span class="params">()</span>:</span></span><br><span class="line">    cook=make_response(<span class="string">"删除cookie完成..."</span>)</span><br><span class="line">    cook.delete_cookie(<span class="string">'Name'</span>)</span><br><span class="line">    <span class="keyword">return</span> cook</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="◆实现Session◆"><a href="#◆实现Session◆" class="headerlink" title="◆实现Session◆"></a>◆实现Session◆</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> session,url_for,escape,redirect</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span>                               <span class="comment">#自动验证session</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">in</span> session:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'用户 %s 已经登陆成功...'</span> % escape(session[<span class="string">'username'</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您还没有登陆呢...'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span>                                 <span class="comment">#登陆session</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        session[<span class="string">'username'</span>] = request.form[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''</span></span><br><span class="line"><span class="string">        &lt;form action="" method="post"&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=text name=username&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input type=submit value=登陆&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="meta">@app.route('/get')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span>                                   <span class="comment">#获取session</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户: %s"</span> %session.get(<span class="string">'username'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span>                                <span class="comment">#注销session</span></span><br><span class="line">    session.pop(<span class="string">'username'</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># session.clear() 　　　　　　　　　      #清空session里的所有数据</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line">app.secret_key = os.urandom(<span class="number">24</span>)             <span class="comment">#加盐,服务端每次重启都会变化</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h3 id="◆表格结构遍历◆"><a href="#◆表格结构遍历◆" class="headerlink" title="◆表格结构遍历◆"></a>◆表格结构遍历◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>书名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>作者<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                &#123;% for book in temp %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.author &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.price &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    book = [</span><br><span class="line">        &#123;<span class="string">'name'</span>:<span class="string">'西游记'</span>,<span class="string">'author'</span>:<span class="string">'吴承恩'</span>,<span class="string">'price'</span>:<span class="number">111</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'name'</span>: <span class="string">'红楼梦'</span>, <span class="string">'author'</span>: <span class="string">'曹雪芹'</span>, <span class="string">'price'</span>: <span class="number">121</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'name'</span>: <span class="string">'水浒传'</span>, <span class="string">'author'</span>: <span class="string">'施耐庵'</span>, <span class="string">'price'</span>: <span class="number">131</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'name'</span>: <span class="string">'三国演义'</span>, <span class="string">'author'</span>: <span class="string">'罗贯中'</span>, <span class="string">'price'</span>: <span class="number">141</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,temp=book)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><h3 id="◆表格属性增强◆"><a href="#◆表格属性增强◆" class="headerlink" title="◆表格属性增强◆"></a>◆表格属性增强◆</h3><p><strong>HTML</strong> index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"发送"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                &#123;% for temp in user %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; temp.user &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; temp.pass &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>后台:</strong> app.py<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">temp = [</span><br><span class="line">    &#123;<span class="string">"user"</span>:<span class="string">"admin"</span>,<span class="string">"pass"</span>:<span class="string">"1233"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"user"</span>:<span class="string">"lyshark"</span>,<span class="string">"pass"</span>:<span class="string">"qwer"</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/",methods=['POST','GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        username = request.form.get(<span class="string">"username"</span>)</span><br><span class="line">        password = request.form.get(<span class="string">"password"</span>)</span><br><span class="line">        data = &#123;<span class="string">"user"</span>:username,<span class="string">"pass"</span>:password&#125;     <span class="comment">#组合数据</span></span><br><span class="line">        temp.append(data)                            <span class="comment">#追加数据到列表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>,user=temp)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>,user=temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask 是一个基于Python开发并且依赖jinja2模板和Werkzeug WSGI服务的一个微型框架,对于Werkzeug本质是Socket服务端,其用于接收http请求并对请求进行预处理,然后触发Flask框架,开发人员基于Flask框架提供的功能对请求进行相应的处理,并返回给用户,如果要返回给用户复杂的内容时,需要借助jinja2模板来将模板和数据进行渲染,将渲染后的字符串返回给用户浏览器,本文将收集一些常用的开发小例子方便开发速查.&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="https://localhost/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端开发" scheme="https://localhost/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发JQuery框架(5)</title>
    <link href="https://localhost/2019/02/25/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91JQuery%E6%A1%86%E6%9E%B6-5/"/>
    <id>https://localhost/2019/02/25/前端开发/Web前端开发JQuery框架-5/</id>
    <published>2019-02-25T02:31:32.000Z</published>
    <updated>2019-09-07T00:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>JQuery 是一个兼容多浏览器支持的JavaScript库,其核心理念是write less,do more(写得更少,做得更多),它是轻量级的js库,兼容CSS3还兼容各种浏览器,需要注意的是后续版本将不再支持IE6/7/8浏览器,jQuery使用户能更方便地处理HTML、events、实现动画效果,并且方便地为网站提供AJAX交互,jQuery还有一个比较大的优势是,它的文档说明很全,而且各种应用也说得很详细,同时还有许多成熟的插件可供选择,jQuery能够使用户的html页面保持代码和html内容分离,也就是说,不用再在html里面插入一堆js来调用命令了,只需要定义id即可,在后续的开发工作中我们经常会用到JQuery框架,你也能够在各种的网页结构中发现它的身影.</p><a id="more"></a><p><br></p><h2 id="JQuery-常用选择器"><a href="#JQuery-常用选择器" class="headerlink" title="JQuery 常用选择器"></a>JQuery 常用选择器</h2><p>JQuery 选择器是JQuery框架的基础,JQuery对事件处理,DOM操作,CSS动画等都是在选择器基础上进行的,JQuery选择器采用CSS和Xpath选择符的能力,能够满足用户在DOM中快速获取元素或元素组,在JQuery中通过各种选择器和方法获取的结果集合实际上都是一个JQuery对象,通过JQuery对象会非常简单,即可实现对元素的各种操作,这里我们介绍几个最常用的选择器例子.</p><p><strong>ID选择器:</strong> 通过使用简单的<code>$(#id)</code>标识前缀,实现快速匹配指定ID的元素对象,具体用法如下.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"1000"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div id="2000"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"3000"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">" type="</span>text/javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line">        $("#2000").css("background","red");          //通过ID号选择指定元素</span><br><span class="line">        <span class="keyword">var</span> temp = $(<span class="string">"#1000"</span>).text();                <span class="comment">//获取到文本的内容</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"文本内容: "</span> + temp);          <span class="comment">//打印出这个文本的内容</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>标签选择器:</strong> 通过使用<code>$(&quot;element&quot;)</code>标识前缀,匹配页面中所有P标签,并设置成红色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"1000"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p id="2000"&gt; hello p&lt;/</span>p&gt;</span><br><span class="line">    &lt;div id=<span class="string">"3000"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p id="4000"&gt; hello p&lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"p"</span>).css(<span class="string">"background"</span>,<span class="string">"red"</span>);          <span class="comment">//通过p标签定位修改所有P标签</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>类选择器:</strong> 通过使用<code>$(&quot;ClassName&quot;)</code>标识前缀,匹配页面中所有<code>class=&quot;MyClass&quot;</code>的类属性.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyClass"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"lyshark"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">" type="</span>text/javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>.MyClass<span class="string">").css("</span>background<span class="string">","</span>green<span class="string">");        //通过.MyClass找到一类属性并修改</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>通配符选择器:</strong> 通过使用<code>$(&quot;body*&quot;)</code>标识前缀,匹配页面中所有开头是<code>div</code>的标签,并设置成绿色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyClass"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line">    &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"lyshark"</span>&gt; hello lyshark &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="lyshark"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"div*"</span>).css(<span class="string">"background"</span>,<span class="string">"green"</span>);        <span class="comment">//修改所有div标签的属性</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>组合选择器:</strong> 使用组合选择器可以扩大选择器的选择范围,可以通过逗号分隔符分割多个不同的选择器.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt; hello lyshark &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyClass"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div id="MyID1"&gt;hello MyID1 &lt;/</span>div&gt;</span><br><span class="line">        &lt;div id=<span class="string">"MyID2"</span>&gt;hello MyID2 &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"lyshark"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">" type="</span>text/javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line">        $(".MyClass #MyID1 , h1 , #lyshark").css("background","green");</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>属性选择器:</strong> 根据元素的属性及其值作为过滤条件,来匹配DOM元素,它以中括号作为分界符.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"Text"</span> value=<span class="string">"标签1"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"password"</span> name=<span class="string">"Text"</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">"id1"</span>&gt; hello P &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p id="id2" alex="sb"&gt; hello P &lt;/</span>p&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"input[type='text']"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);            <span class="comment">//修改input,且类型是text的标签</span></span><br><span class="line">        $(<span class="string">"p[id='id1']"</span>).text(<span class="string">"修改id1的标题"</span>);                 <span class="comment">//修改标题,是p标签且id=id1的</span></span><br><span class="line">        $(<span class="string">"input[name='Text']"</span>).val(<span class="string">"修改成我"</span>);                <span class="comment">//将标签中的value属性修改掉</span></span><br><span class="line">        $(<span class="string">"p[alex='sb']"</span>).css(<span class="string">"background"</span>,<span class="string">"red"</span>);             <span class="comment">//也可以自定义查找标签</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>后代选择器:</strong> 该选择器常用于批量修改,匹配所有的后代,所有选中的DIV标签后代都会应用变化.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt; hello div div1&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="div2"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="divA"&gt;hello div A&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"divA"</span>&gt;hello div B&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">" type="</span>text/javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>.MyClass div<span class="string">").css("</span>background<span class="string">","</span>green<span class="string">");        //修改指定.MyClass下的所有DIV标签</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>子代选择器:</strong> 子代选择器常用于缩小查询范围,在匹配的父元素下,选择所有匹配的子元素.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt; hello div div1&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="divA"&gt;hello div A&lt;/</span>div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div2"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"divA"</span>&gt;hello div A&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="divA"&gt;hello div B&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyClass &gt; .div2"</span>).css(<span class="string">"background"</span>,<span class="string">"green"</span>);        <span class="comment">//修改.MyClass类里面的,div2的所有子元素</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>相邻选择器:</strong> 在所有匹配的元素后选择同级别相邻元素,如下匹配所有跟在<code>.outer</code>后面的所有P标签,并设置成红色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt; hello p1&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p class="outer"&gt; hello p2&lt;/</span>p&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt; hello p3&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".outer + p"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>);    <span class="comment">//匹配所有.outer类中,第一个p标签相邻的元素.</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>兄弟选择器:</strong> 兄弟选择器就是在所有匹配的元素后选择同级的所有元素,如下匹配<code>.outer</code>类后面的所有同级DIV标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt; hello div1&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="outer"&gt; hello div2&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt; hello div3&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">" type="</span>text/javascript<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>.outer~div<span class="string">").css("</span>color<span class="string">","</span>red<span class="string">");   //将属于outer类中的所有同级DIV设置成红色.</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="JQuery-元素的操作"><a href="#JQuery-元素的操作" class="headerlink" title="JQuery 元素的操作"></a>JQuery 元素的操作</h2><p>文档对象模型 (Document Object Model,DOM) 是一种W3C标准所有的现代浏览器都支持DOM,DOM用于HTML和XML文档的编程接口,它给文档提供了一种结构化的表示方法,可以改变文档的内容和呈现方式.最为关心的是,DOM把网页和脚本以及其他的编程语言联系了起来,DOM属于浏览器,而不是JavaScript语言规范里的规定的核心内容,下面我们将使用JQuery函数库,对网页属性进行各种操作,以下是一些常用的操作方式,其他操作方式请自行百度.</p><h3 id="◆文档处理◆"><a href="#◆文档处理◆" class="headerlink" title="◆文档处理◆"></a>◆文档处理◆</h3><p><strong>Text():</strong> 该函数常用于设置或者是读取标签里面的内容.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyName"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="MyAge"&gt; age:22 &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var temp = $("</span>.MyDiv .MyName<span class="string">").text();           //查找指定的标签元素内容</span></span><br><span class="line"><span class="string">        document.write("</span>获取到标签的内容: <span class="string">" + temp);</span></span><br><span class="line"><span class="string">        $("</span>.MyAge<span class="string">").text("</span>hello world<span class="string">");                 //修改指定的标签元素内容</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>html():</strong> 该函数常用于设置或者是读取标签内容,但是可以在设置标签内容的同时添加格式属性.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyName"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="MyAge"&gt; age:22 &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var temp = $("</span>.MyDiv .MyName<span class="string">").html();           //查找指定的标签元素内容</span></span><br><span class="line"><span class="string">        document.write("</span>获取到标签的内容: <span class="string">" + temp);</span></span><br><span class="line"><span class="string">        $("</span>.MyAge<span class="string">").html("</span>&lt;b&gt; hell html &lt;<span class="regexp">/b&gt;");          /</span><span class="regexp">/修改指定的标签元素内容</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>val():</strong> 用于获取或者是设置指定标签的<code>value</code>值.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"MyText1"</span> value=<span class="string">"标签1"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"MyText2"</span> value=<span class="string">"标签2"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>input[name=<span class="string">'MyText1'</span>]<span class="string">").val();          //定位并获取文本的value选项</span></span><br><span class="line"><span class="string">        document.write("</span>获取到文本name属性的值: <span class="string">" + data);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        $("</span>input[name=<span class="string">'MyText2'</span>]<span class="string">").val("</span>lyshark<span class="string">");            //修改文本的value属性为lyshark</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>append():</strong> 给指定的标签添加内容,分别可以在开头插入<code>$().prepend</code>,结尾插入<code>$().append</code>等.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt; hello lyshark ---&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyDiv"</span>).append(<span class="string">"结尾加入"</span>);                <span class="comment">//在标签结尾插入新数据</span></span><br><span class="line">        $(<span class="string">".MyDiv"</span>).prepend(<span class="string">"开头加入"</span>);               <span class="comment">//在标签开头插入新输入</span></span><br><span class="line">        $(<span class="string">".MyDiv"</span>).prepend(<span class="string">"&lt;b&gt; hello &lt;/b&gt;"</span>);        <span class="comment">//开头插入带格式的文本</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>appendTo():</strong> 该函数可以实现将外部的标签插入到一个块级标签里面,动态添加元素.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;h1 id=<span class="string">"Myh1"</span>&gt; hello h1&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;p&gt; hello p1&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt; hello p2&lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"p"</span>).appendTo(<span class="string">"div"</span>);                 <span class="comment">//将p标签加入到div标签里面</span></span><br><span class="line">        $(<span class="string">"p"</span>).appendTo(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line">         $(<span class="string">"div"</span>).prependTo(<span class="string">"h1"</span>)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>empty()/remove()：</strong> 使用<code>empty()</code>可以清空标签中的内容,<code>remove()</code>用于彻底移除标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"p1"</span>&gt; hello p1&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p class="p2"&gt; hello p2&lt;/</span>p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".p1"</span>).empty();</span><br><span class="line">        $(<span class="string">".p2"</span>).empty();              <span class="comment">//清空标签内的内容.</span></span><br><span class="line">        $(<span class="string">".p2"</span>).remove();             <span class="comment">//彻底移除标签.</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>before()/after():</strong> 可以实现在指定标签的上方<code>(.before)</code>插入内容,或者下<code>(.after)</code>方插入内容.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt; hello div &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyDiv div"</span>).before(<span class="string">"&lt;h1&gt; before &lt;/h1&gt;"</span>)         <span class="comment">//在div上方插入内容</span></span><br><span class="line">        $(<span class="string">".MyDiv div"</span>).after(<span class="string">"&lt;h1&gt; after &lt;/h1&gt;"</span>)           <span class="comment">//在div下方插入内容</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>insertBefore()/insertAfter():</strong> 在每个DIV标签前面<code>(insertBefore)</code>插入新标签,或者在后面<code>(insertAfter)</code>插入.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt; hello div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>&lt;span&gt; hello span &lt;<span class="regexp">/span&gt;").insertBefore("div");         /</span><span class="regexp">/在div前面插入span标签</span></span><br><span class="line"><span class="regexp">        $("&lt;h1&gt; hello h1&lt;/</span>h1&gt;<span class="string">").insertAfter("</span>div<span class="string">");                 //在每个div标签后面插入h1</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>replaceWith():</strong> 查找与替换,将所有的类属性是<code>class=&quot;.MyDiv&quot;</code>的标签替换成粗体的<code>hello div</code>.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt; hello div1 &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyDiv"&gt; hello div2 &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyDiv"</span>).replaceWith(<span class="string">"&lt;b&gt; hello div &lt;/b&gt;"</span>);            <span class="comment">//将所有div标签替换成粗体的hello div</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>clone:</strong> 克隆并追加一个DIV标签,追加到body页面中.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt; hello div1 &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>body<span class="string">").append($("</span>div<span class="string">").clone());         //克隆并追加到body中.</span></span><br><span class="line"><span class="string">        $("</span>body<span class="string">").append($("</span>div<span class="string">").clone());</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="◆属性操作◆"><a href="#◆属性操作◆" class="headerlink" title="◆属性操作◆"></a>◆属性操作◆</h3><p><strong>attr():</strong> 可实现获取和设置,指定标签的属性信息.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"MyText1"</span> value=<span class="string">"标签1"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"MyText2"</span> value=<span class="string">"标签2"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var names = $("</span>input[name=<span class="string">'MyText2'</span>]<span class="string">").attr("</span>name<span class="string">");      //获取MyText2标签的name字段内容</span></span><br><span class="line"><span class="string">        var types = $("</span>input[type=<span class="string">'text'</span>]<span class="string">").attr("</span>type<span class="string">");         //获取Type标签的type字段内容</span></span><br><span class="line"><span class="string">        document.write("</span>标签name字段内容: <span class="string">" + names + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>标签type字段内容: <span class="string">" + types + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        $("</span>input[name=<span class="string">'MyText2'</span>]<span class="string">").attr("</span>name<span class="string">","</span>lyshark<span class="string">");       //将MyText2标签的name字段修改成lyshark</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>removeAttr():</strong> 找到指定的字段并可以自定义移除相关字段.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"MyText"</span> value=<span class="string">"标签1"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> data = $(<span class="string">"input[name='MyText']"</span>).attr(<span class="string">"value"</span>);    <span class="comment">//找到value字段的内容</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前value值: "</span> + data);</span><br><span class="line"></span><br><span class="line">        $(<span class="string">"input[name='MyText']"</span>).removeAttr(<span class="string">"value"</span>);         <span class="comment">//移除value字段的内容</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>prop():</strong> 设置标签的属性,常用于设置单选框和复选框.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"check"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> data = $(<span class="string">"input[name='check']"</span>).prop(<span class="string">"checked"</span>);        <span class="comment">//获取checkbox默认状态</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"选择框默认状态:"</span> + data)</span><br><span class="line"></span><br><span class="line">        $(<span class="string">"input[name='check']"</span>).prop(<span class="string">"checked"</span>,<span class="literal">true</span>);             <span class="comment">//设置checkbox为选中状态</span></span><br><span class="line">        $(<span class="string">"input[name='check']"</span>).prop(<span class="string">"disabled"</span>,<span class="literal">true</span>);            <span class="comment">//设置checkbox为禁用状态</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>removeprop：</strong> 删除由prop设置的属性集,(不明白)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"check"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"input[name='check']"</span>).prop(<span class="string">"disabled"</span>,<span class="literal">true</span>);</span><br><span class="line">        $(<span class="string">"input[name='check']"</span>).removeProp(<span class="string">""</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>addClass():</strong> 动态的将一个CSS属性添加到一些标签中.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        .mode&#123;</span><br><span class="line">            background-color: #17a2b8;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyClass"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyClass"</span>).addClass(<span class="string">"mode"</span>);     <span class="comment">//对所有的MyClass标签,添加mode的属性.</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>removeClass:</strong> 动态的将一个CSS属性在标签中删除.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        .mode&#123;</span><br><span class="line">            background-color: #17a2b8;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mode"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="mode"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"div"</span>).removeClass(<span class="string">"mode"</span>);    <span class="comment">//删除所有div标签中的mode类属性.</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>toggleClass:</strong> 实现了动态的切换类的样式.使标签不可见.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        .show&#123;</span><br><span class="line">            background-color: #17a2b8;</span><br><span class="line">        &#125;</span><br><span class="line">        .hidden&#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mode"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>div<span class="string">").toggleClass("</span>hidden<span class="string">");             //切换成隐藏属性</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>hasClass():</strong> 该函数用来判断当前的样式,存在返回真,不存在返回假.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        .mode&#123;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"mode"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>div<span class="string">").hasClass("</span>mode<span class="string">");</span></span><br><span class="line"><span class="string">        document.write(data)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="◆样式操作◆"><a href="#◆样式操作◆" class="headerlink" title="◆样式操作◆"></a>◆样式操作◆</h3><p><strong>修改CSS属性:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass1"</span> style=<span class="string">"background-color: rebeccapurple"</span>&gt; hello lyshark&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="MyClass2" style="font-size: 30px"&gt; hello lyshark&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyClass1"</span>).css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);          <span class="comment">//修改MyClass1的背景属性</span></span><br><span class="line">        $(<span class="string">".MyClass2"</span>).css(<span class="string">"font-size"</span>,<span class="string">"10px"</span>);                <span class="comment">//修改MyClass2的字体大小</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>追加CSS属性:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass1"</span>&gt; hello lyshark&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>.MyClass1<span class="string">").css(&#123;"</span>background-color<span class="string">":"</span>red<span class="string">","</span>font-size<span class="string">":"</span><span class="number">20</span>px<span class="string">"&#125;);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="JQuery-常用筛选器"><a href="#JQuery-常用筛选器" class="headerlink" title="JQuery 常用筛选器"></a>JQuery 常用筛选器</h2><p>jQuery 提供了两种选择文档元素的方式：选择器和筛选器,选择器主要模仿CSS和xPath语法,提供高效、准确匹配元素的一般方法和用法,而筛选器是建立在选择器基础上进行的二次筛选,选择器是符合一定规律的字符串组合,而筛选器就是一系列简单、实用的JQuery方法,在 JQuery 框架中,筛选器通过<code>Sizzle.filter</code>子类来实现,它包含过滤、杳找和串联,这里我们只举几个常用例子.</p><h3 id="◆过滤筛选器◆"><a href="#◆过滤筛选器◆" class="headerlink" title="◆过滤筛选器◆"></a>◆过滤筛选器◆</h3><p><strong>first()/last():</strong> <code>first()</code>筛选出所有li标签中第一个标签,<code>last()</code>筛选出所有标签中的最后一个标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>li:first<span class="string">").text();                  //找出第一个标签的标签内容</span></span><br><span class="line"><span class="string">        document.write("</span>第一个标签内容是:<span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var data = $("</span>li:last<span class="string">").text();                  //找出最后一个标签的标签内容</span></span><br><span class="line"><span class="string">        document.write("</span>最后一个标签内容是:<span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        $("</span>li:last<span class="string">").remove();                            //实现移除最后一个标签</span></span><br><span class="line"><span class="string">        $("</span>li:last<span class="string">").append("</span>&lt;li&gt;添加&lt;<span class="regexp">/li&gt;");             /</span><span class="regexp">/实现添加一个新标签</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>even()/odd():</strong> <code>even()</code>筛选出所有li标签中偶数标签,<code>odd()</code>筛选出所有li标签中基数标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;菜单&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;搞事&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>.MyClass ul li:even<span class="string">").text();</span></span><br><span class="line"><span class="string">        document.write("</span>基数标签为: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">        var count = $("</span>.MyClass ul li:even<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>基数标签个数: <span class="string">" + count.length + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var data = $("</span>.MyClass ul li:odd<span class="string">").text();</span></span><br><span class="line"><span class="string">        document.write("</span>偶数标签为: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">        var count = $("</span>.MyClass ul li:odd<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>偶数标签个数: <span class="string">" + count.length);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>eq():</strong> 过滤出所有li标签中,索引是2的那个标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;菜单&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;搞事&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>li:eq(<span class="number">2</span>)<span class="string">").text();                //所有li标签中,索引是2的标签</span></span><br><span class="line"><span class="string">        document.write("</span>索引是<span class="number">2</span>的标签内容是: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var data = $("</span>li:eq(<span class="number">0</span>)<span class="string">").text();                //所有li标签中,索引是0的标签</span></span><br><span class="line"><span class="string">        document.write("</span>索引是<span class="number">0</span>的标签内容是: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var data = $("</span>.MyClass ul li<span class="string">").eq(4);          //另一种写法,结果相同.</span></span><br><span class="line"><span class="string">        document.write("</span>索引是<span class="number">4</span>的标签内容是: <span class="string">" + data.text() + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>gt():</strong> 所有li标签中，索引大于2的标签<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;菜单&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;搞事&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>li:gt(<span class="number">2</span>)<span class="string">").text();                //所有li标签中,索引大于2的标签</span></span><br><span class="line"><span class="string">        document.write("</span>索引大于<span class="number">2</span>的标签内容是: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>lt():</strong> 所有li标签中，索引小于3的标签<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;菜单&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;搞事&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>li:lt(<span class="number">3</span>)<span class="string">").text();                //所有li标签中,索引小于3的标签</span></span><br><span class="line"><span class="string">        document.write("</span>索引小于<span class="number">3</span>的标签内容是: <span class="string">" + data + "</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>hasclass():</strong> 检测li中的是否含有某个特定的类，有的话返回true<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyClass"</span>&gt;</span><br><span class="line">        &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"lyshark"</span>&gt;</span><br><span class="line">            &lt;li&gt;首页&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;主机&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;系统&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;菜单&lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;搞事&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var data = $("</span>.MyClass ul<span class="string">").hasClass("</span>lyshark<span class="string">");</span></span><br><span class="line"><span class="string">        document.write(data);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="◆查找筛选器◆"><a href="#◆查找筛选器◆" class="headerlink" title="◆查找筛选器◆"></a>◆查找筛选器◆</h3><p><strong>children():</strong> 获取指定标签的所有子标签,以下在类名为<code>&quot;MyForm&quot;</code>盒子里,找所有div子标签,并将其设置为绿色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyForm"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv"</span>&gt; hello lyshark &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="Mydiv"&gt; hello lyshark &lt;/</span>div&gt;</span><br><span class="line">        &lt;p&gt; hello lyshark &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">".MyForm"</span>).children(<span class="string">".Mydiv"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>parent():</strong> 获取指定标签的所有父标签,以下代码找所有P标签的父标签,并设置成红色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv"</span>&gt; hello lyshark</span><br><span class="line">        &lt;p&gt; hello p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; hello p &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">       var data = $("</span>p<span class="string">").parent().css("</span>color<span class="string">","</span>red<span class="string">");</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>next():</strong> 寻找指定标签的下一个标签,以下代码根据第1个Mydiv1为条件寻找下一个div.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv1"</span>&gt;</span><br><span class="line">        &lt;p&gt; hello p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv2"</span>&gt;</span><br><span class="line">        &lt;p&gt; hello p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(<span class="string">"div"</span>).next().css(<span class="string">"background"</span>,<span class="string">"red"</span>);</span><br><span class="line">       $(<span class="string">".Mydiv1"</span>).next().css(<span class="string">"background"</span>,<span class="string">"red"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>prev():</strong> 寻找指定标签的上一个标签,以下代码根据第2个Mydiv2为条件寻找上一个div.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv1"</span>&gt;</span><br><span class="line">        &lt;p&gt; hello p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv2"</span>&gt;</span><br><span class="line">        &lt;p&gt; hello p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(<span class="string">".Mydiv2"</span>).prev().css(<span class="string">"background"</span>,<span class="string">"red"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>siblings():</strong> 查找标签的所有兄弟标签,查找所有的同辈标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv1"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Min"</span>&gt;hello div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Mydiv2"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"Min"</span>&gt;hello div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       $(<span class="string">".Mydiv1"</span>).siblings().css(<span class="string">"background"</span>,<span class="string">"red"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>find():</strong> 在form标签中找到text,password标签,并将其设置为绿色.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form <span class="class"><span class="keyword">class</span></span>=<span class="string">"forms"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> value=<span class="string">"用户名"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"password"</span> value=<span class="string">"密码"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        $("</span>form<span class="string">").find("</span>:text,:password<span class="string">").css(&#123;"</span>color<span class="string">":"</span>red<span class="string">","</span>background<span class="string">":"</span>green<span class="string">"&#125;)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="JQuery-事件的处理"><a href="#JQuery-事件的处理" class="headerlink" title="JQuery 事件的处理"></a>JQuery 事件的处理</h2><p>事件是用户在操作浏览器的过程中,由用户触发或由浏览器自身触发的动作,浏览器捕获这些动作,并根据用户编程时设置的对应这些动作的事件处理程序,触发相应的处理过程,从而实现交互过程,浏览器在程序运行的大部分时间都等待交互事件的发生,并在发生时,自动的调用事件处理函数完成整个处理过程,为了更好的兼容不同类型的浏览器,JQuery在JavaScript的基础上,进一步封装了不同类型的时间模型,从而形成一种功能强大,用法更加优雅的JQuery事件模型,下面个将具体介绍几种常用的用法.</p><p><strong>注册单次事件:</strong> one()方法是bind()方法的特例,由它绑定的事件在执行一次相应后就会失效.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p id=<span class="string">"MyP"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"MyID"</span> value=<span class="string">"添加内容"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"#MyID"</span>).one(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           $(<span class="string">"p"</span>).append(<span class="string">"hello lyshark"</span>);            <span class="comment">//给P标签添加内容</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>注册循环事件:</strong> bind()作为统一的接口,用来为每个匹配元素绑定事件处理程序.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"MyID1"</span> value=<span class="string">"无参数绑定"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"MyID2"</span> value=<span class="string">"带参数绑定"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"#MyID1"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(<span class="string">"绑定无参数的事件..."</span>)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $(<span class="string">"#MyID2"</span>).bind(<span class="string">"click"</span>,&#123;<span class="attr">x</span>:<span class="string">"参数1"</span>,<span class="attr">y</span>:<span class="string">"参数2"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            $(<span class="keyword">this</span>).text(event.data.x + event.data.y);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>绑定多个事件:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"MyID1"</span> value=<span class="string">"按钮1"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"MyID2"</span> value=<span class="string">"按钮2"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="string">"#MyID1,#MyID2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> currentId = $(<span class="keyword">this</span>).attr(<span class="string">"id"</span>);       <span class="comment">//获取它的ID名称</span></span><br><span class="line">           <span class="keyword">if</span>(currentId == <span class="string">"MyID1"</span>)&#123;                 <span class="comment">//说明点击了按钮1</span></span><br><span class="line">               alert(<span class="string">"您点击了按钮1"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currentId == <span class="string">"MyID2"</span>)&#123;           <span class="comment">//说明点击了按钮2</span></span><br><span class="line">               alert(<span class="string">"您点击了按钮2"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>表单数据提交:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDIV"</span>&gt;</span><br><span class="line">    姓名: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input1"</span> /&gt;</span></span></span><br><span class="line">    性别: &lt;input type="text" id="input2" /&gt;</span><br><span class="line">    年龄: &lt;input type="text" id="input3" /&gt;</span><br><span class="line">    &lt;input type="button" id="button1"&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src="js/jquery-3.3.1.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type="text/javascript"&gt;</span><br><span class="line">        $("#button1").click(function()&#123;</span><br><span class="line">            var name = $(".MyDIV #input1").val();     //获取到元素值</span><br><span class="line">            var sex = $(".MyDIV #input2").val();</span><br><span class="line">            var age = $(".MyDIV #input3").val();</span><br><span class="line"></span><br><span class="line">            alert("姓名: " + name + "性别: " + sex + "年龄: " + age);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>回调函数:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $(<span class="string">"p"</span>).hide(<span class="number">1000</span>,call_back());</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">call_back</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"回掉函数使用..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;隐藏&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;hello lyshark&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>标签克隆:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;a onclick=<span class="string">"Add(this)"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">            &lt;input type=<span class="string">"text"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">ths</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> p = $(ths).parent().clone();</span><br><span class="line">            p.find(<span class="string">'a'</span>).text(<span class="string">'-'</span>);</span><br><span class="line">            p.find(<span class="string">'a'</span>).attr(<span class="string">'onclick'</span>,<span class="string">'Remove(this)'</span>);</span><br><span class="line">            $(ths).parent().parent().append(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Remove</span>(<span class="params">ths</span>) </span>&#123;</span><br><span class="line">            $(ths).parent().remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>全选与反选:</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"MyDiv"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"全选"</span> onclick=<span class="string">"CheckAll()"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"取消"</span> onclick=<span class="string">"CancleAll()"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"反选"</span> onclick=<span class="string">"ReverseAll()"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-3.3</span><span class="number">.1</span>.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        function CheckAll() &#123;</span></span><br><span class="line"><span class="string">            $('.MyDiv input[type="</span>checkbox<span class="string">"]').prop('checked',true);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        function CancleAll() &#123;</span></span><br><span class="line"><span class="string">            $('.MyDiv input[type="</span>checkbox<span class="string">"]').prop('checked',false);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">         function ReverseAll() &#123;</span></span><br><span class="line"><span class="string">             $('.MyDiv input[type="</span>checkbox<span class="string">"]').each(function () &#123;</span></span><br><span class="line"><span class="string">                 if($(this).prop('checked'))&#123;</span></span><br><span class="line"><span class="string">                    $(this).prop('checked',false);</span></span><br><span class="line"><span class="string">                 &#125;else&#123;</span></span><br><span class="line"><span class="string">                    $(this).prop('checked',true);</span></span><br><span class="line"><span class="string">                 &#125;</span></span><br><span class="line"><span class="string">             &#125;);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JQuery 是一个兼容多浏览器支持的JavaScript库,其核心理念是write less,do more(写得更少,做得更多),它是轻量级的js库,兼容CSS3还兼容各种浏览器,需要注意的是后续版本将不再支持IE6/7/8浏览器,jQuery使用户能更方便地处理HTML、events、实现动画效果,并且方便地为网站提供AJAX交互,jQuery还有一个比较大的优势是,它的文档说明很全,而且各种应用也说得很详细,同时还有许多成熟的插件可供选择,jQuery能够使用户的html页面保持代码和html内容分离,也就是说,不用再在html里面插入一堆js来调用命令了,只需要定义id即可,在后续的开发工作中我们经常会用到JQuery框架,你也能够在各种的网页结构中发现它的身影.&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="https://localhost/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端开发" scheme="https://localhost/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Web前端开发JavaScript提高(4)</title>
    <link href="https://localhost/2019/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91JavaScript%E6%8F%90%E9%AB%98-4/"/>
    <id>https://localhost/2019/02/21/前端开发/Web前端开发JavaScript提高-4/</id>
    <published>2019-02-21T14:28:24.000Z</published>
    <updated>2019-09-07T00:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 一种直译式脚本语言,是一种动态类型、弱类型、基于原型的语言,内置支持类型,它的解释器被称为JavaScript引擎,是浏览器的一部分,并且是被广泛用于客户端的脚本语言,JavaScript最早是在HTML网页上使用,它是属于网络的脚本语言,现在已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果,通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的,现在随着node.js引擎的出现,使得JavaScript逐步成为了一种全栈开发语言了.</p><a id="more"></a><p><br></p><h2 id="JavaScript-面向对象"><a href="#JavaScript-面向对象" class="headerlink" title="JavaScript 面向对象"></a>JavaScript 面向对象</h2><p>JS是基于对象的(Object-Based)脚本语言,而不是面向对象(Object-Oriented)中所使用的那个对象,之所以说JS是一门基于对象的编程语言,是因为它没有提供抽象,继承,封装等面向对象语言的很多功能,而是把其他语言所创建的复杂对象统一起来,从而形成一个非常强大的对象系统.</p><p>对象是编程语言中很重要的特征之一,JS是基于对象的编程语言,所以支持面向对象的所有特性,灵活使用这些对象能够实现丰富而强大的功能,下面我们首先来看如何创建一个自定义类,代码如下:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">name,age</span>)</span>&#123;                  <span class="comment">//定义类,类名MyClass</span></span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;         <span class="comment">//定义的一个函数体</span></span><br><span class="line">                <span class="built_in">document</span>.write(<span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"年龄: "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> temp = <span class="keyword">new</span> MyClass(<span class="string">"lyshark"</span>,<span class="number">22</span>);        <span class="comment">//实例化一个对象</span></span><br><span class="line">        temp.print()                                 <span class="comment">//调用对象中的函数体</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码执行后会打印出姓名和年龄,但是这种写法在实例化对象时,系统会为每个对象中均保存了一个相同的<code>print()</code>函数,从而浪费内存,使用原型写法可以解决该问题,改进代码如下:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        MyClass.prototype = &#123;</span><br><span class="line">            print:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">document</span>.write(<span class="string">"姓名: "</span> + <span class="keyword">this</span>.name + <span class="string">"年龄: "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> temp = <span class="keyword">new</span> MyClass(<span class="string">"lyshark"</span>,<span class="number">22</span>);        <span class="comment">//实例化一个对象</span></span><br><span class="line">        temp.print()                                 <span class="comment">//调用对象中的函数体</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆Date-对象◆"><a href="#◆Date-对象◆" class="headerlink" title="◆Date 对象◆"></a>◆Date 对象◆</h3><p>Date对象用于处理日期和时间,提供了很多高级的处理方法,可以用来帮助网站制作人员读取和设置日期和时间以及定义日期和时间的显示格式等,在JS中使用Date对象前需要先创建对象实例,然后才可以使用.</p><p><strong>读取日期方法:</strong> 下面是几个常用的日期获取方法和说明信息,设置日期一般不会用到.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前年份: "</span> + now.getFullYear() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前月份: "</span> + now.getMonth() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前日期: "</span> + now.getDate() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前周几: "</span> + now.getDay() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前小时: "</span> + now.getHours() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前分钟: "</span> + now.getMinutes() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前秒数: "</span> + now.getSeconds() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"当前时间戳: "</span> + now.getTime() + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>data对象转换:</strong> 将获取到的日期时间戳,通过不同的方式展示出来.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用UTC时区表示: "</span> + now.toUTCString(now.getTime()) + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用本地时区表示: "</span> + now.toLocaleString(now.getTime()) + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用本地时区表示日期: "</span> + now.toDateString(now.getTime()) + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用本地中国标准时间: "</span> + now.toTimeString(now.getTime()) + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用本地时区表示2019/02/21: "</span> + now.toLocaleDateString(now.getTime()) +<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"采用本地时区表示4:01:55 : "</span> + now.toLocaleTimeString(now.getTime()) +<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆Math-对象◆"><a href="#◆Math-对象◆" class="headerlink" title="◆Math 对象◆"></a>◆Math 对象◆</h3><p>Math对象的方法是编程过程中经常使用的数学函数,如三角函数、平方根、四舍五入等,对象的方法同Math对象的属性一样,属于Math对象本身,在引用这些方法时,直接使用Math而不用使用Math对象的实例名称.</p><p><strong>Math常用方法:</strong> 一些常用的Math数值计算方法.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"产生随机数[0-9]: "</span> + <span class="built_in">parseInt</span>(<span class="number">10</span> * <span class="built_in">Math</span>.random())  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"产生随机数[任意数字]: "</span> + <span class="built_in">String</span>.fromCharCode(<span class="number">97</span> * <span class="built_in">Math</span>.random())  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"返回数值的绝对值: "</span> + <span class="built_in">Math</span>.abs(<span class="number">3.161592654</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"返回x和y中较大的一个数: "</span> + <span class="built_in">Math</span>.max(<span class="number">10</span>,<span class="number">87</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"返回x和y中较小的一个数: "</span> + <span class="built_in">Math</span>.min(<span class="number">10</span>,<span class="number">87</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"返回x的y次方根: "</span> + <span class="built_in">Math</span>.pow(<span class="number">10</span>,<span class="number">87</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"对x进行四舍五入: "</span> + <span class="built_in">Math</span>.round(<span class="number">12.425</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"返回x的平方根: "</span> + <span class="built_in">Math</span>.sqrt(<span class="number">10</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆RegExp-对象◆"><a href="#◆RegExp-对象◆" class="headerlink" title="◆RegExp 对象◆"></a>◆RegExp 对象◆</h3><p>正则表达式并非一门专用语言,但也可以看作是一种语言,它可以让用户通过使用一系列普通字符和特殊字符构建能明确描述文本字符串的匹配模式.除了简单描述这些模式之外,正则表达式解释引擎通常可用于遍历匹配,并使用模式作为分隔符来将字符串解析为子字符串,或以智能方式替换文本或重新设置文本格式.正则表达式为解决与文本处理有关的许多常见任务提供了有效而简捷的方式.</p><p><strong>正则匹配:</strong> 一些常用的正则匹配函数,正则表达式是通用的,请自行百度.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> string = <span class="string">"hello123world567mynames;"</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"Match全局匹配: "</span> + string.match(<span class="regexp">/\d+/g</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"Search取出第一个结果的索引值: "</span> + string.search(<span class="regexp">/\d+/g</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"Split取出第一个结果的索引值: "</span> + string.split(<span class="regexp">/\d+/g</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="string">"\d+"</span>,g);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"测试字符是否存在: "</span> + reg.test(<span class="string">"names123123lyshark456,789"</span>)  + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆Window-对象◆"><a href="#◆Window-对象◆" class="headerlink" title="◆Window 对象◆"></a>◆Window 对象◆</h3><p>Window 对象称之为窗口对象,位于浏览器对象模型的最顶层,代表整个浏览器窗口,是Web浏览所有内容的主容器,只要打开一个浏览器窗口,就创建了一个Window对象,即使没有在窗口上显示任何内容.</p><p><strong>打开关闭窗口:</strong> 利用<code>window.open()</code>打开网页,<code>window.close()</code>关闭打开的网页.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">msg.html</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=<span class="string">"#bc8f8f"</span>&gt;</span><br><span class="line">    &lt;table width=<span class="string">"300"</span> height=<span class="string">"200"</span> border=<span class="string">"0"</span> cellpadding=<span class="string">"0"</span> cellspacing=<span class="string">"0"</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td valign=<span class="string">"top"</span>&gt; 网页通知</span><br><span class="line">                &lt;p&gt; 这是一个通知信息,您可以忽略掉&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>td&gt;</span><br><span class="line">        &lt;<span class="regexp">/tr&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>table&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">index.html</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="button" value="弹出通知" onclick="msg()"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="button" value="关闭通知" onclick="msg_close()"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        function msg()&#123;</span></span><br><span class="line"><span class="string">            open("</span>msg.html<span class="string">","</span>通知<span class="string">",height=50,width=30,top=20,left=10);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        function msg_close() &#123;</span></span><br><span class="line"><span class="string">            close()</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>弹出提示框:</strong> 点击按钮自动弹出<code>Window.alert()</code>提示消息框.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"点击弹窗"</span> onclick=<span class="string">"msg()"</span>&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"这是一个提示框..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>弹出选择框:</strong> <code>Window.confirm()</code>弹出一条信息让用户确认,包括确认和取消按钮.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"弹窗口"</span> onclick=<span class="string">"msg()"</span>&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(confirm(<span class="string">"请输入你的选项.."</span>))&#123;</span><br><span class="line">                alert(<span class="string">"感谢您的参与.."</span>)       <span class="comment">//确认按钮执行语句</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alert(<span class="string">"取消语句.."</span>)           <span class="comment">//取消按钮执行语句</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>弹出输入框:</strong> <code>window.prompt()</code>用于弹出一个输入框,可以让用户输入一些信息.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> passwd = prompt(<span class="string">"请输入密码(密码是123): "</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span>(passwd !=<span class="string">"123"</span>)&#123;</span><br><span class="line">            passwd = prompt(<span class="string">"密码错误,请重新输入: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(passwd ==<span class="string">"123"</span>)&#123;alert(<span class="string">"密码正确..."</span>)&#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>设置单次定时器:</strong> 以下案例,实现当点击删除按钮时,屏幕提示删除成功,在5秒后自动的隐藏标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"status"</span> style=<span class="string">"color: red;"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"删除定时"</span> onclick=<span class="string">"DeleteStatus()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">DeleteStatus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> temp = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line">            temp.innerText = <span class="string">"删除成功了..."</span>;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                temp.innerText = <span class="string">""</span>;</span><br><span class="line">            &#125;,<span class="number">50000</span>);                     <span class="comment">//设置5秒后执行清空标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>设置循环定时器:</strong> <code>setIntercal()设置定时器</code>,<code>clearInterval()清除定时器</code>,定时器用于周期性执行.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> id=<span class="string">"clock"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"开始执行"</span> onclick=<span class="string">"begin_func()"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"取消执行"</span> onclick=<span class="string">"end_func()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">begin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">var</span> stime = now.getTime()</span><br><span class="line">            <span class="keyword">var</span> ret = <span class="built_in">document</span>.getElementById(<span class="string">"clock"</span>);</span><br><span class="line">            ret.value=stime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ID;                                <span class="comment">//定义全局变量,后期用于清楚定时器</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">begin_func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             ID =setInterval(begin,<span class="number">1000</span>);     <span class="comment">//每隔1秒执行一次,设置定时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">end_func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            clearInterval(ID);                <span class="comment">//取消一秒内执行,清除定时器</span></span><br><span class="line">            ID = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="JavaScript-DOM编程"><a href="#JavaScript-DOM编程" class="headerlink" title="JavaScript DOM编程"></a>JavaScript DOM编程</h2><p>文档对象模型 (Document Object Model,DOM) 是一种W3C标准所有的现代浏览器都支持DOM,DOM用于HTML和XML文档的编程接口,它给文档提供了一种结构化的表示方法,可以改变文档的内容和呈现方式.最为关心的是,DOM把网页和脚本以及其他的编程语言联系了起来,DOM属于浏览器,而不是JavaScript语言规范里的规定的核心内容.Dom+JavaScript就能使网页动起来,一般使用JQuery来做这事,JQuery封装了JavaScript+Dom变得更为简单,这里我们只需要了解一些基本内容.</p><h3 id="◆DOM-查找元素◆"><a href="#◆DOM-查找元素◆" class="headerlink" title="◆DOM 查找元素◆"></a>◆DOM 查找元素◆</h3><p><strong>GetElementById:</strong> 根据ID号获取一个标签,这种方式是最常用的.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span>&gt; hello world &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var temp = document.getElementById("</span>MyDiv<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>获取到的结果: <span class="string">" + temp.innerText);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>getElementsByName:</strong> 根据自定义标签<code>alex=MyDiv</code>属性获取标签集合.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div alex=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var names = document.getElementsByName("</span>alex<span class="string">");      //通过自定义的名称找标签</span></span><br><span class="line"><span class="string">        names.innerText = "</span>www.baidu.com<span class="string">";                   //改变元素标签名称</span></span><br><span class="line"><span class="string">        document.write("</span>修改后的内容:<span class="string">" + names.innerText);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>getElementsByClassName:</strong> 根据class类名称属性获取标签集合.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div clas=<span class="string">"MyClass"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var names = document.getElementsByClassName("</span>MyClass<span class="string">");  //通过类名称找出标签</span></span><br><span class="line"><span class="string">        names.innerText = "</span>www.baidu.com<span class="string">";                       //改变元素标签名称</span></span><br><span class="line"><span class="string">        document.write("</span>修改后的内容:<span class="string">" + names.innerText);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>getElementsByTagName:</strong> 根据标签名<code>name=&quot;MyDiv&quot;</code>来获取标签集合.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div name=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var names = document.getElementsByName("</span>MyDiv<span class="string">");      //通过标签名称找出标签</span></span><br><span class="line"><span class="string">        names.innerText = "</span>www.baidu.com<span class="string">";                    //改变元素标签名称</span></span><br><span class="line"><span class="string">        document.write("</span>修改后的内容:<span class="string">" + names.innerText);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="◆DOM-标签操作◆"><a href="#◆DOM-标签操作◆" class="headerlink" title="◆DOM 标签操作◆"></a>◆DOM 标签操作◆</h3><p><strong>innerText:</strong> 该方式只能对单纯的标签进行操作,如果标签中嵌入了其他标签,那么该方式会自动过滤掉标签格式.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"lyshark"</span>&gt;hello world&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var temp = document.getElementById("</span>lyshark<span class="string">");                 //通过标签ID获取标签句柄</span></span><br><span class="line"><span class="string">        document.write("</span>原来的内容: <span class="string">" + temp.innerText + "</span>&lt;br&gt;<span class="string">");      //获取标签中原始的内容</span></span><br><span class="line"><span class="string">        temp.innerText = "</span>alex<span class="string">"                                       //修改标签中的内容为alex</span></span><br><span class="line"><span class="string">        document.write("</span>修改后的内容: <span class="string">" + temp.innerText + "</span>&lt;br&gt;<span class="string">");    //获取修改后的标签内容</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>innerHTML:</strong> 该方式不但可以修改文本,还可以同时修改HTML的嵌套标签,修改时应加上标签格式.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"lyshark"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var temp = document.getElementById("</span>lyshark<span class="string">");                //通过标签ID获取标签句柄</span></span><br><span class="line"><span class="string">        document.write("</span>原来的内容: <span class="string">" + temp.innerHTML + "</span>&lt;br&gt;<span class="string">");      //获取标签中原始的内容</span></span><br><span class="line"><span class="string">        temp.innerHTML = '&lt;b&gt; hello alex &lt;/b&gt;'                        //修改标签中的内容为alex</span></span><br><span class="line"><span class="string">        document.write("</span>修改后的内容: <span class="string">" + temp.innerHTML + "</span>&lt;br&gt;<span class="string">");    //获取修改后的标签内容</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>inner 循环修改:</strong> 通过使用数组的形式,可以实现循环修改元素,比如以下循环修改<code>name=&quot;MyDiv&quot;</code>的所有标签内容.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div name=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div name="MyDiv"&gt; &lt;b&gt; hello lyshark &lt;/</span>b&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;div name=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span> hello lyshark <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div name="MyDiv"&gt; &lt;b&gt; hello lyshark &lt;/</span>b&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> names = <span class="built_in">document</span>.getElementsByName(<span class="string">"MyDiv"</span>);      <span class="comment">//通过标签名称找出标签</span></span><br><span class="line">        <span class="comment">//id.innerText = "www.mkdirs.com";       不生效:原因是标签名称重复,需要使用数组</span></span><br><span class="line">        names[<span class="number">0</span>].innerText = <span class="string">"www.mkdirs.com"</span>;                <span class="comment">//改变第1个元素标签名称</span></span><br><span class="line">        names[<span class="number">1</span>].innerText = <span class="string">"www.mkdirs.com"</span>;                <span class="comment">//改变第2个元素标签名称</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//------------------------------------------------</span></span><br><span class="line">        <span class="comment">//通过循环修改多个标签</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"总共有标签数: "</span> + names.length);       <span class="comment">//可以统计总共标签数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> names)&#123;</span><br><span class="line">            names[item].innerText = <span class="string">"www.mkdirs.com"</span>;         <span class="comment">//这里写批量修改的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>CreateElement 创建标签:</strong> 使用最原始的方式创建标签,实现在父容器<code>div id=tags</code>中,动态的添加a标签.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt; -------------------------[方式<span class="number">1</span>]------------------------- &gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>                          &lt;!--指定一个父容器--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> tag = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);      <span class="comment">//指定标签格式:这里是a标签</span></span><br><span class="line">        tag.innerText = <span class="string">"点我跳转"</span>;                 <span class="comment">//设置标签名称</span></span><br><span class="line">        tag.href = <span class="string">"http://www.baidu.com"</span>;          <span class="comment">//设置跳转地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> id1 = <span class="built_in">document</span>.getElementById(<span class="string">"MyDiv"</span>);  <span class="comment">//获取标签的对象</span></span><br><span class="line">        id1.appendChild(tag)                         <span class="comment">//放到标签里面</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line">&lt; -------------------------[方式<span class="number">2</span>]------------------------- &gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>                          &lt;!--指定一个父容器--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> tag = <span class="string">"&lt;a class='c1' href='http://www.baidu.com'&gt;点我啊&lt;/a&gt;"</span>;</span><br><span class="line">        <span class="keyword">var</span> id1 =<span class="built_in">document</span>.getElementById(<span class="string">"MyDiv"</span>);     <span class="comment">//加到这个标签的里面</span></span><br><span class="line">        id1.innerHTML = tag;                          <span class="comment">//直接通过inner追加进去</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆DOM-属性操作◆"><a href="#◆DOM-属性操作◆" class="headerlink" title="◆DOM 属性操作◆"></a>◆DOM 属性操作◆</h3><p><strong>修改类属性:</strong> 分别新建两个CSS属性,并通过<code>className</code>方法,实现后期对类属性的修改.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        .show_table&#123;</span><br><span class="line">            display: block;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .hide_table&#123;</span><br><span class="line">            display: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"show_table"</span>&gt; hello world &lt;<span class="regexp">/div&gt;   &lt;!--指定修改的标签--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var ids = document.getElementById("</span>MyDiv<span class="string">");          //通过ID找到标签</span></span><br><span class="line"><span class="string">        ids.className = "</span>hide_table<span class="string">";                        //指定使用hid_table的CSS属性</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>修改标签属性:</strong> 修改DIV标签<code>id=MyDiv</code>的标签属性,将<code>name=lyshark</code>修改为<code>name=hello</code>.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span> name=<span class="string">"lyshark"</span>&gt; hello world &lt;<span class="regexp">/div&gt;                &lt;!--准备修改的标签--&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var ids = document.getElementById("</span>MyDiv<span class="string">");                  //找到DIV标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        document.write("</span>当前 Name= <span class="string">" + ids.getAttribute('name'));    //找到div1标签里面的name属性</span></span><br><span class="line"><span class="string">        ids.setAttribute('name','hello');                           //将name属性修改为name=hello</span></span><br><span class="line"><span class="string">        document.write("</span>修改后 Name= <span class="string">" + ids.getAttribute('name'));  //修改后,再次打印出结果</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>修改标签样式:</strong> 修改标签的CSS代码的格式,可以修改多个,但是标签中必须存在该字段,否则无法修改.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"MyDiv"</span> name=<span class="string">"lyshark"</span> style=<span class="string">"background-color: red "</span>&gt; hello world &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var ids = document.getElementById("</span>MyDiv<span class="string">");                  //找到DIV标签</span></span><br><span class="line"><span class="string">        ids.style.backgroundColor = "</span>green<span class="string">";                         //将背景色改成绿色</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>伪造表单提交:</strong> 自己实现一个submit的表单提交功能,自己定义提交按钮的功能.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=<span class="string">"MyForm"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"submit提交"</span>&gt;</span><br><span class="line">        &lt;a onclick=<span class="string">"Submit()"</span>&gt;自定义提交&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Submit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"MyForm"</span>);</span><br><span class="line">            form.submit();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="JavaScript-事件绑定"><a href="#JavaScript-事件绑定" class="headerlink" title="JavaScript 事件绑定"></a>JavaScript 事件绑定</h2><p>JavaScript 的事件和事件驱动为网页增添了丰富的交互性,事件是用户在操作浏览器的过程中,由用户触发或由浏览器自身触发的动作,浏览器捕获这些动作,并根据用户编程时设置的对应这些动作的事件处理程序,触发相应的处理过程,从而实现交互过程,浏览器在程序运行的大部分时间都等待交互事件的发生,并在发生时,自动的调用事件处理函数,完成整个处理过程.</p><h3 id="◆键盘事件◆"><a href="#◆键盘事件◆" class="headerlink" title="◆键盘事件◆"></a>◆键盘事件◆</h3><p><strong>keyDown:</strong> 当键盘按下某个键时会触发KeyDown事件,用于浏览器窗体,图像,超链接,文本区域.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"text"</span> onkeydown=<span class="string">"func_keydown()"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func_keydown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"你按下了一个键.."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>keyUp:</strong> 当键盘松开某个键时会触发Keyup事件,用于浏览器窗体,图像,超链接,文本区域.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"text"</span> onkeyup=<span class="string">"func_keyup()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func_keyup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"你按松开了一个键.."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>KeyPress:</strong> 当键盘上同时按下一个键并且同时弹出,则执行指定的函数.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"text"</span> onkeypress=<span class="string">"func_keypress()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func_keypress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"同时按下并弹出.."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Resize:</strong> 当浏览器窗口或帧的大小发生变化时触发Resize事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body onresize=<span class="string">"mesg()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mesg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">"窗口大小已被改变了..."</span> + <span class="string">"&lt;br&gt;"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>keycode:</strong> 用户在body区域中按下空格键,触发弹出信息框.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body onkeypress=<span class="string">"keycode()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">keycode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">window</span>.event.keyCode == <span class="number">32</span>)&#123;</span><br><span class="line">                alert(<span class="string">"您按下了空格..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆鼠标事件◆"><a href="#◆鼠标事件◆" class="headerlink" title="◆鼠标事件◆"></a>◆鼠标事件◆</h3><p><strong>Click:</strong> 鼠标在一个对象上左键点击触发<code>Click</code>事件,对象包括button,document,checkbox,link,radio,submit.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"button1"</span> value=<span class="string">"按钮1"</span> onclick=<span class="string">"alert('按钮1被按下了...')"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> id=<span class="string">"button2"</span> value=<span class="string">"按钮2"</span> onclick=<span class="string">"alert('按钮2被按下了...')"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>MouseDown&amp;MouseUP:</strong> 当我们按下鼠标,系统触发<code>MouseDown</code>事件,释放鼠标时自动触发<code>MouseUP</code>事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"点我"</span> onmousedown=<span class="string">"down()"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"点我"</span> onmouseup=<span class="string">"up()"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">"你按下了按键..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">"你释放了按键..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>MouseOver&amp;MouseOut:</strong> 鼠标指针到达一个对象之上时,触发<code>MouseOver</code>事件,鼠标离开时触发<code>MouseOut</code>事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"鼠标在按钮上"</span> onmouseover=<span class="string">"in_over()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"鼠标离开按钮"</span> onmouseout=<span class="string">"out_over()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">in_over</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"鼠标在按钮上..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">out_over</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"鼠标离开按钮..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="◆其他事件◆"><a href="#◆其他事件◆" class="headerlink" title="◆其他事件◆"></a>◆其他事件◆</h3><p><strong>OnClick:</strong> 通用事件,可以绑定到任何可以操作的标签中,当事件触发后,执行对应的函数体.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"弹窗"</span> onclick=<span class="string">"show()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"触发弹窗一个窗口提示..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Focus&amp;Blur:</strong> 当屏幕上的光标进入对象区域内时触发<code>focus</code>事件,反之当光标离开时触发<code>blur</code>事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input onfocus=<span class="string">"Focus(this);"</span> onblur=<span class="string">"Blur(this);"</span></span><br><span class="line">       id=<span class="string">"search"</span> value=<span class="string">"请输入关键字"</span> style=<span class="string">"color: gray;"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Focus</span>(<span class="params">ths</span>)</span>&#123;             <span class="comment">//光标来到执行</span></span><br><span class="line">            ths.style.color = <span class="string">"black"</span>;</span><br><span class="line">            <span class="keyword">if</span>(ths.value == <span class="string">'请输入关键字'</span> || ths.value.trim() == <span class="string">""</span>)&#123;</span><br><span class="line"></span><br><span class="line">                ths.value = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Blur</span>(<span class="params">ths</span>)</span>&#123;            <span class="comment">//光标离开执行</span></span><br><span class="line">            <span class="keyword">if</span>(ths.value.trim() == <span class="string">""</span>)&#123;</span><br><span class="line">                ths.value = <span class="string">'请输入关键字'</span>;</span><br><span class="line">                ths.style.color = <span class="string">'gray'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ths.style.color = <span class="string">"black"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Submit(1):</strong> 通常和form标记配合使用,其作用是用于送出数据,用户在form中输入数据后,点击Sumbit触发自定义函数.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form name=<span class="string">"forms"</span> method=<span class="string">"post"</span> onsubmit=<span class="string">"return check()"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> name=<span class="string">"texts"</span> size=<span class="string">"20"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        function check() &#123;</span></span><br><span class="line"><span class="string">            if(document.forms.texts.value == "</span><span class="string">")&#123;</span></span><br><span class="line"><span class="string">                document.forms.focus()</span></span><br><span class="line"><span class="string">                alert("</span>用户没有输入任何内容...<span class="string">")</span></span><br><span class="line"><span class="string">                return false</span></span><br><span class="line"><span class="string">            &#125;else</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                alert("</span>用户输入了内容...<span class="string">")</span></span><br><span class="line"><span class="string">                return true</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>Submit(2):</strong> 通常和form标记配合使用,其作用是用于送出数据,用户在form中输入数据后,点击Sumbit触发自定义函数.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"https://www.baidu.com"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> id=<span class="string">"username"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span> onclick=<span class="string">"return MySub()"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        function MySub()&#123;</span></span><br><span class="line"><span class="string">            var user = document.getElementById("</span>username<span class="string">");</span></span><br><span class="line"><span class="string">            if(user.value.length &gt; 0)&#123;</span></span><br><span class="line"><span class="string">                alert("</span>编辑框内有数据,允许提交数据..<span class="string">")</span></span><br><span class="line"><span class="string">                return true;</span></span><br><span class="line"><span class="string">            &#125;else</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                alert("</span>用户名输入不能为空...<span class="string">")</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>Reset:</strong> 通常情况下和form标记配合使用,其起到的作用是,当用户完成信息输入后,按下按钮自动清空已经输入的数据.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form name=<span class="string">"forms"</span> method=<span class="string">"post"</span> &gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"password"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"reset"</span> value=<span class="string">"重置"</span> onreset=<span class="string">"reset()"</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--&lt;script type="text/</span>javascript<span class="string">"&gt;--&gt;</span></span><br><span class="line"><span class="string">        &lt;!--function reset()&#123;--&gt;</span></span><br><span class="line"><span class="string">            &lt;!--alert("</span>内容已经清空了...<span class="string">")--&gt;</span></span><br><span class="line"><span class="string">            &lt;!--return 1--&gt;</span></span><br><span class="line"><span class="string">        &lt;!--&#125;--&gt;</span></span><br><span class="line"><span class="string">    &lt;!--&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>Change:</strong> 当文本区域中的鼠标指针移离该对象时,若对象内容与原来内容不同,则就会触发Change事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"3"</span> cols=<span class="string">"30"</span> value=<span class="string">""</span></span><br><span class="line">              onchange=<span class="string">"show()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"您在文本框中添加了新的内容..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Select:</strong> 当一个文本框,文本区域对象中的文本被选中时就会触发Select事件,未被选择则不会出现提示框.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> value=<span class="string">"hello lyshark"</span> onselect=<span class="string">"show()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"您选中了文本框中的文本内容..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Error:</strong> 当网页因为某种原因出现错误时就会触发,在错误处理程序中可以绑定操作,该标签常用与<code>&lt;body&gt;,&lt;img&gt;</code>配合.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">"temp.jpg"</span> onerror=<span class="string">"error_msg()"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">error_msg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"图片加载失败了..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 一种直译式脚本语言,是一种动态类型、弱类型、基于原型的语言,内置支持类型,它的解释器被称为JavaScript引擎,是浏览器的一部分,并且是被广泛用于客户端的脚本语言,JavaScript最早是在HTML网页上使用,它是属于网络的脚本语言,现在已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果,通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的,现在随着node.js引擎的出现,使得JavaScript逐步成为了一种全栈开发语言了.&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="https://localhost/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端开发" scheme="https://localhost/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
