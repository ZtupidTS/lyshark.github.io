<!DOCTYPE html>













<html class="theme-next gemini" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">











<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"slideUpIn","post_header":"slideUpIn","post_body":"slideUpIn","coll_header":"slideUpIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Docker 诞生于2013年,最初发起者是dotCloud公司.Docker自开源后受到广泛的关注和讨论,目前已有多个相关项目逐渐形成了围绕Docker容器的生态体系,由于Docker在业界造成的影响力实在太大,dotCloud公司后来也直接改名为Docker Inc,并专注于Docker相关技术和产品的开发. Docker是基于Go语言实现的开源容器项目,Docker让开发者可以打包他们的应用">
<meta name="keywords" content="Linux 服务配置">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 容器配置笔记">
<meta property="og:url" content="https://localhost/2018/12/14/Linux 服务配置/Docker-容器配置笔记/index.html">
<meta property="og:site_name" content="哔哩哔">
<meta property="og:description" content="Docker 诞生于2013年,最初发起者是dotCloud公司.Docker自开源后受到广泛的关注和讨论,目前已有多个相关项目逐渐形成了围绕Docker容器的生态体系,由于Docker在业界造成的影响力实在太大,dotCloud公司后来也直接改名为Docker Inc,并专注于Docker相关技术和产品的开发. Docker是基于Go语言实现的开源容器项目,Docker让开发者可以打包他们的应用">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-18T15:28:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker 容器配置笔记">
<meta name="twitter:description" content="Docker 诞生于2013年,最初发起者是dotCloud公司.Docker自开源后受到广泛的关注和讨论,目前已有多个相关项目逐渐形成了围绕Docker容器的生态体系,由于Docker在业界造成的影响力实在太大,dotCloud公司后来也直接改名为Docker Inc,并专注于Docker相关技术和产品的开发. Docker是基于Go语言实现的开源容器项目,Docker让开发者可以打包他们的应用">



  <link rel="alternate" href="/atom.xml" title="哔哩哔" type="application/atom+xml">




  <link rel="canonical" href="https://localhost/2018/12/14/Linux 服务配置/Docker-容器配置笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Docker 容器配置笔记 | 哔哩哔</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">哔哩哔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://localhost/2018/12/14/Linux 服务配置/Docker-容器配置笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王瑞">
      <meta itemprop="description" content="记录点滴技术成长之路">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="哔哩哔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker 容器配置笔记

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-14 12:01:33" itemprop="dateCreated datePublished" datetime="2018-12-14T12:01:33+08:00">2018-12-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-18 23:28:38" itemprop="dateModified" datetime="2019-05-18T23:28:38+08:00">2019-05-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux-服务配置/" itemprop="url" rel="index"><span itemprop="name">Linux 服务配置</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Docker 诞生于2013年,最初发起者是dotCloud公司.Docker自开源后受到广泛的关注和讨论,目前已有多个相关项目逐渐形成了围绕Docker容器的生态体系,由于Docker在业界造成的影响力实在太大,dotCloud公司后来也直接改名为Docker Inc,并专注于Docker相关技术和产品的开发.</p>
<p>Docker是基于Go语言实现的开源容器项目,Docker让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的 Linux 机器上,也可以实现虚拟化.容器是完全使用沙箱机制,相互之间不会有任何接口,</p>
<a id="more"></a>
<p><br></p>
<h2 id="Docker-容器简介"><a href="#Docker-容器简介" class="headerlink" title="Docker 容器简介"></a>Docker 容器简介</h2><p>Docker的构想是要实现 “Build,Ship and Run Any App,Anywhere” ,即通过对应用的封装(Packaging)、分发(Distribution)、部署(Deployment)、运行(Runtime)生命周期进行管理,达到应用组件 “一次封装,到处运行” 的目的.这里的应用组件,既可以是一个Web应用、一个编译环境,也可以是一套数据库平台服务,甚至是一个操作系统或集群.基于Linux平台上的多项开源技术,Docker提供了高效、敏捷和轻量级的容器方案,并支持部署到本地环境和多种主流云平台.可以说,Docker首次为应用的开发、运行和部署提供了”一站式”的实用解决方案,而且Docker的源代码是开源的,并已加入了Linux基金会,遵循Apache2.0协议,全部开源代码均在<code>https://github.com/docker/</code>上进行维护.</p>
<p>跟大部分新兴技术的诞生一样,Docker也并非”从石头缝里蹦出来的”,而是站在前人的肩膀上,其中最重要的就是Linux容器(LinuxContainers LXC)技术,LXC可以提供轻量级的虚拟化,以便隔离进程和资源,而且不需要提供指令解释机制以及全虚拟化的其他复杂性.相当于C++中的NameSpace.容器有效地将由单个操作系统管理的资源划分到孤立的组中,以更好地在孤立的组之间平衡有冲突的资源使用需求,LXC在资源管理方面依赖于Linux内核的cgroups子系统,cgroups子系统是Linux内核提供的一个基于进程组的资源管理的框架,可以为特定的进程组限定可以使用的资源.LXC在隔离控制方面依赖于Linux内核的namespace特性,具体而言就是在clone时加入相应的flag.</p>
<p><strong>Docker与Linux系统</strong></p>
<p>在LXC的基础上,Docker进一步优化了容器的使用体验,首先Docker提供了各种容器管理工具(如分发、版本、移植等)让用户无需关注底层的操作,可以更简单明了地管理和使用容器.其次Docker通过引入分层文件系统构建和高效的镜像机制,降低了迁移难度,极大地提升了用户体验.用户操作Docker容器就像操作应用自身一样简单,早期的Docker代码实现是直接基于LXC的,自0.9版本开始Docker开发了libcontainer项目,作为更广泛的容器驱动实现,从而替换掉了LXC的实现.目前Docker还积极推动成立了runC标准项目,试图让容器支持不再局限于Linux操作系统,而是更安全、更具扩展性.</p>
<p>简单来说,其实我们可以把Docker容器理解为一种轻量级的沙盒(sandbox),每个容器内运行着一个应用,不同的容器相互隔离,容器之间也可以通过网络互相通信.容器的创建和停止都十分快速,几乎跟创建和终止原生应用一致.另外,容器自身对系统资源的额外需求也十分有限,远远低于传统虚拟机.很多时候,甚至直接把容器当作应用本身也没有任何问<br>题.</p>
<p><strong>Docker虚拟化的好处</strong></p>
<p>Docker项目的发起人和Docker公司CTO Solomon Hykes曾认为,Docker在正确的地点、正确的时间顺应了正确的趋势——如何正确地构建应用.在云时代,开发者创建的应用必须要能很方便地在网络上传播,也就是说应用必须脱离底层物理硬件的限制.同时必须是”任何时间、任何地点”可获取的,因此,开发者需要一种新型的创建分布式应用程序的方式,快速分发和部署,这正是Docker所能够提供的最大优势,</p>
<p>Docker还可以快速迁移数据,通过容器来打包应用,解耦应用和运行平台.意味着迁移的时候,只需要在新的服务器上启动需要的容器就可以了,无论新旧服务器是否是同一类型的平台.这无疑将节约大量的宝贵时间,并降低部署过程出现问题的风险.</p>
<p><strong>Go语言与Docker</strong></p>
<p>相比Go语言与其它语言的对比,国内外很多技术媒体都有列举,在Docker领域Go语言相比其它语言的优势在于.</p>
<blockquote>
<p>● 相对于C/C++开发难度低,支持向前兼容,运维维护成本小.<br>● 相对于python生成的是静态文件,有效的避免的低级错误,并且性能高一个等级.<br>● 并发性好,内存占用低,属于编译型.<br>● 部署简单,毕竟生成的静态文件,有glibc的地方就能运行.</p>
</blockquote>
<p>一门语言当然也有自己的缺点,比如内存回收延迟久,图片处理库有bug,对包版本要求严格等一些问题,但是瑕不掩瑜,一个开发成本极其简单,性能优良,部署简单的语言与Docker简直就是天作之合.</p>
<p><strong>Docker的引擎简介</strong></p>
<p>Docker的是基于Linux自带的(Linux Containers,LXC)技术,在LXC上Docker进行了近一步封装.正因为如此,Docker只能在Linux环境下运行,当然前段时间docker终于支持OSX和Windows了,虽然还是体验尝鲜版,但更加方便开发者去开发了.</p>
<p><strong>Docker的原理</strong></p>
<p>其实前面讲了这么多,Docker的原理已经不言而喻,这里用IBM的解释就是:</p>
<p>容器有效的将单个操作系统管理的资源划分到孤立的组中,以便更好的在孤立的组之间平衡有冲突的资源使用需求.与虚拟化相比,这样既不需要指令级模拟,也不需要即时编译.容器可以在核心CPU本地运行指令,而不需要任何专门的解释机制.此外,也避免了准虚拟化(paravirtualization)和系统调用替换中的复杂性.</p>
<p>简而言之就是,Docker是一个盒子,一个盒子装一个玩具,无论你丢在哪里,你给他通电(glibc)他就能运行.你的玩具大就用大盒子,小玩具就用小盒子.</p>
<p>两个应用之间的环境是环境是完全隔离的,建立通信机制来互相调用.容器的创建和停止都十分快速(秒级),容器自身对资源的需求十分有限,远比虚拟机本身占用的资源少.</p>
<hr>
<p>Docker的大部分操作都围绕着它的三大核心概念:镜像、容器、仓库而展开.因此,准确把握这三大核心概念对于掌握Docker技术尤为重要,在docker中,我们重点关注的就是镜像和容器了.因为在实际应用中,我们封装好镜像,然后通过镜像来创建容器,在容器运行我们的应用就好了.而server端掌控网络和磁盘,我们不用去关心,启动docker sever 和 docker client都是一条命令的事情.</p>
<p><strong>镜像(Image)：</strong> Docker镜像类似于虚拟机镜像,可以将它理解为一个只读的模板.例如,一个镜像可以包含一个基本的操作系统环境,里面仅安装了一个应用程序,可以把它称为一个镜像,镜像是创建Docker容器的基础.通过版本管理和增量的文件系统,Docker提供了一套十分简单的机制来创建和更新现有的镜像,用户甚至可以从网上下载一个已经做好的应用镜像,并直接使用.</p>
<p><strong>容器(Container)：</strong> Docker容器类似于一个轻量级的沙箱,Docker利用容器来运行和隔离应用.容器是从镜像创建的应用运行实例.可以将其启动、开始、停止、删除,而这些容器都是彼此相互隔离的、互不可见的.可以把容器看做是一个简易版的Linux系统环境,以及运行在其中的应用程序打包而成的盒子.</p>
<p>镜像启动后,都是一堆layer的统一视角,唯一的却别是镜像最上面那一层是只读的,不可以修改,但是容器最上面一层是rw的,提供给用户操作.</p>
<p><strong>仓库(repository)：</strong> Docker仓库类似于代码仓库,它是Docker集中存放镜像文件的场所.根据所存储的镜像公开分享与否,Docker仓库可以分为公开仓库(Public)和私有仓库(Private)两种形式.目前,最大的公开仓库是官方提供的Docker Hub,其中存放了数量庞大的镜像供用户下载.国内不少云服务提供商(如网易云、阿里云等)也提供了仓库的本地源,可以提供稳定的国内访问.<br><br><br><strong>Docker 安装</strong></p>
<p>1.配置YUM源,此处我们使用阿里源,并安装EPEL源,和Docker相应的依赖.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rm -fr /etc/yum.repos.d/*</span></span><br><span class="line">[root@localhost ~]<span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum makecache</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum -y install epel-release</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure></p>
<p>2.下载Docker源,并开始配置一些安装属性列表.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum-config-manager --enable docker-ce-edge</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum-config-manager --enable docker-ce-test</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum-config-manager --disable docker-ce-edge</span></span><br></pre></td></tr></table></figure></p>
<p>3.开始安装Docker,并设置开机自启动.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum install -y docker-ce</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum list docker-ce --showduplicates | sort -r</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl start docker</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable docker</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run hello-world</span></span><br></pre></td></tr></table></figure></p>
<p>4.接着配置好阿里云Docker加速器地址.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/docker/daemon.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"registry-mirrors"</span>: [<span class="string">"https://h8o9al0n.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker version</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="管理Docker镜像"><a href="#管理Docker镜像" class="headerlink" title="管理Docker镜像"></a>管理Docker镜像</h2><p>镜像是Docker三大核心概念中最为重要的,自Docker诞生之日起,镜像就是相关社区最为热门的关键词,Docker运行容器前需要本地存在对应的镜像,如果镜像没保存在本地,Docker会尝试先从默认Docker Hub仓库下载,用户也可以通过配置,使用自定义的镜像仓库.</p>
<p>下面例子将围绕镜像这一核心概念的具体操作,包括如何使用pull命令从Docker Hub仓库中下载镜像到本地,如何查看本地已有的镜像信息和管理镜像标签,如何在远端仓库使用search命令进行搜索和过滤,如何删除镜像标签和镜像文件,如何创建用户定制的镜像并且保存为外部文件.最后,还介绍如何往Docker Hub仓库中推送自己的镜像.</p>
<h3 id="◆查询本地镜像◆"><a href="#◆查询本地镜像◆" class="headerlink" title="◆查询本地镜像◆"></a>◆查询本地镜像◆</h3><p>使用docker images命令可以列出本地主机上已有镜像的基本信息,还可以使用条件过滤出你想要看得到的相关镜像文件的信息.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面信息的参数解释,在列出的信息中可以看到以下几个字段信息:</p>
<blockquote>
<p>REPOSITORY=来自于哪个仓库,比如hello-world仓库.<br>TAG=镜像标签信息,latest表示不同版本信息.<br>IMAGE ID=镜像唯一ID号,此处唯一.<br>CREATED=创建时间信息,镜像最后的更新时间.<br>SIZE=镜像大小,优秀的镜像往往体积都较小,hello-world很优秀.</p>
</blockquote>
</blockquote>
<p>其中镜像的ID信息十分重要,它唯一标识了镜像.在使用镜像ID的时候,一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID,比如后期我们要删除一个镜像时无需写出全部镜像ID.</p>
<p>TAG信息用来标记来自同一个仓库的不同镜像,例如ubuntu仓库中有多个镜像,通过TAG信息来区分发行版本,包括13.04、14.04、16.04等标签.</p>
<p>镜像大小信息只是表示该镜像的逻辑体积大小,实际上由于相同的镜像层本地只会存储一份,物理上占用的存储空间会小于各镜像的逻辑体积之和.</p>
<p><strong>实例1：</strong> 通过使用<code>-a --all=true|false</code>参数,列出所有的镜像文件(包括临时文件),默认为否.因为我这里只有一个镜像所以只有这一个啦.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images --all=true</span></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 通过使用<code>--digests=true|false</code>,列出镜像的数字摘要值,默认为否.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images --digests=true</span></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              sha256:0add3ace90ecb4adbf7777e9a   4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 通过使用<code>--quiet=true|false</code>,仅输出ID信息,默认为否.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images -q</span></span><br><span class="line">4ab4c602aa5e</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images --quiet=false</span></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<h3 id="◆查询网络镜像◆"><a href="#◆查询网络镜像◆" class="headerlink" title="◆查询网络镜像◆"></a>◆查询网络镜像◆</h3><p>使用docker search命令可以搜索远端仓库中共享的镜像,默认搜索官方仓库中的镜像.用法为docker search TERM.</p>
<p><strong>实例1：</strong> 使用<code>search</code>搜索一个Centos镜像文件.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker search centos</span></span><br><span class="line"></span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   5048                [OK]            </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              119                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                 CentOS-6 6.10 x86_64 / CentOS-7 7.5.1804 x86…   102                </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 仅显示自动创建的镜像,默认为否.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker search --automated=true centos</span></span><br><span class="line">Flag --automated has been deprecated, use --filter=is-automated=<span class="literal">true</span> instead</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">ansible/centos7-ansible           Ansible on Centos7                              119                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                CentOS-6 6.10 x86_64 / CentOS-7 7.5.1804 x86…   102                                     [OK]</span><br><span class="line">consol/centos-xfce-vnc            Centos container with <span class="string">"headless"</span> VNC session…   73                                      [OK]</span><br><span class="line">imagine10255/centos6-lnmp-php56   centos6-lnmp-php56                              48                                      [OK]</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 搜索所有自动创建的评价为1+的带nginx关键字的镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker search --automated -s 3 nginx</span></span><br><span class="line"></span><br><span class="line">Flag --automated has been deprecated, use --filter=is-automated=<span class="literal">true</span> instead</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">jwilder/nginx-proxy                                    Automated Nginx reverse proxy <span class="keyword">for</span> docker con…   1488                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm                                Container running Nginx + PHP-FPM capable of…   663</span><br></pre></td></tr></table></figure></p>
<h3 id="◆拉镜像到本地◆"><a href="#◆拉镜像到本地◆" class="headerlink" title="◆拉镜像到本地◆"></a>◆拉镜像到本地◆</h3><p>可以使用docker pull命令直接从Docker Hub镜像源来下载镜像,该命令的格式为docker pull NAME[：TAG].其中NAME是镜像仓库的名称,TAG是镜像的标签,通常情况下,描述一个镜像需要包括”名称+标签”.</p>
<p><strong>实例：</strong> 通过<code>pull</code>命令获取一个Centos系统镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker pull centos</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<h3 id="◆给镜像加标签◆"><a href="#◆给镜像加标签◆" class="headerlink" title="◆给镜像加标签◆"></a>◆给镜像加标签◆</h3><p>为了方便在后续工作中使用特定镜像,还可以使用docker tag命令来为本地镜像任意添加新的标签.</p>
<p><strong>实例：</strong> 为Centos镜像添加一个新的mycentos:latest镜像标签.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag centos:latest mycentos:latest</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">mycentos            latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<p>上图可看到,当再次使用docker images列出本地主机上镜像信息,可以看到多了一个拥有mycentos:latest标签的镜像,细心的你可能注意到,这些mycentos:latest镜像的ID跟centos:latest完全一致,它们实际上指向同一个镜像文件,只是别名不同而已.docker tag命令添加的标签实际上起到了类似链接的作用.</p>
<h3 id="◆查询镜像详情◆"><a href="#◆查询镜像详情◆" class="headerlink" title="◆查询镜像详情◆"></a>◆查询镜像详情◆</h3><p>使用docker inspect命令可以获取该镜像的详细信息,包括制作者、适应架构、各层的数字摘要等.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker inspect hello-world</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67f"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"hello-world:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [</span><br><span class="line">            <span class="string">"hello-world@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788"</span></span><br><span class="line">        ],</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<p>上面的输出有很多,只不过我这里简单显示了,如果我们只要其中一项内容时,可以使用参数<code>-f</code>来指定你要打印的数据,例如下面我们来演示一下获取当前镜像的Id这个字段的数据.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker inspect -f &#123;&#123;".Id"&#125;&#125; hello-world</span></span><br><span class="line"></span><br><span class="line">sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67f</span><br></pre></td></tr></table></figure></p>
<h3 id="◆查询镜像分层◆"><a href="#◆查询镜像分层◆" class="headerlink" title="◆查询镜像分层◆"></a>◆查询镜像分层◆</h3><p>既然镜像文件由多个层组成,那么怎么知道各个层的内容具体是什么呢?这时候可以使用history子命令,该命令将列出各层的创建信息.注意过长的命令被自动截断了,可以使用前面提到的<code>--no-trunc</code>选项来输出完整命令.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker history centos:latest</span></span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">1e1148e4cc2c        8 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0B</span></span><br><span class="line">&lt;missing&gt;           8 days ago          /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema.sc…   0B</span></span><br><span class="line">&lt;missing&gt;           8 days ago          /bin/sh -c <span class="comment">#(nop) ADD file:6f877549795f4798a…   202MB</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆删除指定镜像◆"><a href="#◆删除指定镜像◆" class="headerlink" title="◆删除指定镜像◆"></a>◆删除指定镜像◆</h3><p>使用docker rmi命令可以删除镜像,其中IMAGE可以为标签或ID,如果要强制删除可加<code>-f</code>这个选项.</p>
<p><strong>删除镜像：</strong> 通过<code>rmi</code>命令删除mycentos这个标签.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">mycentos            latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi mycentos:latest</span></span><br><span class="line">Untagged: mycentos:latest</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<p><strong>强制删除：</strong> 强制删除系统全部镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker rmi -f $(docker images -q)</span></span><br><span class="line"></span><br><span class="line">Deleted: sha256:1e1148e4cc2c148c6890a18e3b2d2dde41a6745ceb4e5fe94a923d811bf82ddb</span><br><span class="line">Deleted: sha256:071d8bd765171080d01682844524be57ac9883e53079b6ac66707e192ea25956</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Deleted: sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67f</span><br></pre></td></tr></table></figure></p>
<h3 id="◆镜像导入导出◆"><a href="#◆镜像导入导出◆" class="headerlink" title="◆镜像导入导出◆"></a>◆镜像导入导出◆</h3><p><strong>导出操作：</strong> 通过<code>save 镜像ID &gt;</code>导出centos镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker save 1e1148e4cc2c &gt; /root/centos.tar</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">centos.tar</span><br></pre></td></tr></table></figure></p>
<p><strong>导入操作：</strong> 通过<code>load &lt; 文件名</code>导入centos镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker load &lt; centos.tar</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              1e1148e4cc2c        8 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br></pre></td></tr></table></figure></p>
<h3 id="◆镜像命令速查◆"><a href="#◆镜像命令速查◆" class="headerlink" title="◆镜像命令速查◆"></a>◆镜像命令速查◆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker info                       #查询守护进程的系统资源设置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker search                     #仓库镜像的查询</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker pull                       #仓库镜像的下载</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images                     #本地镜像的查询</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi                        #本地镜像的删除</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi -f $(docker images -q) #强制删除全部镜像(Image)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi -f &lt;image id&gt;          #强制删除指定镜像(Image)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker history 镜像名              #查询镜像的分层</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker save 镜像ID &gt; /root/*.tar  #镜像的导出</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker load &lt; /root/*.tar         #镜像的导入</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="管理Docker容器"><a href="#管理Docker容器" class="headerlink" title="管理Docker容器"></a>管理Docker容器</h2><p>容器是Docker的另一个核心概念,简单来说,容器是镜像的一个运行实例.所不同的是,镜像是静态的只读文件,而容器带有运行时需要的可写文件层.如果认为虚拟机是模拟运行的一整套操作系统和跑在上面的应用,那么Docker容器就是独立运行的一个应用,以及它们必需的运行环境.</p>
<p>下面的例子将具体介绍围绕容器的重要操作,包括创建一个容器、启动容器、终止一个容器、进入容器内执行操作、删除容器和通过导入导出容器来实现容器迁移等.</p>
<h3 id="◆创建容器◆"><a href="#◆创建容器◆" class="headerlink" title="◆创建容器◆"></a>◆创建容器◆</h3><p>从现在开始,忘掉臃肿的虚拟机吧,对容器进行操作就跟直接操作应用一样简单、快速.Docker容器实在太轻量级了,用户可以随时创建或删除容器.</p>
<p><strong>新建容器：</strong> 可以使用docker create命令新建一个容器,使用docker create命令新建的容器处于停止状态,可以使用docker start命令来启动它.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        9 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker create -it centos:latest</span></span><br><span class="line">23c881ac33c526e60811978a418be92c6a022c106e6d59d989fb7b932dc3473a</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start 23c881ac33c5</span></span><br><span class="line">23c881ac33c5</span><br></pre></td></tr></table></figure></p>
<p><strong>新建并启动：</strong> 除了创建容器后通过start命令来启动,也可以直接新建并启动容器.所需要的命令主要为docker run,等价于先执行docker create命令,再执行docker start命令.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        9 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run centos:latest</span></span><br></pre></td></tr></table></figure></p>
<p><strong>守护态运行：</strong> 更多的时候,需要让Docker容器在后台以守护态Daemonized形式运行.此时,可以通过添加<code>-d</code>参数来实现.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              1e1148e4cc2c        9 days ago          202MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -itd ubuntu:latest</span></span><br><span class="line">540fd59ee8899a38c4302d83549bd113ad159064ec41c9475a773cbc0fd2dfb8</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d centos:latest /bin/sh</span></span><br><span class="line">505a728a2bed9e96b3e4615c4e528bd55285a856dc201bb50d4ed5c9e0a52566</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d centos:latest /bin/sh -c "echo hello"</span></span><br><span class="line">6c8fc14a6637928442b768bee0b2d3af800464192e7fce295f39ccdd91b73572</span><br></pre></td></tr></table></figure></p>
<h3 id="◆终止容器◆"><a href="#◆终止容器◆" class="headerlink" title="◆终止容器◆"></a>◆终止容器◆</h3><p>可以使用docker stop来终止一个运行中的容器,也可以使用docker kill命令干掉一个容器.</p>
<p><strong>stop终止容器：</strong> 指定通过stop终止一个容器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker stop 540fd59ee889</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">540fd59ee889        ubuntu:latest       <span class="string">"/bin/bash"</span>         6 minutes ago       Up 6 minutes                            festive_liskov</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker stop 540fd59ee889</span></span><br><span class="line">540fd59ee889</span><br></pre></td></tr></table></figure></p>
<p><strong>kill终止容器：</strong>docker kill命令会直接发送SIGKILL信号来强行终止容器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">84da1ad9f06c        centos:latest       <span class="string">"/bin/bash"</span>         33 seconds ago      Up 32 seconds                           hungry_bhabha</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker kill 84da1ad9f06c</span></span><br><span class="line">84da1ad9f06c</span><br></pre></td></tr></table></figure></p>
<h3 id="◆进入容器◆"><a href="#◆进入容器◆" class="headerlink" title="◆进入容器◆"></a>◆进入容器◆</h3><p>在使用-d参数时,容器启动后会进入后台,用户无法看到容器中的信息,也无法进行操作.<br>这个时候如果需要进入容器进行操作,有多种方法,包括使用官方的attach或exec命令,以及第三方的nsenter工具等.下面分别介绍一下.</p>
<p><strong>attach进入容器：</strong> attach是Docker自带的命令,下面我们使用它来进入容器的内部吧.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES</span><br><span class="line">540fd59ee889        ubuntu:latest       <span class="string">"/bin/bash"</span>         About a minute ago   Up About a minute                       festive_liskov</span><br><span class="line">300560ca1c88        centos:latest       <span class="string">"/bin/bash"</span>         3 minutes ago        Up 3 minutes                            ecstatic_raman</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker attach 300560ca1c88</span></span><br><span class="line">[root@300560ca1c88 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>但是使用attach命令有时候并不方便,当多个窗口同时用attach命令连到同一个容器的时候,所有窗口都会同步显示.当某个窗口因命令阻塞时,其他窗口也无法执行操作了,接着下面的命令就更好一些了.</p>
<p><strong>exec进入容器：</strong> Docker从1.3.0版本起提供了一个更加方便的exec命令,可以在容器内直接执行任意命令.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">540fd59ee889        ubuntu:latest       <span class="string">"/bin/bash"</span>         3 minutes ago       Up 3 minutes                            festive_liskov</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it 540fd59ee889 /bin/bash</span></span><br><span class="line">root@540fd59ee889:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到,一个bash终端打开了,在不影响容器内其他应用的前提下,用户可以很容易与容器进行交互,通过指定<code>-it</code>参数来保持标准输入打开,并且分配一个伪终端.通过exec命令对容器执行操作是最为推荐的方式.</p>
<h3 id="◆删除容器◆"><a href="#◆删除容器◆" class="headerlink" title="◆删除容器◆"></a>◆删除容器◆</h3><p>可以使用docker rm命令来删除处于终止或退出状态的容器.</p>
<p><strong>rm 删除容器：</strong> 通过<code>rm -f</code>命令强制删除一个容器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">fa6110bdb3df        centos:latest       <span class="string">"/bin/bash"</span>         3 seconds ago       Up 2 seconds                            eager_mirzakhani</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rm -f fa6110bdb3df</span></span><br><span class="line">fa6110bdb3df</span><br></pre></td></tr></table></figure></p>
<h3 id="◆命令速查◆"><a href="#◆命令速查◆" class="headerlink" title="◆命令速查◆"></a>◆命令速查◆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run                      #容器的创建或启动</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --restart=always     #设置容器的自启动</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps                       #运行中的容器的查询</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps --no-trunc            #查看容器状态</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start/stop               #容器启动/关闭</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker stop $(docker ps -a -q)  #停止所有运行中的容器(Container)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rm $(docker ps -a -q)    #删除全部容器(Container)</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start/stop 镜像名         #通过容器别名启动/停止</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker inspect 镜像名            #查看容器所有基本信息</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker logs 镜像名               #查看容器日志</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker stats 镜像名              #查看容器所占用的系统资源</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec 容器名 容器内执行的命令#容器执行命令</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it 容器名 /bin/bash  #登入容器的bash</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -it 容器名 /bin/bash   #进入一个镜像</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Docker-持久存储"><a href="#Docker-持久存储" class="headerlink" title="Docker 持久存储"></a>Docker 持久存储</h2><p>生产环境中使用Docker的过程中,往往需要对数据进行持久化,或者需要在多个容器之间进行数据共享,这必然涉及容器的数据管理操作,容器管理中主要有两种方式,<code>数据卷(Data Volumes)</code>,<code>数据卷容器(Data Volume Containers)</code>,本小结将首先介绍如何在容器内创建数据卷,并且把本地的目录或文件挂载到容器内的数据卷中.接下来,会介绍如何使用数据卷容器在容器和主机、容器和容器之间共享数据,并实现数据的备份和恢复.</p>
<h3 id="◆数据卷◆"><a href="#◆数据卷◆" class="headerlink" title="◆数据卷◆"></a>◆数据卷◆</h3><p>数据卷是一个可供容器使用的特殊目录,它将主机操作系统目录直接映射进容器,类似于Linux中的mount操作.</p>
<blockquote>
<p>数据卷可以提供很多有用的特性,如下所示:</p>
<blockquote>
<p>● 数据卷可以在容器之间共享和重用,容器间传递数据将变得高效方便.<br>● 对数据卷内数据的修改会立马生效,无论是容器内操作还是本地操作.<br>● 对数据卷的更新不会影响镜像,解耦了应用和数据.<br>● 卷会一直存在,直到没有容器使用,可以安全地卸载它.</p>
</blockquote>
</blockquote>
<p><strong>挂载一个本地目录作为数据卷:</strong></p>
<p>1.在本地主机创建一个目录,并写入一些数据,来模拟本地数据.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /data</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "hello mkdirs.com" &gt; /data/index.html</span></span><br></pre></td></tr></table></figure></p>
<p>2.开启容器,并让容器读取本地的<code>/data</code>目录.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 8080:80 --name MyWeb -v /data:/usr/local/apache2/htdocs httpd:latest</span></span><br><span class="line">2882b3edda42fe153a897d3dc21f73835eb57c14019b5e810066c34e0eda4c0c</span><br><span class="line"></span><br><span class="line">[参数解释]</span><br><span class="line"></span><br><span class="line">	-d     <span class="comment">#以守护进程运行</span></span><br><span class="line">	-p     <span class="comment">#将容器中的80口,映射到本地主机的8080</span></span><br><span class="line">	--name <span class="comment">#指定一个容器名称</span></span><br><span class="line">	-v     <span class="comment">#上面指的是,将本地/data目录挂载得到容器中的/usr/local目录中.</span></span><br><span class="line">	-P     <span class="comment">#是将容器服务暴露的端口,是自动映射到本地主机的临时端口.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1:8080</span></span><br><span class="line">hello mkdirs.com</span><br></pre></td></tr></table></figure></p>
<h3 id="◆数据卷容器◆"><a href="#◆数据卷容器◆" class="headerlink" title="◆数据卷容器◆"></a>◆数据卷容器◆</h3><p>如果用户需要在多个容器之间共享一些持续更新的数据,最简单的方式是使用数据卷容器.数据卷容器也是一个容器,但是它的目的是专门用来提供数据卷供其他容器挂载.</p>
<p>1.首先,创建一个数据卷容器dbdata,并在容器中创建一个数据卷/dbdata的目录.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -itd -v /usr/local/apache2/htdocs --name dbdata centos:latest</span></span><br><span class="line">1bc16a7978db7db83a4a107bf2fe1c4c42c4c7fffa7dd92372a6aacb68ccfdd0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it dbdata /bin/bash</span></span><br><span class="line">[root@1bc16a7978db /]<span class="comment"># echo "hello mkdirs.com" &gt; /usr/local/apache2/htdocs/index.html</span></span><br><span class="line">[root@1bc16a7978db /]<span class="comment"># ls -lh /usr/local/apache2/htdocs/index.html</span></span><br><span class="line">total 4.0K</span><br><span class="line">-rw-r--r-- 1 root root 17 Dec 15 11:37 index.html</span><br><span class="line"></span><br><span class="line">[root@1bc16a7978db /]<span class="comment"># exit</span></span><br></pre></td></tr></table></figure></p>
<p>2.然后,可以在其他容器中使用<code>--volumes-from</code>来挂载dbdata容器中的数据卷,例如创建db1和db2两个容器,并从dbdata容器挂载数据卷.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 801:80 --volumes-from dbdata --name db1 httpd:latest</span></span><br><span class="line">123e75f38947f3294ac77a08bf4380f311d09cc176b576c61499139d75b35db3</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 802:80 --volumes-from dbdata --name db2 httpd:latest</span></span><br><span class="line">a4e0f8016af6b89e31a637b1482b0849dcea26e4004298def4abce44c84d6dd6</span><br></pre></td></tr></table></figure></p>
<p>3.分别访问两个不同的端口,会发现网页展现效果是一样的,也就是说,db1和db2共享了dbdata容器里指定文件的内容.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep 801</span></span><br><span class="line">tcp6       0      0 :::801                  :::*                    LISTEN      3998/docker-proxy</span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep 802</span></span><br><span class="line">tcp6       0      0 :::802                  :::*                    LISTEN      4157/docker-proxy</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1:801</span></span><br><span class="line">hello mkdirs.com</span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1:802</span></span><br><span class="line">hello mkdirs.com</span><br></pre></td></tr></table></figure></p>
<p>使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态,如果删除了挂载的容器(包括dbdata、db1和db2),数据卷并不会被自动删除.如果要删除一个数据卷,必须在删除最后一个还挂载着它的容器时显式使用<code>docker rm -v</code>命令来指定同时删除关联的容器.</p>
<h3 id="◆容器备份恢复◆"><a href="#◆容器备份恢复◆" class="headerlink" title="◆容器备份恢复◆"></a>◆容器备份恢复◆</h3><p><strong>数据备份：</strong> 使用下面的命令来备份dbdata数据卷容器内的数据卷,并把它备份到当前目录下.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run --volumes-from dbdata -v $(pwd):/backup --name workers centos:latest tar -czvf /backup/backup.tar /usr/local/apache2/htdocs</span></span><br><span class="line"></span><br><span class="line">tar: Removing leading `/<span class="string">' from member names</span></span><br><span class="line"><span class="string">/usr/local/apache2/htdocs/</span></span><br><span class="line"><span class="string">/usr/local/apache2/htdocs/index.html</span></span><br><span class="line"><span class="string">[root@localhost ~]# ls</span></span><br><span class="line"><span class="string">backup.tar</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令稍微有点复杂,具体分析一下,首先利用centos镜像创建了一个容器workers.使用<code>--volumes-from dbdata</code>参数来让workers容器挂载dbdata容器的数据卷(即dbdata数据卷),使用<code>-v $(pwd):/backup</code>参数来挂载本地的当前目录到workers容器的/backup目录.workers容器启动后,使用了<code>tar -czvf/backup/backup.tar /usr/local/apache2/htdocs</code>命令来将<code>/usr/local/apache2/htdocs</code>下内容备份为容器内的<code>/backup/backup.tar</code>,即宿主主机当前目录下的backup.tar.</p>
<p><strong>数据恢复：</strong> 如果要将数据恢复到一个容器,可以按照下面的步骤操作.</p>
<p>1.首先创建一个带有数据卷的容器dbdata_backup.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -itd -v /usr/local/apache2/htdocs --name dbdata_backup centos:latest /bin/bash</span></span><br><span class="line">a207d887bfa07cc0e1737efb197950cac3b2c5647391348b1b8fa8b873c58667</span><br></pre></td></tr></table></figure></p>
<p>2.然后创建另一个新的容器,挂载dbdata2的容器,并使用untar解压备份文件到所挂载的容器卷中.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run --volumes-from dbdata_backup -v $(pwd):/backup busybox tar -xzvf /backup/backup.tar</span></span><br><span class="line"></span><br><span class="line">usr/<span class="built_in">local</span>/apache2/htdocs/</span><br><span class="line">usr/<span class="built_in">local</span>/apache2/htdocs/index.html</span><br></pre></td></tr></table></figure></p>
<p>本小结介绍了通过数据卷和数据卷容器对容器内数据进行共享、备份和恢复等操作,通过这些机制,即使容器在运行中出现故障,用户也不必担心数据发生丢失,只需要快速地重新创建容器即可.<br><br></p>
<h2 id="Docker-端口映射"><a href="#Docker-端口映射" class="headerlink" title="Docker 端口映射"></a>Docker 端口映射</h2><p>在实践中,经常会碰到需要多个服务组件容器共同协作的情况,这往往需要多个容器之间有能够互相访问到对方的服务,Docker提供了两个很方便的功能来满足服务访问的基本需求：一个是允许映射容器内应用的服务端口到本地宿主主机,另一个是互联机制实现多个容器间通过容器名来快速访问,下面我们来分别介绍一下吧.</p>
<h3 id="◆从外部访问容器应用◆"><a href="#◆从外部访问容器应用◆" class="headerlink" title="◆从外部访问容器应用◆"></a>◆从外部访问容器应用◆</h3><p><strong>随机分配端口：</strong> 当容器中运行一些网络应用,要让外部访问这些应用时,可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射.当使用-P(大写的)标记时,Docker会随机映射一个<code>49000~49900</code>的端口到内部容器开放的网络端口.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -P --name myweb httpd:latest</span></span><br><span class="line">afb211e832c16c80822632fe0864838781cee2132993f93cde8c915e242f9df5</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">afb211e832c1        httpd:latest        <span class="string">"httpd-foreground"</span>   3 seconds ago       Up 2 seconds        0.0.0.0:32768-&gt;80/tcp   myweb</span><br></pre></td></tr></table></figure></p>
<p><strong>指定分配端口：</strong> 当我们使用<code>-p(小写的)</code>可以指定要映射的端口,并且,在一个指定端口上只可以绑定一个容器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 8080:80 --name myweb1 httpd:latest</span></span><br><span class="line">b47f6131dea02c8cd22a75049e97c28cc4bb25bc6bf5cd36645c1ccb4210554e</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面说明,将容器的80端口,映射到本地的8080</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1.8080</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="◆映射所有接口地址◆"><a href="#◆映射所有接口地址◆" class="headerlink" title="◆映射所有接口地址◆"></a>◆映射所有接口地址◆</h3><p><strong>映射指定端口：</strong> 格式将容器的80端口映射到本机的80端口.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 80:80 --name myweb2 httpd:latest</span></span><br><span class="line">9c3d0f8ad0bbfa75cc6534f93f959192316125a2776a2c909c71dc9dfb5a8b79</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>映射多个端口：</strong> 多次使用<code>-p</code>标记可以绑定多个端口.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 8080:80 -p 1000:21 --name myweb3 httpd:latest</span></span><br><span class="line">097ceb68128b58195c990dff720e39ca1717809cc2019d3f31466dee6fd32aec</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep "8080"</span></span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      2306/docker-proxy</span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep "1000"</span></span><br><span class="line">tcp6       0      0 :::1000                 :::*                    LISTEN      2317/docker-proxy</span><br></pre></td></tr></table></figure></p>
<h3 id="◆映射到指定地址◆"><a href="#◆映射到指定地址◆" class="headerlink" title="◆映射到指定地址◆"></a>◆映射到指定地址◆</h3><p><strong>映射到指定地址的指定端口：</strong> 将容器中的80端口映射到本地指定IP地址上去.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ifconfig ens32:0 192.168.1.10 netmask 255.255.255.0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig ens32:0</span></span><br><span class="line">ens32:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether 00:0c:29:1e:14:e2  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 192.168.1.10:8080:80 --name myweb_port httpd:latest</span></span><br><span class="line">7385faa5d476cb37dd7d201cd0ec939501c9bdb23ec1c8239245c30d2be9abe7</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep "8080"</span></span><br><span class="line">tcp        0      0 192.168.1.10:8080       0.0.0.0:*               LISTEN      2585/docker-proxy</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 192.168.1.10:8080</span></span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>映射到指定地址的任意端口：</strong> ：本地主机会自动分配一个端口,绑定到容器的80口.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 192.168.1.10::80 --name myweb_port1 httpd:latest</span></span><br><span class="line">7a5a105ae0827aaff68864a28b5f9b8a9592af3551f7deca564ea2d6d5a249b3</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -antp |grep "80"</span></span><br><span class="line">tcp        0      0 192.168.1.10:8080       0.0.0.0:*               LISTEN      2585/docker-proxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#还可以使用udp标记来指定udp端口</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 192.168.1.10:5000:5000/udp --name myweb_udp httpd:latest</span></span><br><span class="line">b9cc6333a63109a70a1d2e645b1ff5046988b472dea3bb4f4d010f1478951adf</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -an |grep "5000"</span></span><br><span class="line">udp        0      0 192.168.1.10:5000       0.0.0.0:*</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Docker-容器互联"><a href="#Docker-容器互联" class="headerlink" title="Docker 容器互联"></a>Docker 容器互联</h2><p>容器的互联(linking)是一种让多个容器中应用进行快速交互的方式,它会在源和接收容器之间创建连接关系,接收容器可以通过容器名快速访问到源容器,而不用指定具体的IP地址.</p>
<p>1.使用<code>--link</code>参数可以让容器之间安全地进行交互,下面先创建一个新的MySQL数据库容器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d --name mysqldb mysql:latest</span></span><br><span class="line">c1770a69ed29944466ce013c42ac2a0391651c88381e41be05308eab80458390</span><br></pre></td></tr></table></figure></p>
<p>2.然后创建一个新的web容器,并将它连接到MySQL容器,使之能够通信.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -P --name web --link mysqldb:mysqldb httpd:latest</span></span><br><span class="line">8b2bfcbbe00f6966c511fdbbbc16e40736ab8d6aa89d229e224f38d12c4643df</span><br></pre></td></tr></table></figure></p>
<p>此时,mysqldb容器和web容器建立互联关系,<code>--link</code>参数的格式为<code>--link name：alias</code>,其中name是要连接的容器名称,alias是这个连接的别名.</p>
<p>Docker相当于在两个互联的容器之间创建了一个虚机通道,而且不用映射它们的端口到宿主主机上.在启动mysqldb容器的时候并没有使用-p和-P标记,从而避免了暴露数据库服务端口到外部网络上.</p>
<h3 id="环境变量传递参数"><a href="#环境变量传递参数" class="headerlink" title="环境变量传递参数"></a>环境变量传递参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">USER root</span><br><span class="line">MAINTAINER lyshark@139.com</span><br><span class="line"></span><br><span class="line">ENV USER none</span><br><span class="line">ENV PASD none</span><br></pre></td></tr></table></figure>
<p>在docker run 命令中通过 -e标记来传递环境变量，这样容器运行时就可以使用该变量：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --env <span class="string">"USER=root"</span> \</span><br><span class="line">               --env <span class="string">"PASD=1233"</span> df434s4s /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>查看环境变量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker inspect centos:v3</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it b2f327865a98 env</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆Apache◆"><a href="#◆Apache◆" class="headerlink" title="◆Apache◆"></a>◆Apache◆</h3><p>Apache是世界使用排名第一的Web服务器软件,它可以运行在几乎所有广泛使用的计算机平台上,由于其跨平台和安全性被广泛使用,是最流行的Web服务器端软件之一.它快速、可靠并且可通过简单的API扩充,将Perl/Python等解释器编译到服务器中.</p>
<p>1.拉取镜像,并在本地创建一个测试页.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull httpd:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              2a51bb06dc8b        4 weeks ago         132MB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /web</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo "hello world" &gt; /web/index.html</span></span><br></pre></td></tr></table></figure></p>
<p>2.运行http容器,并访问测试.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 8080:80 --name MyWeb -v /web:/usr/local/apache2/htdocs httpd:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># curl 127.0.0.1:8080</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<h3 id="◆GitLab◆"><a href="#◆GitLab◆" class="headerlink" title="◆GitLab◆"></a>◆GitLab◆</h3><p>Gitlab是一款非常强大的开源源码管理系统.它支持基于Git的源码管理、代码评审、issue跟踪、活动管理、wiki页面,持续集成和测试等功能.基于Gitlab,用户可以自己搭建一套类似Github的开发协同平台.</p>
<p>1.安装并启动postgresql.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull sameersbn/postgresql:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">sameersbn/postgresql   latest              3c0142eb3992        5 months ago        204MB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --name gitlab_postgresql -d \</span></span><br><span class="line">--env <span class="string">'DB_NAME=gitlab'</span> \</span><br><span class="line">--env <span class="string">'DB_USER=gitlab'</span> --env <span class="string">'DB_PASS=gitlab'</span> \</span><br><span class="line">sameersbn/postgresql:latest</span><br></pre></td></tr></table></figure></p>
<p>2.安装redis.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull sameersbn/redis:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">sameersbn/redis        latest              ad607f019b8c        4 months ago        84.8MB</span><br><span class="line">sameersbn/postgresql   latest              3c0142eb3992        5 months ago        204MB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --name gitlab_redis -itd sameersbn/redis:latest</span></span><br></pre></td></tr></table></figure></p>
<p>3.安装GitLab.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull sameersbn/gitlab:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">sameersbn/gitlab       latest              336fe9c19d92        6 days ago          1.96GB</span><br><span class="line">sameersbn/redis        latest              ad607f019b8c        4 months ago        84.8MB</span><br><span class="line">sameersbn/postgresql   latest              3c0142eb3992        5 months ago        204MB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --name gitlab -d sameersbn/gitlab \</span></span><br><span class="line">--link gitlab_postgresql:postgresql --link gitlab_redis:redis \</span><br><span class="line">--publish 10022:22 --publish 10080:80 \</span><br><span class="line">--env <span class="string">'GITLAB_PORT=10080'</span> --env <span class="string">'GITLAB_SSH_PORT=10022'</span> \</span><br><span class="line">--env <span class="string">'GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string'</span> \</span><br><span class="line">sameersbn/gitlab:latest</span><br></pre></td></tr></table></figure></p>
<h3 id="◆WordPress◆"><a href="#◆WordPress◆" class="headerlink" title="◆WordPress◆"></a>◆WordPress◆</h3><p>WordPress是使用PHP语言开发的博客平台,用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站.也可以把WordPress当作一个内容管理系统(CMS)来使用,WordPress逐步演化成一款内容管理系统软件,它是使用PHP语言和MySQL数据库开发的.用户可以在支持PHP和MySQL数据库的服务器上使用自己的博客.</p>
<p>1.首先安装一个MariaDB数据库,并配置好初始密码.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mariadb:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mariadb             latest              b468922dbbd7        3 weeks ago         366MB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --name MyDataBase --env MYSQL_ROOT_PASSWORD=example -d mariadb:latest</span></span><br></pre></td></tr></table></figure></p>
<p>2.拉取WordPress镜像,并运行,将容器内的80口映射到宿主机的8080口上.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull wordpress:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run --name MyWordPress --link MyDataBase:MariaDB -p 8080:80 -d wordpress:latest</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Docker-制作镜像"><a href="#Docker-制作镜像" class="headerlink" title="Docker 制作镜像"></a>Docker 制作镜像</h2><h3 id="◆手动制作镜像◆"><a href="#◆手动制作镜像◆" class="headerlink" title="◆手动制作镜像◆"></a>◆手动制作镜像◆</h3><p>1.拉centos:latest 镜像为基础镜像<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull centos:latest</span></span><br></pre></td></tr></table></figure></p>
<p>2.启动并进入容器内部<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -itd --name lamp --net=host centos:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker exec -it lamp /bin/bash</span></span><br></pre></td></tr></table></figure></p>
<p>3.安装lamp环境<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y httpd httpd-devel \</span><br><span class="line">               mariadb mariadb-server mysql-devel \</span><br><span class="line">               php php-mysql php-common php-gd \</span><br><span class="line">               php-mbstring php-mcrypt php-devel php-xml</span><br></pre></td></tr></table></figure></p>
<p>4.写入一下内容.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello lyshark"</span> &gt; /var/www/html/index.html</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/sbin/apachectl"</span> &gt;&gt; /etc/bashrc</span><br></pre></td></tr></table></figure></p>
<p>5.保存镜像,将所退出的容器用commit命令保存为一个新的my_ssh：centos镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS             </span><br><span class="line">ebfae6bcd308        centos:latest       <span class="string">"/bin/bash"</span>         2 minutes ago       Up 2 minutes      </span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker commit ebfae6bcd308 httpd:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">httpd               latest              89cb7bb995ba        4 seconds ago       329 MB</span><br><span class="line">docker.io/centos    latest              9f38484d220f        2 months ago        202 MB</span><br></pre></td></tr></table></figure></p>
<p>6.启动容器,并添加端口映射10000–&gt;22.其中10000是宿主主机的端口,22是容器的SSH服务监听端口.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -itd -p 8080:80 httpd:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -p 10000:22 -itd my_ssh:centos</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆编译制作镜像◆"><a href="#◆编译制作镜像◆" class="headerlink" title="◆编译制作镜像◆"></a>◆编译制作镜像◆</h3><p>1.首先我们要解决Docker容器内不得网络问题.修改DockerDNS,默认没有文件自行创建即可.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/default/docker</span></span><br><span class="line">docker_OPTS=<span class="string">"--dns 8.8.8.8 --dns 114.114.114.114"</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure></p>
<p>2.接着在当前目录创建一个Dockerfile文件,和一个index.html文件,文件内容如下.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM centos:latest                          // 指定基础镜像</span><br><span class="line">USER root                                   // 以root身份运行</span><br><span class="line">MAINTAINER lyshark@139.com                  // 个人描述信息</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/nginx/sbin/       // 指定环境变量</span><br><span class="line"></span><br><span class="line">RUN yum install -y gcc wget pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br><span class="line">WORKDIR /tmp/</span><br><span class="line">RUN wget http://nginx.org/download/nginx-1.15.12.tar.gz</span><br><span class="line">RUN tar -xzf nginx-1.15.12.tar.gz           // 解压文件</span><br><span class="line">WORKDIR /tmp/nginx-1.15.12                  // 切换默认目录</span><br><span class="line"></span><br><span class="line">RUN useradd -s /sbin/nologin -M nginx \     // 编译安装过程</span><br><span class="line">&amp;&amp; ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --user=nginx --group=nginx \</span><br><span class="line">&amp;&amp; make \</span><br><span class="line">&amp;&amp; make install</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello docker"</span> &gt; /usr/<span class="built_in">local</span>/nginx/html/index.html</span><br><span class="line"><span class="comment"># COPY ./index.html /usr/local/nginx/html/      // 拷贝文件</span></span><br><span class="line">EXPOSE 80                                       // 内部侦听端口</span><br><span class="line">ENTRYPOINT  /usr/<span class="built_in">local</span>/nginx/sbin/nginx &amp;&amp; tail -f /usr/<span class="built_in">local</span>/nginx/logs/access.log  // 镜像入口</span><br><span class="line"><span class="comment">#CMD ["/usr/local/nginx/sbin/nginx"]            // 作用同上</span></span><br></pre></td></tr></table></figure></p>
<p>3.编译镜像文件，并运行镜像<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:latest .</span><br><span class="line">docker run -d -p80:80 nginx:latest</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Registry-仓库搭建"><a href="#Registry-仓库搭建" class="headerlink" title="Registry 仓库搭建"></a>Registry 仓库搭建</h2><p>Docker Registry工具是Docker内置的私有仓库解决方案,新版本的Registry基于Golang进行了重构,提供更好的性能和扩展性,并且支持Docker 1.6+的API,非常适合用来构建私有的镜像注册服务器.官方仓库中也提供了Registry的镜像,因此用户可以通过容器运行和源码安装两种方<br>式来使用Registry.</p>
<p>实验规划<code>Docker服务器:192.168.1.5</code>,<code>Docker客户端：192.168.1.25</code>,请在服务端配置好网桥服务.</p>
<h3 id="◆服务端配置◆"><a href="#◆服务端配置◆" class="headerlink" title="◆服务端配置◆"></a>◆服务端配置◆</h3><p>1.将本机配置成网桥,使之能够互相通信.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-ens32</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens32</span></span><br><span class="line">DEVICE=eno16777728</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">BRIDGE=br0</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysconfig/network-scripts/ifcfg-br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-br0</span></span><br><span class="line">TYPE=Bridge</span><br><span class="line">DEVICE=br0</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.1.15</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure></p>
<p>2.在服务端<code>192.168.1.5</code>上拉取registry镜像包.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull registry:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry            latest              2e2f252f3c88        3 months ago        33.3MB</span><br></pre></td></tr></table></figure></p>
<p>3.在服务端192.168.1.5运行docker私有仓库成功执行，则我们的docker私有仓库搭建成功.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run -itd -p 5000:5000 -v /registry:/var/lib/registry --restart=always --privileged=true --name my_registry registry:latest</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆客户端上传◆"><a href="#◆客户端上传◆" class="headerlink" title="◆客户端上传◆"></a>◆客户端上传◆</h3><p>1.此处我们以<code>hello-world</code>为例,首先要先把它拉取下来.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull hello-world:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/hello-world   latest              4ab4c602aa5e        3 months ago        1.84 kB</span><br></pre></td></tr></table></figure></p>
<p>2.其次给<code>hello-world</code>镜像打个tag表示新的版本,过程中指定服务器IP地址.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker tag hello-world 192.168.1.5:5000/hello-world:latest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.1.5:5000/hello-world   latest              4ab4c602aa5e        3 months ago        1.84 kB</span><br><span class="line">docker.io/hello-world          latest              4ab4c602aa5e        3 months ago        1.84 kB</span><br></pre></td></tr></table></figure></p>
<p>3.由于docker私有仓库服务器,默认是基于https传输的,所以我们需要在客户端<code>192.168.1.25</code>做相关设置,禁止使用https传输.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://njrds9qc.mirror.aliyuncs.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>:[<span class="string">"192.168.1.5:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.依次执行下面两条命令,重新启动docker让其加载我们的配置文件.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable docker</span></span><br></pre></td></tr></table></figure></p>
<p>5.执行推送命令,将我们的<code>hello-world</code>推送到服务器上.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">192.168.1.5:5000/hello-world   latest              4ab4c602aa5e        3 months ago        1.84 kB</span><br><span class="line">docker.io/hello-world          latest              4ab4c602aa5e        3 months ago        1.84 kB</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># docker push 192.168.1.5:5000/hello-world:latest</span></span><br><span class="line">The push refers to a repository [192.168.1.5:5000/hello-world]</span><br><span class="line">428c97da766c: Pushed</span><br><span class="line">latest: digest: sha256:1a6fd470b9ce10849be79e99529a88371dff60c60aab424c077007f6979b4812 size: 524</span><br></pre></td></tr></table></figure></p>
<p>6.在服务器端查看刚刚提交的一个请求.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l /registry/docker/registry/v2/repositories</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 5 root root 55 Dec 17 20:23 hello-world</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># curl http://192.168.1.5:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"hello-world"</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="◆客户端拉取◆"><a href="#◆客户端拉取◆" class="headerlink" title="◆客户端拉取◆"></a>◆客户端拉取◆</h3><p>1.客户端修改一下配置文件,指定以下服务器地址.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">"registry-mirrors"</span>: [<span class="string">"https://njrds9qc.mirror.aliyuncs.com"</span>],</span><br><span class="line">        <span class="string">"insecure-registries"</span>:[<span class="string">"192.168.1.5:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.修改Docker配置文件,开启局域网模式.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在/etc/default/docker添加一行：</span><br><span class="line"></span><br><span class="line">DOCKER_OPTS=<span class="string">"--insecure-registry 192.168.1.5:5000"</span></span><br><span class="line"></span><br><span class="line">或在/etc/sysconfig/docker文件中添加</span><br><span class="line"></span><br><span class="line">OPTIONS=<span class="string">'--selinux-enabled --insecure-registry 192.168.1.5:5000'</span></span><br></pre></td></tr></table></figure></p>
<p>3.重新启动Docker,加载配置文件.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl enable docker</span></span><br></pre></td></tr></table></figure></p>
<p>4.通过命令下载测试镜像.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull 192.168.1.5:5000/hello-world:latest</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>

      
    </div>

    

<!--增加的底部版权代码-->
<div>
      
        ﻿
<br>
<div class="my_post_copyright">
  <p><span>文章作者:</span><a href="/" title="访问 王瑞 的个人博客">王瑞</a></p>
  <p><span>发布时间:</span>2018年12月14日 - 12:12</p>
  <p><span>原始链接:</span><a href="/2018/12/14/Linux 服务配置/Docker-容器配置笔记/" title="Docker 容器配置笔记">https://localhost/2018/12/14/Linux 服务配置/Docker-容器配置笔记/</a>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者</p>
</div>

      
</div>
    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux-服务配置/" rel="tag"> <i class="fa fa-tag"></i> Linux 服务配置</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/02/Linux 服务配置/Ansible 自动化工具入门/" rel="next" title="Ansible 自动化工具入门">
                <i class="fa fa-chevron-left"></i> Ansible 自动化工具入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/24/MySQL/MySQL-数据库基础命令-1/" rel="prev" title="MySQL 数据库基础命令(1)">
                MySQL 数据库基础命令(1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="王瑞">
            
              <p class="site-author-name" itemprop="name">王瑞</p>
              <div class="site-description motion-element" itemprop="description">记录点滴技术成长之路</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">80</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/lyshark" title="GitHub &rarr; https://github.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:1181506874@qq.com" title="E-Mail &rarr; mailto:1181506874@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://plus.google.com/lyshark" title="Google &rarr; https://plus.google.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://twitter.com/lyshark" title="Twitter &rarr; https://twitter.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" title="QQ &rarr; http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://weixin.qq.com" title="Wechat &rarr; https://weixin.qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-weixin"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-容器简介"><span class="nav-text">Docker 容器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理Docker镜像"><span class="nav-text">管理Docker镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆查询本地镜像◆"><span class="nav-text">◆查询本地镜像◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆查询网络镜像◆"><span class="nav-text">◆查询网络镜像◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆拉镜像到本地◆"><span class="nav-text">◆拉镜像到本地◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆给镜像加标签◆"><span class="nav-text">◆给镜像加标签◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆查询镜像详情◆"><span class="nav-text">◆查询镜像详情◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆查询镜像分层◆"><span class="nav-text">◆查询镜像分层◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆删除指定镜像◆"><span class="nav-text">◆删除指定镜像◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆镜像导入导出◆"><span class="nav-text">◆镜像导入导出◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆镜像命令速查◆"><span class="nav-text">◆镜像命令速查◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理Docker容器"><span class="nav-text">管理Docker容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆创建容器◆"><span class="nav-text">◆创建容器◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆终止容器◆"><span class="nav-text">◆终止容器◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆进入容器◆"><span class="nav-text">◆进入容器◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆删除容器◆"><span class="nav-text">◆删除容器◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆命令速查◆"><span class="nav-text">◆命令速查◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-持久存储"><span class="nav-text">Docker 持久存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆数据卷◆"><span class="nav-text">◆数据卷◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆数据卷容器◆"><span class="nav-text">◆数据卷容器◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆容器备份恢复◆"><span class="nav-text">◆容器备份恢复◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-端口映射"><span class="nav-text">Docker 端口映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆从外部访问容器应用◆"><span class="nav-text">◆从外部访问容器应用◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆映射所有接口地址◆"><span class="nav-text">◆映射所有接口地址◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆映射到指定地址◆"><span class="nav-text">◆映射到指定地址◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-容器互联"><span class="nav-text">Docker 容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量传递参数"><span class="nav-text">环境变量传递参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆Apache◆"><span class="nav-text">◆Apache◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆GitLab◆"><span class="nav-text">◆GitLab◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆WordPress◆"><span class="nav-text">◆WordPress◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-制作镜像"><span class="nav-text">Docker 制作镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆手动制作镜像◆"><span class="nav-text">◆手动制作镜像◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆编译制作镜像◆"><span class="nav-text">◆编译制作镜像◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Registry-仓库搭建"><span class="nav-text">Registry 仓库搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆服务端配置◆"><span class="nav-text">◆服务端配置◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆客户端上传◆"><span class="nav-text">◆客户端上传◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆客户端拉取◆"><span class="nav-text">◆客户端拉取◆</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">

<!-- 屏蔽版权开始 -->
&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王瑞</span>
<!-- 屏蔽版权结束 -->
	 | 页面托管于 GitHub/Coding 主机

  

  
</div>









        








        
      </div>
    </footer>

    

    

    

    
  </div>

<script type="text/javascript" src="/js/coloured.js"></script>



  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/poi.model.json"},"display":{"superSample":2,"width":300,"height":290,"position":"left","hOffset":0,"vOffset":-10},"mobile":{"show":true,"scale":0},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
